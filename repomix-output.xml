This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  agents/
    voguedrop-code-validator.md
  commands/
    commit-automatically.md
    explain-code.md
  settings.local.json
.cursor/
  rules/
    canvas-implementation-guide.mdc
app/
  (auth)/
    login/
      _components/
        LoginForm.tsx
      page.tsx
    signup/
      _components/
        SignupForm.tsx
      page.tsx
    layout.tsx
  (home)/
    _components/
      BackgroundEffects.tsx
      CTASection.tsx
      FeaturesSection.tsx
      Footer.tsx
      GalleryItems.tsx
      GallerySection.tsx
      HeroSection.tsx
      HomeHeader.tsx
      HowItWorksSection.tsx
  api/
    auth/
      login/
        route.ts
      logout/
        route.ts
      signup/
        route.ts
    canvas/
      categories/
        route.ts
      effects/
        route.ts
      favorite/
        route.ts
      favorites/
        route.ts
      generate/
        route.ts
      generate-async/
        route.ts
      history/
        route.ts
      image-brush/
        history/
          route.ts
        route.ts
      jobs/
        [jobId]/
          check-webhook/
            route.ts
          poll/
            route.ts
          route.ts
      library/
        route.ts
    sound/
      generate-async/
        route.ts
      generate-from-video/
        route.ts
      history/
        route.ts
      jobs/
        [jobId]/
          poll/
            route.ts
          route.ts
    upload/
      music/
        route.ts
    video/
      check-render/
        route.ts
      render/
        route.ts
      save/
        route.ts
    webhooks/
      fal-ai/
        route.ts
  canvas/
    _components/
      Canvas.tsx
      CanvasControls.tsx
      CanvasHistoryPanel.tsx
      CanvasLayout.tsx
      CanvasModals.tsx
      EffectsGallery.tsx
      EffectsSection.tsx
      ImageBrushModal.tsx
      ImageSection.tsx
      index.ts
      LeftPanel.tsx
      PrompterSection.tsx
      QuickActionsBar.tsx
      VideoGenerationProgress.tsx
    _context/
      CanvasContext.tsx
    _hooks/
      index.ts
      useBeforeUnload.ts
      useCanvas.ts
      useCanvasSettings.ts
      useEffectsData.tsx
      useEffectsManager.ts
      useFavoritesManager.ts
      useModalManager.ts
      useSlotManager.ts
      useVideoGeneration.ts
    _services/
      api.ts
    _types/
      index.ts
    page.tsx
  gallery/
    _components/
      CategoryFilter.tsx
      GalleryGrid.tsx
      GalleryGridSkeleton.tsx
      GalleryHeader.tsx
      GalleryItem.tsx
      GalleryPageClient.tsx
      GallerySection.tsx
    page.tsx
  video-editor/
    _components/
      remotion/
        CompositePreview.tsx
      BufferingSpinner.tsx
      ContextMenu.tsx
      FullscreenPreviewModal.tsx
      PlayerControls.tsx
      RenderingModal.tsx
      SoundClip.tsx
      SoundGenerationProgress.tsx
      SoundLibraryModal.tsx
      TextClip.tsx
      TextEditorModal.tsx
      TextOverlayEditor.tsx
      Timeline.tsx
      TimelineControls.tsx
      TimelinePlayhead.tsx
      TimelineSelectionBox.tsx
      TimelineTrack.tsx
      VideoClipSelector.tsx
      VideoLibraryModal.tsx
      VideoPreview.tsx
    _constants/
      index.ts
    _context/
      ClipContext.tsx
      HistoryContext.tsx
      PlaybackContext.tsx
      ProjectContext.tsx
      Providers.tsx
    _hooks/
      useDragAndDrop.ts
      useRemotionPlayer.ts
      useSelectionState.ts
      useTimelineResize.ts
      useTimelineState.ts
      useVideoPlayback.ts
      useVideoPreloader.ts
      useVideoSoundGeneration.ts
    _types/
      timeline-props.ts
    _utils/
      audio-analysis.ts
      clip-operations.ts
      timeline-helpers.ts
      timeline-utils.ts
      video-metadata.ts
      video.ts
    page.tsx
  error.tsx
  external-imports.css
  global-error.tsx
  globals.css
  layout.tsx
  loading.tsx
  page.tsx
components/
  layout/
    Header.tsx
  modals/
    library/
      components/
        LibraryCard.tsx
        LibrarySidebar.tsx
        LibraryUpload.tsx
      hooks/
        useLibraryData.ts
      utils/
        constants.ts
      LibraryModalBase.tsx
    BaseModal.tsx
    CameraModal.tsx
    EffectModal.tsx
    LibraryModal.tsx
    ModelModal.tsx
    ProjectTitleModal.tsx
    PromptModal.tsx
  ui/
    button.tsx
    hover-video.tsx
    input.tsx
    slider.tsx
    textarea.tsx
    video-preview.tsx
constants/
  fonts.ts
  text-editor.ts
contexts/
  CanvasContext.tsx
  ModalContext.tsx
  ThemeContext.tsx
docs/
  features/
    canvas-ai-video-generation-mvp.md
    canvas-ai-video-generation.md
    fal.ai.md
    image_brush.md
    image-brush-deployment.md
  task/
    task_image_brush.md
    task.md
  edge-function-deployment.md
  frontend-architecture.md
  fullstack-architecture.md
  prd.md
  project-brief.md
  RLS_POLICIES.md
  STORAGE_BUCKET_SETUP.md
  storage-structure.md
  SUPABASE_SETUP.md
  timeline-resize-width-zero-bug.md
  ui-ux-spec.md
  user-upload-setup-guide.md
  video-editor-overlay-troubleshooting.md
  video-render-setup-guide.md
hooks/
  useTranslation.ts
lambda/
  deploy-instructions.md
  render.ts
lib/
  api/
    gallery.ts
    upload.ts
  auth/
    AuthContext.tsx
  constants/
    errors.ts
  db/
    video-generations.ts
  logging/
    video-generation-logger.ts
  sound/
    utils.ts
  supabase/
    client.ts
    middleware.ts
    server.ts
    service.ts
    storage.ts
  utils/
    session.server.ts
    session.ts
  fal-ai.ts
  fal-webhook.ts
  supabase.ts
  theme.ts
  tokens.ts
  utils.ts
locales/
  en/
    canvas.json
    home.json
  ko/
    canvas.json
  en.json
public/
  file.svg
  globe.svg
  next.svg
  placeholder.svg
  vercel.svg
  window.svg
scripts/
  download-all-fonts.sh
src/
  remotion/
    fonts.d.ts
    index.ts
    inject-fonts.ts
    load-fonts.ts
    VideoComposition.tsx
styles/
  fonts.css
supabase/
  .temp/
    cli-latest
  functions/
    _shared/
      cors.ts
    image-brush/
      index.ts
    upload-video/
      index.ts
  migrations/
    001_20250130_add_canvas_categories.sql
    002_20250130_add_canvas_ai_tables.sql
    003_20250130_migrate_creations_to_effect_templates.sql
    004_20250130_drop_creations_table.sql
    005_20250131_fix_video_generations_table.sql
    006_20250131_fix_rls_policies.sql
    007_20250131_disable_rls_mvp.sql
    008_20250131_create_storage_bucket.sql
    009_20250131_add_job_tracking_fields.sql
    010_20250131_create_video_generation_logs.sql
    011_20250131_update_rls_for_webhooks.sql
    012_20250131_update_rls_strict_policies.sql
    013_20250201_update_video_generations_user_id_to_uuid.sql
    014_20250204_add_favorite_to_video_generations.sql
    015_20250113_create_sound_generations.sql
    016_create_video_renders_table.sql
    017_add_content_hash_to_video_renders.sql
    018_20250114_add_sound_generation_grouping.sql
    019_20250814_create_project_saves_table_v2.sql
    020_20250814_update_video_renders_table.sql
    021_add_generation_type_to_sound_generations.sql
    021_add_project_saves_foreign_key.sql
    022_simplify_project_saves.sql
    023_20250320_user_uploaded_videos.sql
    024_20250320_storage_policies_user_uploads.sql
    025_add_thumbnail_to_project_saves.sql
    025_create_user_uploaded_music.sql
    20240119_create_image_brush_history.sql
    20240120_update_image_brush_history_urls.sql
    README.md
  seeds/
    canvas-effect-templates.sql
types/
  auth.ts
  canvas.ts
  database.ts
  image-brush.ts
  library-modal.ts
  sound.ts
  video-editor.ts
.gitignore
.mcp.json
CLAUDE.md
components.json
eslint.config.mjs
fix-lambda-permission.sh
lambda-invoke-policy.json
middleware.ts
next.config.ts
package.json
postcss.config.mjs
README.md
remotion.config.ts
stagewise.json
tailwind.config.ts
tsconfig.json
vercel-lambda-fix.md
vercel.json
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(ls:*)",
      "Bash(npm install:*)",
      "Bash(mkdir:*)",
      "Bash(mkdir:*)",
      "Bash(npm run dev:*)",
      "Bash(git mv:*)",
      "Bash(rmdir:*)",
      "Bash(npm run build:*)",
      "Bash(npm run build:*)",
      "Bash(npm run lint)",
      "Bash(git commit:*)",
      "Bash(git add:*)",
      "Bash(rm:*)",
      "Bash(grep:*)",
      "Bash(git diff:*)",
      "mcp__supabase__list_tables",
      "mcp__supabase__execute_sql",
      "mcp__context7__resolve-library-id",
      "Bash(chmod:*)",
      "mcp__playwright__browser_type",
      "mcp__playwright__browser_click",
      "mcp__playwright__browser_navigate",
      "mcp__playwright__browser_evaluate",
      "mcp__playwright__browser_drag",
      "mcp__supabase__apply_migration",
      "WebSearch",
      "Bash(cd:*)",
      "Bash(cp:*)",
      "Bash(tree:*)",
      "Bash(mv:*)",
      "mcp__remotion-documentation-own__remotion-documentation",
      "Bash(touch:*)",
      "Bash(npx tsc:*)",
      "Bash(git fetch:*)",
      "Bash(npx supabase inspect db:*)",
      "Bash(npx remotion compositions:*)",
      "WebFetch(domain:remotionlambda-useast1-54qz3bnxt2.s3.us-east-1.amazonaws.com)",
      "Bash(aws configure:*)",
      "Bash(npx remotion lambda renders:*)",
      "Bash(npm run remotion:lambda:sites:*)",
      "Bash(git checkout:*)",
      "Bash(./scripts/download-fonts-simple.sh:*)",
      "Bash(npx remotion:*)",
      "Bash(./scripts/download-fonts.sh:*)",
      "Bash(curl:*)",
      "Bash(wget:*)",
      "Bash(./scripts/download-all-fonts.sh:*)",
      "Bash(npx supabase:*)"
    ],
    "deny": [
      "Bash(npm run dev:*)"
    ],
    "defaultMode": "acceptEdits",
    "additionalDirectories": [
      "/Users/srlee/Desktop/커서개발/3."
    ]
  },
  "enabledMcpjsonServers": [
    "remotion-documentation-own"
  ],
  "hooks": {
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "say \"작업이 모두 완료되었습니다. 확인해주세요.\""
          }
        ]
      }
    ]
  },
  "outputStyle": "Explanatory"
}
</file>

<file path="app/(auth)/login/_components/LoginForm.tsx">
'use client'

import { useState } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import type { LoginFormData } from '@/types/auth'
import { createClient } from '@/lib/supabase/client'

export function LoginForm() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const supabase = createClient()
  const [formData, setFormData] = useState<LoginFormData>({
    email: '',
    password: '',
  })
  const [error, setError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  
  const redirect = searchParams.get('redirect') || '/'

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    // Validate email format
    if (!validateEmail(formData.email)) {
      setError('Please enter a valid email address')
      return
    }

    // Validate password
    if (!formData.password) {
      setError('Password is required')
      return
    }

    setIsLoading(true)

    try {
      const { error: signInError } = await supabase.auth.signInWithPassword({
        email: formData.email,
        password: formData.password,
      })

      if (signInError) {
        throw signInError
      }

      // Redirect to the intended page or home
      router.push(redirect)
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message)
      } else {
        setError('An error occurred during login')
      }
    } finally {
      setIsLoading(false)
    }
  }

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    })
    // Clear error when user starts typing
    if (error) setError(null)
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <div className="rounded-lg bg-destructive/10 border border-destructive/20 p-4">
          <p className="text-sm text-destructive">{error}</p>
        </div>
      )}

      <div>
        <label htmlFor="email" className="block text-sm font-medium text-foreground mb-2">
          Email
        </label>
        <input
          id="email"
          name="email"
          type="email"
          autoComplete="email"
          required
          value={formData.email}
          onChange={handleChange}
          className="input-base"
          placeholder="you@example.com"
        />
      </div>

      <div>
        <label htmlFor="password" className="block text-sm font-medium text-foreground mb-2">
          Password
        </label>
        <input
          id="password"
          name="password"
          type="password"
          autoComplete="current-password"
          required
          value={formData.password}
          onChange={handleChange}
          className="input-base"
          placeholder="••••••••"
        />
      </div>

      <button
        type="submit"
        disabled={isLoading}
        className="w-full rounded-lg bg-primary px-4 py-3 text-sm font-semibold text-primary-foreground hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-background disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 shadow-lg shadow-primary/20"
      >
        {isLoading ? 'Signing in...' : 'Sign in'}
      </button>
    </form>
  )
}
</file>

<file path="app/(auth)/login/page.tsx">
import { LoginForm } from './_components/LoginForm'
import Link from 'next/link'

export default function LoginPage() {
  return (
    <div className="relative flex min-h-screen items-center justify-center px-4">
      <Link href="/" className="absolute top-8 left-8 font-sans text-xl font-bold text-primary tracking-tight hover:opacity-80 transition-opacity">
        vogue drop
      </Link>
      
      <div className="relative mx-auto w-full max-w-md space-y-8">
        <div className="text-center">
          <h1 className="text-4xl font-bold tracking-tight text-foreground">
            Welcome back
          </h1>
          <p className="mt-2 text-base text-text-secondary">
            Sign in to continue creating amazing fashion videos
          </p>
        </div>
        
        <div className="relative rounded-2xl bg-surface/50 backdrop-blur-sm border border-border px-8 py-10 shadow-xl">
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-primary/10 to-secondary/10 opacity-50" />
          <div className="relative">
            <LoginForm />
            
            <div className="mt-6 text-center text-sm">
              <span className="text-text-secondary">Don&apos;t have an account? </span>
              <Link 
                href="/signup" 
                className="font-medium text-primary hover:text-primary/80 transition-colors"
              >
                Sign up
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/(auth)/signup/_components/SignupForm.tsx">
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import type { SignupFormData } from '@/types/auth'
import { createClient } from '@/lib/supabase/client'

export function SignupForm() {
  const router = useRouter()
  const supabase = createClient()
  const [formData, setFormData] = useState<SignupFormData>({
    email: '',
    password: '',
    confirmPassword: '',
  })
  const [error, setError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)

  const validateEmail = (email: string) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    return emailRegex.test(email)
  }

  const validatePassword = (password: string) => {
    return password.length >= 8
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setError(null)

    // Validate email format
    if (!validateEmail(formData.email)) {
      setError('Please enter a valid email address')
      return
    }

    // Validate password strength
    if (!validatePassword(formData.password)) {
      setError('Password must be at least 8 characters long')
      return
    }

    // Validate password match
    if (formData.password !== formData.confirmPassword) {
      setError('Passwords do not match')
      return
    }

    setIsLoading(true)

    try {
      const { error: signUpError } = await supabase.auth.signUp({
        email: formData.email,
        password: formData.password,
      })

      if (signUpError) {
        throw signUpError
      }

      // Auto sign in after successful signup
      const { error: signInError } = await supabase.auth.signInWithPassword({
        email: formData.email,
        password: formData.password,
      })

      if (signInError) {
        throw signInError
      }

      // Redirect to home page on successful signup
      router.push('/')
    } catch (err) {
      if (err instanceof Error) {
        setError(err.message)
      } else {
        setError('An error occurred during signup')
      }
    } finally {
      setIsLoading(false)
    }
  }

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData({
      ...formData,
      [e.target.name]: e.target.value,
    })
    // Clear error when user starts typing
    if (error) setError(null)
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {error && (
        <div className="rounded-lg bg-destructive/10 border border-destructive/20 p-4">
          <p className="text-sm text-destructive">{error}</p>
        </div>
      )}

      <div>
        <label htmlFor="email" className="block text-sm font-medium text-foreground mb-2">
          Email
        </label>
        <input
          id="email"
          name="email"
          type="email"
          autoComplete="email"
          required
          value={formData.email}
          onChange={handleChange}
          className="input-base"
          placeholder="you@example.com"
        />
      </div>

      <div>
        <label htmlFor="password" className="block text-sm font-medium text-foreground mb-2">
          Password
        </label>
        <input
          id="password"
          name="password"
          type="password"
          autoComplete="new-password"
          required
          value={formData.password}
          onChange={handleChange}
          className="input-base"
          placeholder="••••••••"
        />
        <p className="mt-1 text-xs text-muted-foreground">
          Must be at least 8 characters long
        </p>
      </div>

      <div>
        <label htmlFor="confirmPassword" className="block text-sm font-medium text-foreground mb-2">
          Confirm Password
        </label>
        <input
          id="confirmPassword"
          name="confirmPassword"
          type="password"
          autoComplete="new-password"
          required
          value={formData.confirmPassword}
          onChange={handleChange}
          className="input-base"
          placeholder="••••••••"
        />
      </div>

      <button
        type="submit"
        disabled={isLoading}
        className="w-full rounded-lg bg-primary px-4 py-3 text-sm font-semibold text-primary-foreground hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 focus:ring-offset-background disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200 shadow-lg shadow-primary/20"
      >
        {isLoading ? 'Creating account...' : 'Create account'}
      </button>
    </form>
  )
}
</file>

<file path="app/(auth)/signup/page.tsx">
import { SignupForm } from './_components/SignupForm'
import Link from 'next/link'

export default function SignupPage() {
  return (
    <div className="relative flex min-h-screen items-center justify-center px-4">
      <Link href="/" className="absolute top-8 left-8 font-sans text-xl font-bold text-primary tracking-tight hover:opacity-80 transition-opacity">
        vogue drop
      </Link>
      
      <div className="relative mx-auto w-full max-w-md space-y-8">
        <div className="text-center">
          <h1 className="text-4xl font-bold tracking-tight text-foreground">
            Create your account
          </h1>
          <p className="mt-2 text-base text-text-secondary">
            Join VogueDrop to start creating amazing fashion videos
          </p>
        </div>
        
        <div className="relative rounded-2xl bg-surface/50 backdrop-blur-sm border border-border px-8 py-10 shadow-xl">
          <div className="absolute inset-0 rounded-2xl bg-gradient-to-br from-primary/10 to-secondary/10 opacity-50" />
          <div className="relative">
            <SignupForm />
            
            <div className="mt-6 text-center text-sm">
              <span className="text-text-secondary">Already have an account? </span>
              <Link 
                href="/login" 
                className="font-medium text-primary hover:text-primary/80 transition-colors"
              >
                Sign in
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/(auth)/layout.tsx">
import type { Metadata } from 'next'

export const metadata: Metadata = {
  title: {
    template: '%s | VogueDrop',
    default: 'Authentication',
  },
  description: 'Sign in or create an account to start creating amazing fashion videos',
}

export default function AuthLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="min-h-screen bg-background relative overflow-hidden">
      {/* Background effects similar to home page */}
      <div className="absolute inset-0">
        <div className="absolute inset-0 bg-gradient-to-br from-primary/20 via-background to-secondary/20 animate-gradient" />
        <div className="absolute top-0 left-0 w-96 h-96 bg-primary/30 rounded-full blur-3xl animate-pulse" />
        <div className="absolute bottom-0 right-0 w-96 h-96 bg-secondary/30 rounded-full blur-3xl animate-pulse delay-1000" />
      </div>
      {children}
    </div>
  )
}
</file>

<file path="app/(home)/_components/BackgroundEffects.tsx">
export function BackgroundEffects() {
  return (
    <>
      <div className="absolute inset-0 bg-gradient-to-br from-primary/10 via-background to-secondary/10" />
      <div className="absolute inset-0">
        <div className="absolute top-20 left-20 w-72 h-72 bg-primary/20 rounded-full filter blur-[100px] animate-pulse" />
        <div className="absolute bottom-20 right-20 w-96 h-96 bg-secondary/20 rounded-full filter blur-[120px] animate-pulse" />
      </div>
    </>
  );
}
</file>

<file path="app/(home)/_components/CTASection.tsx">
"use client"

import { Button } from "@/components/ui/button"
import { Zap } from "lucide-react"
import Link from "next/link"
import { useAuth } from "@/lib/auth/AuthContext"

interface CTASectionProps {
  texts: {
    title: {
      line1: string
      line2: string
    }
    subtitle: string
    button: string
  }
}

export function CTASection({ texts }: CTASectionProps) {
  const { user } = useAuth();
  
  return (
    <section className="py-16 sm:py-24 md:py-32 relative overflow-hidden">
      <div className="absolute inset-0 bg-gradient-to-br from-primary/10 via-black to-secondary/10" />
      <div className="relative z-10 max-w-4xl mx-auto px-4 sm:px-6 text-center">
        <h2 className="text-3xl sm:text-4xl md:text-6xl font-bold mb-6">
          {texts.title.line1}
          <span className="block gradient-text">
            {texts.title.line2}
          </span>
        </h2>
        <p className="text-lg sm:text-xl text-gray-300 mb-8">
          {texts.subtitle}
        </p>
        <Link href={user ? "/canvas" : "/login"}>
          <Button size="lg" className="bg-primary hover:bg-primary/90 text-white shadow-lg shadow-primary/20">
            {user ? "Go to Canvas" : texts.button}
            <Zap className="ml-2 w-4 h-4" />
          </Button>
        </Link>
      </div>
    </section>
  )
}
</file>

<file path="app/(home)/_components/FeaturesSection.tsx">
import Image from "next/image"
import { Target, Film, Circle, Monitor, Volume2, Sparkles } from "lucide-react"

interface Feature {
  title: string
  description: string
  image: string
  icon: string
}

interface FeaturesSectionProps {
  texts: {
    title: string
    subtitle: string
    tagline?: string
    items: Feature[]
  }
}

const iconMap: Record<string, React.ComponentType<{ className?: string }>> = {
  target: Target,
  film: Film,
  circle: Circle,
  monitor: Monitor,
  volume: Volume2,
  sparkles: Sparkles
}

const iconColors = [
  "bg-green-500/20 text-green-400",
  "bg-blue-500/20 text-blue-400",
  "bg-yellow-500/20 text-yellow-400",
  "bg-purple-500/20 text-purple-400",
  "bg-pink-500/20 text-pink-400",
  "bg-indigo-500/20 text-indigo-400"
]

export function FeaturesSection({ texts }: FeaturesSectionProps) {
  return (
    <section id="features" className="py-16 sm:py-24 md:py-32 relative bg-black">
      <div className="max-w-7xl mx-auto px-4 sm:px-6">
        <div className="text-center mb-6">
          <div className="flex items-center justify-center gap-2 mb-6">
            <Film className="w-6 h-6 text-gray-400" />
            <h2 className="text-4xl sm:text-5xl md:text-6xl font-bold">
              {texts.title}
            </h2>
          </div>
          <p className="text-lg sm:text-xl text-gray-300 max-w-3xl mx-auto">
            {texts.subtitle}
          </p>
        </div>

        <div className="flex flex-wrap justify-center gap-3 mb-12">
          <div className="flex items-center gap-2 px-4 py-2 bg-gray-800/50 rounded-full">
            <Target className="w-4 h-4 text-green-400" />
            <span className="text-sm text-gray-300">Zooms & Pans</span>
          </div>
          <div className="flex items-center gap-2 px-4 py-2 bg-gray-800/50 rounded-full">
            <Film className="w-4 h-4 text-blue-400" />
            <span className="text-sm text-gray-300">Retro Filters</span>
          </div>
          <div className="flex items-center gap-2 px-4 py-2 bg-gray-800/50 rounded-full">
            <Volume2 className="w-4 h-4 text-purple-400" />
            <span className="text-sm text-gray-300">AI Sound</span>
          </div>
        </div>

        {texts.tagline && (
          <p className="text-center text-gray-400 mb-12">
            {texts.tagline}
          </p>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {texts.items.map((feature, index) => {
            const Icon = iconMap[feature.icon] || Sparkles
            const iconColorClass = iconColors[index] || iconColors[0]
            
            return (
              <div
                key={index}
                className="group relative bg-gradient-to-b from-gray-900/90 to-gray-950/90 backdrop-blur rounded-2xl border border-gray-800 hover:border-gray-700 hover:shadow-2xl hover:shadow-white/5 hover:-translate-y-1 transition-all duration-300 overflow-hidden"
              >
                <div className="p-6">
                  <div className={`w-10 h-10 rounded-lg ${iconColorClass} flex items-center justify-center mb-4`}>
                    <Icon className="w-5 h-5" />
                  </div>
                  
                  <h3 className="text-xl font-semibold mb-2 text-white">
                    {feature.title}
                  </h3>
                  <p className="text-gray-400 text-sm mb-4">
                    {feature.description}
                  </p>
                </div>
                
                <div className="px-6 pb-6">
                  <div className="relative h-48 w-full overflow-hidden rounded-2xl">
                    <Image
                      src={feature.image}
                      alt={feature.title}
                      fill
                      className="object-cover group-hover:scale-105 transition-transform duration-300"
                    />
                  </div>
                </div>
              </div>
            )
          })}
        </div>
      </div>
    </section>
  )
}
</file>

<file path="app/(home)/_components/Footer.tsx">
import Link from "next/link"

interface FooterProps {
  texts: {
    tagline: string
    sections: {
      product: {
        title: string
        links: string[]
      }
      company: {
        title: string
        links: string[]
      }
      legal: {
        title: string
        links: string[]
      }
    }
    copyright: string
  }
}

export function Footer({ texts }: FooterProps) {
  return (
    <footer className="py-12 sm:py-16 border-t border-gray-800">
      <div className="max-w-7xl mx-auto px-4 sm:px-6">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
          <div className="col-span-2 md:col-span-1">
            <div className="text-xl sm:text-2xl font-bold text-primary tracking-tight mb-4">
              vogue drop
            </div>
            <p className="text-sm sm:text-base text-gray-400">
              {texts.tagline}
            </p>
          </div>
          <div>
            <h3 className="font-semibold mb-4 text-sm sm:text-base">{texts.sections.product.title}</h3>
            <ul className="space-y-2 text-gray-400">
              {texts.sections.product.links.map((link, index) => (
                <li key={index}>
                  <Link href="#" className="text-sm sm:text-base hover:text-white transition-colors">
                    {link}
                  </Link>
                </li>
              ))}
            </ul>
          </div>
          <div>
            <h3 className="font-semibold mb-4 text-sm sm:text-base">{texts.sections.company.title}</h3>
            <ul className="space-y-2 text-gray-400">
              {texts.sections.company.links.map((link, index) => (
                <li key={index}>
                  <Link href="#" className="text-sm sm:text-base hover:text-white transition-colors">
                    {link}
                  </Link>
                </li>
              ))}
            </ul>
          </div>
          <div>
            <h3 className="font-semibold mb-4 text-sm sm:text-base">{texts.sections.legal.title}</h3>
            <ul className="space-y-2 text-gray-400">
              {texts.sections.legal.links.map((link, index) => (
                <li key={index}>
                  <Link href="#" className="text-sm sm:text-base hover:text-white transition-colors">
                    {link}
                  </Link>
                </li>
              ))}
            </ul>
          </div>
        </div>
        <div className="mt-8 sm:mt-12 pt-8 border-t border-gray-800 text-center text-gray-400">
          <p className="text-sm sm:text-base">{texts.copyright}</p>
        </div>
      </div>
    </footer>
  )
}
</file>

<file path="app/(home)/_components/GalleryItems.tsx">
"use client"

import { Play } from "lucide-react"
import Image from "next/image"
import { getPublicUrl } from "@/lib/supabase"
import type { EffectTemplateWithMedia } from "@/types/database"

interface GalleryItemsProps {
  items: EffectTemplateWithMedia[]
}

export function GalleryItems({ items }: GalleryItemsProps) {
  if (items.length === 0) {
    return (
      <div className="col-span-full text-center py-12">
        <p className="text-gray-400">No gallery items available yet.</p>
      </div>
    )
  }

  return (
    <>
      {items.map((item) => (
        <div
          key={item.id}
          className="group relative aspect-[9/16] bg-gray-900 rounded-lg overflow-hidden cursor-pointer"
        >
          <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent z-10" />
          
          {/* Always show gradient as fallback/background */}
          <div className="w-full h-full bg-gradient-to-br from-primary/20 to-secondary/20 absolute inset-0" />
          
          {item.preview_media?.storage_path && (
            (() => {
              const url = getPublicUrl(item.preview_media.storage_path)
              const isVideo = url.endsWith('.mp4') || url.endsWith('.webm')
              
              if (isVideo) {
                return (
                  <video
                    src={url}
                    className="w-full h-full object-cover z-[1]"
                    autoPlay
                    loop
                    muted
                    playsInline
                    onError={(e) => {
                      // Hide broken video and show gradient fallback
                      e.currentTarget.style.display = 'none'
                    }}
                  />
                )
              } else {
                return (
                  <Image
                    src={url}
                    alt={item.name || "Gallery item"}
                    fill
                    className="object-cover z-[1]"
                    sizes="(max-width: 640px) 50vw, (max-width: 1024px) 33vw, 25vw"
                    onError={(e) => {
                      // Hide broken image and show gradient fallback
                      e.currentTarget.style.display = 'none'
                    }}
                  />
                )
              }
            })()
          )}
          
          <div className="absolute bottom-2 sm:bottom-4 left-2 sm:left-4 right-2 sm:right-4 z-20">
            <h3 className="font-semibold text-sm sm:text-base">
              {item.name}
            </h3>
          </div>
          
          <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity z-30">
            <div className="w-12 sm:w-16 h-12 sm:h-16 bg-white/20 backdrop-blur-sm rounded-full flex items-center justify-center">
              <Play className="w-5 sm:w-6 h-5 sm:h-6 ml-1" />
            </div>
          </div>
        </div>
      ))}
    </>
  )
}
</file>

<file path="app/(home)/_components/GallerySection.tsx">
import { Suspense } from "react"
import { getGalleryItems } from "@/lib/api/gallery"
import { GalleryItems } from "./GalleryItems"

export const dynamic = 'force-dynamic'
export const revalidate = 0

interface GallerySectionProps {
  texts: {
    title: string
    subtitle: string
  }
}

async function GalleryData() {
  try {
    const items = await getGalleryItems()
    // Limit to 8 items for the home page
    const limitedItems = items.slice(0, 8)
    return <GalleryItems items={limitedItems} />
  } catch {
    return (
      <div className="col-span-full text-center py-12">
        <p className="text-red-400 mb-2">Failed to load gallery items</p>
        <p className="text-sm text-gray-400">Please try again later</p>
      </div>
    )
  }
}

function GalleryItemsLoading() {
  return (
    <>
      {[...Array(8)].map((_, index) => (
        <div
          key={index}
          className="relative aspect-[9/16] bg-gray-900 rounded-lg overflow-hidden animate-pulse"
        >
          <div className="w-full h-full bg-gray-800" />
        </div>
      ))}
    </>
  )
}

export async function GallerySection({ texts }: GallerySectionProps) {
  return (
    <section id="gallery" className="py-16 sm:py-24 md:py-32">
      <div className="max-w-7xl mx-auto px-4 sm:px-6">
        <div className="text-center mb-12 sm:mb-16">
          <h2 className="text-3xl sm:text-4xl md:text-5xl font-bold mb-4">
            {texts.title}
          </h2>
          <p className="text-lg sm:text-xl text-gray-400">
            {texts.subtitle}
          </p>
        </div>

        <div className="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-3 sm:gap-4">
          <Suspense fallback={<GalleryItemsLoading />}>
            <GalleryData />
          </Suspense>
        </div>
      </div>
    </section>
  )
}
</file>

<file path="app/(home)/_components/HeroSection.tsx">
"use client"

import { Button } from "@/components/ui/button";
import { ArrowRight } from "lucide-react";
import Link from "next/link";
import Image from "next/image";
import { HomeHeader } from "./HomeHeader";
import { BackgroundEffects } from "./BackgroundEffects";
import { useAuth } from "@/lib/auth/AuthContext";

interface HeroSectionProps {
  texts: {
    badge: string
    title: {
      line1: string
      line2: string
    }
    description: string
    cta: {
      primary: string
      secondary: string
    }
  }
}

export function HeroSection({ texts }: HeroSectionProps) {
  const { user } = useAuth();
  
  return (
    <>
      <HomeHeader texts={{ login: "Login", getStarted: "Get Started" }} />
      
      <section className="relative min-h-screen flex items-center justify-center overflow-hidden">
        <BackgroundEffects />

      {/* Hero Content */}
      <div className="relative z-10 max-w-7xl mx-auto px-4 sm:px-6 py-24">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-16 items-center">
          <div className="text-center lg:text-left">
            <h1 className="text-5xl sm:text-6xl md:text-7xl font-bold mb-8 leading-tight text-foreground">
              {texts.title.line1}
              <span className="block gradient-text">
                {texts.title.line2}
              </span>
            </h1>
            
            <p className="text-lg sm:text-xl text-text-secondary mb-12 max-w-xl">
              {texts.description}
            </p>

            <div className="flex flex-col sm:flex-row gap-4 justify-center lg:justify-start">
              <Link href={user ? "/canvas" : "/login"}>
                <Button size="lg" className="bg-primary hover:bg-primary/90 text-primary-foreground group w-full sm:w-auto shadow-lg shadow-primary/20 px-8 py-4 text-lg font-semibold">
                  {user ? "Go to Canvas" : texts.cta.primary}
                  <ArrowRight className="ml-2 w-4 h-4 group-hover:translate-x-1 transition-transform" />
                </Button>
              </Link>
            </div>
          </div>
          
          <div className="flex gap-6 justify-center lg:justify-end">
            <div className="relative hero-image rounded-3xl aspect-[9/16] w-[200px] sm:w-[240px] lg:w-[280px] overflow-hidden animate-float">
              <Image 
                src="https://static.readdy.ai/image/6f7165cfe0b25edc582c9815e9f0cfd2/ffb51a9f9b523f1e494aea016a7d2899.png" 
                alt="Fashion AI" 
                className="w-full h-full object-cover rounded-3xl"
                fill
                sizes="(max-width: 640px) 200px, (max-width: 1024px) 240px, 280px"
                priority
              />
              <div className="absolute inset-0 bg-gradient-to-t from-background/50 to-transparent rounded-3xl"></div>
            </div>
            <div className="relative hero-image rounded-3xl aspect-[9/16] w-[200px] sm:w-[240px] lg:w-[280px] overflow-hidden animate-float-reverse">
              <Image 
                src="https://static.readdy.ai/image/6f7165cfe0b25edc582c9815e9f0cfd2/a0eb3ad9c81f7aa80d8355d320ea7e96.png" 
                alt="Fashion AI" 
                className="w-full h-full object-cover rounded-3xl scale-110"
                fill
                sizes="(max-width: 640px) 200px, (max-width: 1024px) 240px, 280px"
                priority
              />
              <div className="absolute inset-0 bg-gradient-to-t from-background/50 to-transparent rounded-3xl"></div>
            </div>
          </div>
        </div>
      </div>
    </section>
    </>
  );
}
</file>

<file path="app/(home)/_components/HomeHeader.tsx">
"use client"

import { useState, useEffect } from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { useAuth } from "@/lib/auth/AuthContext";

interface HomeHeaderProps {
  texts?: {
    login: string;
    getStarted: string;
  };
}

export function HomeHeader({ texts = { login: "Login", getStarted: "Get Started" } }: HomeHeaderProps) {
  const [isScrolled, setIsScrolled] = useState(false);
  const { user, signOut } = useAuth();

  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 20);
    };
    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  return (
    <header
      className={`fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${
        isScrolled ? "bg-background/80 backdrop-blur-md" : ""
      }`}
    >
      <div className="max-w-7xl mx-auto px-4 sm:px-6 py-4">
        <div className="flex items-center justify-between">
          <Link 
            href="/" 
            className="font-sans text-xl sm:text-2xl font-bold text-primary tracking-tight hover:opacity-80 transition-opacity"
          >
            vogue drop
          </Link>
          <nav className="hidden md:flex items-center gap-8">
            <Link
              href="/#features"
              className="text-text-secondary hover:text-text-primary transition-colors"
            >
              Features
            </Link>
            <Link
              href="/#how-it-works"
              className="text-text-secondary hover:text-text-primary transition-colors"
            >
              How it Works
            </Link>
            <Link
              href="/gallery"
              className="text-text-secondary hover:text-text-primary transition-colors"
            >
              Gallery
            </Link>
            <Link
              href="/canvas"
              className="text-text-secondary hover:text-text-primary transition-colors"
            >
              Canvas
            </Link>
          </nav>
          <div className="flex items-center gap-4">
            {user ? (
              <>
                <Button 
                  variant="ghost" 
                  className="text-text-secondary hover:text-text-primary"
                  onClick={async () => {
                    await signOut()
                  }}
                >
                  Logout
                </Button>
                <Link href="/canvas">
                  <Button className="bg-primary text-primary-foreground hover:bg-primary/90">
                    Go to Canvas
                  </Button>
                </Link>
              </>
            ) : (
              <>
                <Link href="/login">
                  <Button variant="ghost" className="text-text-secondary hover:text-text-primary">
                    {texts.login}
                  </Button>
                </Link>
                <Link href="/login">
                  <Button className="bg-primary text-primary-foreground hover:bg-primary/90">
                    {texts.getStarted}
                  </Button>
                </Link>
              </>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}
</file>

<file path="app/(home)/_components/HowItWorksSection.tsx">
import { Upload, Palette, Settings, Video, Share2 } from "lucide-react"

export function HowItWorksSection() {
  return (
    <section id="how-it-works" className="py-16 sm:py-24 md:py-32 bg-gray-950">
      <div className="w-full px-4 sm:px-6 lg:px-8">
        <div className="text-center mb-12 sm:mb-16">
          <div className="flex items-center justify-center gap-3 mb-4">
            <Settings className="w-8 h-8 text-primary" />
            <h2 className="text-3xl sm:text-4xl md:text-5xl font-bold">
              AI-Powered Workflow
            </h2>
          </div>
          <p className="text-lg sm:text-xl text-gray-400">
            Create stunning videos in minutes. No timeline. Just results.
          </p>
        </div>

        <div className="relative w-full">
          {/* Vertical connecting line */}
          <div className="hidden md:block absolute left-1/2 top-0 bottom-0 w-0.5 bg-gradient-to-b from-primary to-secondary -translate-x-1/2" />
          
          {/* Workflow steps */}
          <div className="space-y-2 md:-space-y-10">
            {[
              { title: "Upload Images", description: "Upload your lookbook or photo shoot images to get started", icon: Upload },
              { title: "Choose Video Style", description: "Select from our curated collection of professional video styles", icon: Palette },
              { title: "AI Magic", description: "AI automatically adds sound effects and edits your video", icon: Video },
              { title: "Share & Go Viral", description: "Download or directly share to TikTok, Reels, and Shorts", icon: Share2 }
            ].map((step, index) => {
              const Icon = step.icon
              const isEven = index % 2 === 0
              
              return (
                <div key={index} className={`relative flex ${isEven ? 'justify-start' : 'justify-end'} lg:px-20 xl:px-32`}>
                  {/* Card */}
                  <div className={`relative w-full md:w-2/5 lg:w-5/12 ${isEven ? 'md:mr-auto' : 'md:ml-auto'}`}>
                    {/* Connection dot - positioned at card edge */}
                    <div className={`hidden md:block absolute top-1/2 w-4 h-4 bg-primary rounded-full -translate-y-1/2 z-10 ${isEven ? '-right-2' : '-left-2'}`} />
                    <div className="bg-black border border-gray-800 rounded-2xl p-6 sm:p-8">
                      <div className="flex items-start gap-4">
                        <div className="flex-shrink-0 w-14 h-14 bg-green-500 rounded-xl flex items-center justify-center">
                          <Icon className="w-7 h-7 text-white" />
                        </div>
                        
                        <div className="flex-1">
                          <div className="flex items-center gap-2 mb-2">
                            <span className="text-sm font-medium text-primary">Step {index + 1}</span>
                            <h3 className="text-xl font-semibold text-white">{step.title}</h3>
                          </div>
                          <p className="text-gray-400">{step.description}</p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              )
            })}
          </div>
        </div>
      </div>
    </section>
  )
}
</file>

<file path="app/api/auth/login/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'
import type { LoginFormData } from '@/types/auth'

export async function POST(request: Request) {
  try {
    const body: LoginFormData = await request.json()
    const { email, password } = body

    if (!email || !password) {
      return NextResponse.json(
        { error: { message: 'Email and password are required' } },
        { status: 400 }
      )
    }

    const supabase = await createClient()

    const { data, error } = await supabase.auth.signInWithPassword({
      email,
      password,
    })

    if (error) {
      return NextResponse.json(
        { error: { message: error.message, code: error.code } },
        { status: 401 }
      )
    }

    return NextResponse.json({
      success: true,
      user: {
        id: data.user.id,
        email: data.user.email,
      },
    })
  } catch (error) {
    console.error('Login error:', error)
    return NextResponse.json(
      { error: { message: 'An unexpected error occurred' } },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/auth/logout/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function POST() {
  try {
    const supabase = await createClient()

    const { error } = await supabase.auth.signOut()

    if (error) {
      return NextResponse.json(
        { error: { message: error.message } },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      message: 'Logged out successfully',
    })
  } catch (error) {
    console.error('Logout error:', error)
    return NextResponse.json(
      { error: { message: 'An unexpected error occurred' } },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/auth/signup/route.ts">
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

interface SignupRequest {
  email: string
  password: string
}

export async function POST(request: Request) {
  try {
    const body: SignupRequest = await request.json()
    const { email, password } = body

    if (!email || !password) {
      return NextResponse.json(
        { error: { message: 'Email and password are required' } },
        { status: 400 }
      )
    }

    if (password.length < 8) {
      return NextResponse.json(
        { error: { message: 'Password must be at least 8 characters long' } },
        { status: 400 }
      )
    }

    const supabase = await createClient()

    const { data, error } = await supabase.auth.signUp({
      email,
      password,
    })

    if (error) {
      return NextResponse.json(
        { error: { message: error.message, code: error.code } },
        { status: 400 }
      )
    }

    if (!data.user) {
      return NextResponse.json(
        { error: { message: 'Failed to create user' } },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      user: {
        id: data.user.id,
        email: data.user.email,
      },
    })
  } catch (error) {
    console.error('Signup error:', error)
    return NextResponse.json(
      { error: { message: 'An unexpected error occurred' } },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/canvas/categories/route.ts">
import { NextResponse } from 'next/server'
import { supabase } from '@/lib/supabase'

export async function GET() {
  try {
    const { data: categories, error } = await supabase
      .from('categories')
      .select('id, name')
      .order('name', { ascending: true })

    if (error) {
      console.error('Categories fetch error:', error)
      return NextResponse.json(
        { error: '카테고리 목록을 불러오는데 실패했습니다.' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      categories: categories || [],
      total: categories?.length || 0
    })

  } catch (error) {
    console.error('API error:', error)
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/canvas/effects/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { supabase } from '@/lib/supabase'

interface EffectWithRelations {
  id: number
  name: string
  category_id: number
  preview_media_id: number | null
  display_order: number
  is_active: boolean
  created_at: string
  category: {
    id: number
    name: string
  }
  preview_media?: {
    storage_path: string
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const category = searchParams.get('category')

    if (!category) {
      return NextResponse.json(
        { error: '카테고리를 지정해주세요.' },
        { status: 400 }
      )
    }

    // 'all' 카테고리인 경우 모든 효과를 한 번에 조회
    if (category === 'all') {
      const { data: effects, error: effectsError } = await supabase
        .from('effect_templates')
        .select(`
          id,
          name,
          category_id,
          preview_media_id,
          display_order,
          is_active,
          created_at,
          category:categories(*),
          preview_media:media_assets(storage_path)
        `)
        .eq('is_active', true)
        .order('display_order', { ascending: true })

      if (effectsError) {
        console.error('Effects fetch error:', effectsError)
        return NextResponse.json(
          { error: '효과 목록을 불러오는데 실패했습니다.' },
          { status: 500 }
        )
      }

      // 미디어 URL 변환
      const effectsWithMedia = ((effects || []) as unknown as EffectWithRelations[]).map((effect) => {
        let previewUrl = null
        
        // preview_media가 있고 storage_path가 있는 경우
        if (effect.preview_media?.storage_path) {
          previewUrl = supabase.storage
            .from('media-asset')
            .getPublicUrl(effect.preview_media.storage_path).data.publicUrl
        }

        return {
          ...effect,
          previewUrl,
          preview_media: undefined // 클라이언트에 불필요한 정보 제거
        }
      })

      return NextResponse.json({
        effects: effectsWithMedia,
        category: 'all',
        total: effectsWithMedia.length
      })
    }

    // 특정 카테고리 조회 - join을 사용해서 한 번에 모든 데이터 가져오기
    const { data: effects, error: effectsError } = await supabase
      .from('effect_templates')
      .select(`
        id,
        name,
        category_id,
        preview_media_id,
        display_order,
        is_active,
        created_at,
        category:categories!inner(*),
        preview_media:media_assets(storage_path)
      `)
      .eq('category.name', category)
      .eq('is_active', true)
      .order('display_order', { ascending: true })

    if (effectsError) {
      console.error('Effects fetch error:', effectsError)
      return NextResponse.json(
        { error: '효과 목록을 불러오는데 실패했습니다.' },
        { status: 500 }
      )
    }

    // 미디어 URL 변환
    const effectsWithMedia = ((effects || []) as unknown as EffectWithRelations[]).map((effect) => {
      let previewUrl = null
      
      // preview_media가 있고 storage_path가 있는 경우
      if (effect.preview_media?.storage_path) {
        previewUrl = supabase.storage
          .from('media-asset')
          .getPublicUrl(effect.preview_media.storage_path).data.publicUrl
      }

      return {
        ...effect,
        previewUrl,
        preview_media: undefined // 클라이언트에 불필요한 정보 제거
      }
    })

    return NextResponse.json({
      effects: effectsWithMedia,
      category: category,
      total: effectsWithMedia.length
    })

  } catch (error) {
    console.error('API error:', error)
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/canvas/favorite/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { toggleVideoFavorite } from '@/lib/db/video-generations';
import { createClient } from '@/lib/supabase/server';

export async function PATCH(request: NextRequest) {
  try {
    // 인증된 Supabase 클라이언트 생성
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    const { videoId, isFavorite } = await request.json();

    if (!videoId || typeof isFavorite !== 'boolean') {
      return NextResponse.json(
        { error: 'videoId and isFavorite are required' },
        { status: 400 }
      );
    }

    // 인증된 supabase 클라이언트와 함께 호출
    const updatedVideo = await toggleVideoFavorite(videoId, isFavorite, supabase);

    return NextResponse.json({ 
      success: true, 
      videoId: updatedVideo.job_id,
      isFavorite: updatedVideo.is_favorite
    });
  } catch (error) {
    console.error('Error toggling favorite:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to toggle favorite';
    return NextResponse.json(
      { 
        error: errorMessage,
        details: error instanceof Error ? error.stack : undefined 
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/favorites/route.ts">
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET() {
  try {
    // Supabase 클라이언트 생성 및 인증 확인
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    // 즐겨찾기된 비디오의 job_id만 조회
    const { data: videos, error } = await supabase
      .from('video_generations')
      .select('job_id')
      .eq('user_id', user.id)
      .eq('is_favorite', true)
      .eq('status', 'completed')
      .not('job_id', 'is', null);

    if (error) {
      console.error('Favorites fetch error:', error);
      return NextResponse.json(
        { error: '즐겨찾기 목록을 불러오는데 실패했습니다.' },
        { status: 500 }
      );
    }

    // job_id 배열만 반환
    const favoriteIds = (videos || [])
      .map(v => v.job_id)
      .filter(Boolean);

    return NextResponse.json({
      favoriteIds,
      total: favoriteIds.length
    });

  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/history/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '20');
    const offset = parseInt(searchParams.get('offset') || '0');

    // 인증된 Supabase 클라이언트 생성
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    // video_generations 테이블에서 완료된 영상만 조회 (민감한 정보 제외)
    const { data, error, count } = await supabase
      .from('video_generations')
      .select('id, job_id, input_image_url, output_video_url, created_at, is_favorite', { count: 'exact' })
      .eq('user_id', user.id)
      .eq('status', 'completed')
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (error) {
      console.error('History fetch error:', error);
      return NextResponse.json(
        { error: '영상 기록을 불러오는데 실패했습니다.' },
        { status: 500 }
      );
    }

    // 응답 데이터 포맷팅 (민감한 정보 제외)
    const formattedVideos = (data || []).map(video => ({
      id: video.job_id,
      videoUrl: video.output_video_url,
      thumbnail: video.input_image_url,
      createdAt: video.created_at,
      isFavorite: video.is_favorite || false
    }));

    return NextResponse.json({
      videos: formattedVideos,
      total: count || 0,
      hasMore: (offset + limit) < (count || 0)
    });

  } catch (error) {
    console.error('API error:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/jobs/[jobId]/check-webhook/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { createServiceClient } from '@/lib/supabase/service';

interface RouteParams {
  params: Promise<{
    jobId: string;
  }>;
}

async function checkFalApiStatus(falRequestId: string, modelType: string) {
  try {
    // 모델별 엔드포인트 설정
    const endpoint = modelType === 'seedance' 
      ? "fal-ai/bytedance/seedance/v1/pro/image-to-video"
      : "fal-ai/minimax/hailuo-02/standard/image-to-video";
    
    // Queue API status endpoint
    const statusUrl = `https://queue.fal.run/${endpoint}/requests/${falRequestId}/status`;
    
    // Check fal.ai status
    
    const response = await fetch(statusUrl, {
      headers: {
        'Authorization': `Key ${process.env.FAL_API_KEY}`
      }
    });

    if (!response.ok) {
      // Failed to check fal.ai status
      return { completed: false, status: 'error' };
    }

    const statusData = await response.json();
    // Process fal.ai status response

    // Queue API 상태 확인
    if (statusData.status === 'COMPLETED') {
      // response_url이 없을 경우 requests 엔드포인트 사용
      const responseUrl = statusData.response_url || `https://queue.fal.run/${endpoint}/requests/${falRequestId}`;
      
      const resultResponse = await fetch(responseUrl, {
        headers: {
          'Authorization': `Key ${process.env.FAL_API_KEY}`
        }
      });

      if (resultResponse.ok) {
        const resultData = await resultResponse.json();
        // Process fal.ai result data
        
        // response 객체 안에 실제 결과가 있을 수 있음
        const videoUrl = resultData.video?.url || resultData.response?.video?.url;
        
        if (videoUrl) {
          return {
            completed: true,
            status: 'completed',
            videoUrl: videoUrl
          };
        } else {
          // No video URL found in result
          return {
            completed: true,
            status: 'failed',
            error: 'No video URL in response'
          };
        }
      } else {
        // Failed to get result
        return {
          completed: true,
          status: 'failed',
          error: 'Failed to retrieve result'
        };
      }
    } else if (statusData.status === 'IN_QUEUE') {
      return {
        completed: false,
        status: 'queued',
        queuePosition: statusData.queue_position
      };
    } else if (statusData.status === 'IN_PROGRESS') {
      return {
        completed: false,
        status: 'processing',
        logs: statusData.logs
      };
    } else if (statusData.status === 'FAILED') {
      // 실패한 경우에도 결과를 가져와서 에러 메시지 확인
      const responseUrl = statusData.response_url || `https://queue.fal.run/${endpoint}/requests/${falRequestId}`;
      
      try {
        const errorResponse = await fetch(responseUrl, {
          headers: {
            'Authorization': `Key ${process.env.FAL_API_KEY}`
          }
        });
        
        if (errorResponse.ok) {
          const errorData = await errorResponse.json();
          return {
            completed: true,
            status: 'failed',
            error: errorData.error || errorData.message || 'Video generation failed'
          };
        }
      } catch {
        // Error fetching failure details
      }
      
      return {
        completed: true,
        status: 'failed',
        error: 'Video generation failed'
      };
    }

    return { completed: false, status: statusData.status || 'unknown' };
  } catch (error) {
    // Error checking fal.ai status
    return { completed: false, status: 'error', error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

export async function GET(
  request: NextRequest,
  props: RouteParams
) {
  try {
    const params = await props.params;
    const { jobId } = params;

    if (!jobId) {
      return NextResponse.json(
        { error: 'Job ID가 필요합니다.' },
        { status: 400 }
      );
    }

    // Supabase에서 job 정보 조회
    const supabase = await createClient();
    
    const { data: job, error } = await supabase
      .from('video_generations')
      .select('job_id, status, created_at, webhook_status, fal_request_id, model_type')
      .eq('job_id', jobId)
      .single();

    if (error || !job) {
      return NextResponse.json(
        { error: '작업을 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    const elapsedTime = Date.now() - new Date(job.created_at).getTime();
    const elapsedMinutes = Math.floor(elapsedTime / 60000);
    
    // 응답 데이터 기본 구성
    const responseData = {
      jobId: job.job_id,
      webhookStatus: job.webhook_status,
      status: job.status,
      elapsedMinutes,
      webhookCheckRequired: false,
      message: ''
    };

    // 5분 경과 후 webhook이 pending 상태면 fal.ai API 직접 확인
    if (job.webhook_status === 'pending' && elapsedMinutes >= 5 && job.fal_request_id) {
      // Webhook timeout, checking fal.ai directly
      
      responseData.webhookCheckRequired = true;
      responseData.message = 'Webhook 수신 지연으로 fal.ai API 직접 확인 중';

      // fal.ai 상태 직접 확인
      const falStatus = await checkFalApiStatus(job.fal_request_id, job.model_type);
      
      if (falStatus.completed) {
        // Service client로 DB 업데이트
        const serviceSupabase = createServiceClient();
        
        const updateData: Record<string, unknown> = {
          webhook_status: 'timeout',
          updated_at: new Date().toISOString()
        };

        if (falStatus.status === 'completed' && falStatus.videoUrl) {
          updateData.status = 'completed';
          updateData.output_video_url = falStatus.videoUrl;
          responseData.message = 'fal.ai 직접 확인으로 비디오 생성 완료 확인';
        } else if (falStatus.status === 'failed') {
          updateData.status = 'failed';
          updateData.error_message = falStatus.error || 'Video generation failed';
          responseData.message = 'fal.ai 직접 확인으로 생성 실패 확인';
        }

        const { error: updateError } = await serviceSupabase
          .from('video_generations')
          .update(updateData)
          .eq('job_id', jobId);
          
        if (updateError) {
          // Failed to update job status
        } else {
          // Job updated via fal.ai check
          responseData.status = updateData.status || job.status;
        }
      }
    } else if (job.webhook_status === 'delivered') {
      responseData.message = 'Webhook 정상 수신됨';
    } else if (job.webhook_status === 'failed') {
      responseData.message = 'Webhook 수신 실패';
    } else if (elapsedMinutes < 5) {
      responseData.message = `Webhook 대기 중 (${elapsedMinutes}분 경과)`;
    }

    return NextResponse.json(responseData);

  } catch {
    // Check webhook error
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/jobs/[jobId]/poll/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{
    jobId: string;
  }>;
}

/**
 * fal.ai API를 직접 폴링하여 상태를 확인하는 엔드포인트
 * webhook이 실패하는 경우의 백업 방안
 */
export async function GET(
  request: NextRequest,
  props: RouteParams
) {
  try {
    const params = await props.params;
    const { jobId } = params;

    if (!jobId) {
      return NextResponse.json(
        { error: 'Job ID가 필요합니다.' },
        { status: 400 }
      );
    }

    // Supabase에서 job 정보 조회
    const supabase = await createClient();
    
    const { data: job, error } = await supabase
      .from('video_generations')
      .select('job_id, status, created_at, input_image_url, output_video_url, error_message, webhook_status, fal_request_id, model_type')
      .eq('job_id', jobId)
      .single();

    if (error || !job) {
      return NextResponse.json(
        { error: '작업을 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    // 이미 완료되었거나 실패한 경우 그대로 반환
    if (job.status === 'completed' || job.status === 'failed') {
      return NextResponse.json({
        jobId: job.job_id,
        status: job.status,
        result: job.status === 'completed' ? {
          videoUrl: job.output_video_url,
          thumbnailUrl: job.input_image_url
        } : null,
        error: job.error_message
      });
    }

    // webhook 상태 확인 (5분 타임아웃)
    const elapsedMinutes = Math.floor((Date.now() - new Date(job.created_at).getTime()) / 60000);
    
    if (job.webhook_status === 'pending' && elapsedMinutes >= 5) {
      // Webhook timeout after 5 minutes
      
      // Service client로 webhook_status 업데이트
      const { createServiceClient } = await import('@/lib/supabase/service');
      const serviceSupabase = createServiceClient();
      
      await serviceSupabase
        .from('video_generations')
        .update({ 
          webhook_status: 'timeout',
          updated_at: new Date().toISOString()
        })
        .eq('job_id', jobId);
    }

    // fal_request_id가 있는 경우 fal.ai API 상태 확인
    if (job.fal_request_id) {
      try {
        // 모델별 엔드포인트 설정
        const endpoint = job.model_type === 'seedance' 
          ? "fal-ai/bytedance/seedance/v1/pro/image-to-video"
          : "fal-ai/minimax/hailuo-02/standard/image-to-video";
        
        const statusUrl = `https://queue.fal.run/${endpoint}/requests/${job.fal_request_id}/status`;
        
        const response = await fetch(statusUrl, {
          headers: {
            'Authorization': `Key ${process.env.FAL_API_KEY}`
          }
        });

        if (response.ok) {
          const statusData = await response.json();
          // fal.ai status received

          // 완료된 경우
          if (statusData.status === 'COMPLETED') {
            const responseUrl = statusData.response_url || `https://queue.fal.run/${endpoint}/requests/${job.fal_request_id}`;
            
            // 결과 가져오기
            const resultResponse = await fetch(responseUrl, {
              headers: {
                'Authorization': `Key ${process.env.FAL_API_KEY}`
              }
            });

            if (resultResponse.ok) {
              const resultData = await resultResponse.json();
              
              // response 객체 안에 실제 결과가 있을 수 있음
              const videoUrl = resultData.video?.url || resultData.response?.video?.url;
              
              if (videoUrl) {
                // Service client로 DB 업데이트
                const { createServiceClient } = await import('@/lib/supabase/service');
                const serviceSupabase = createServiceClient();
                
                await serviceSupabase
                  .from('video_generations')
                  .update({
                    status: 'completed',
                    output_video_url: videoUrl,
                    webhook_status: job.webhook_status === 'pending' ? 'timeout' : job.webhook_status,
                    updated_at: new Date().toISOString()
                  })
                  .eq('job_id', jobId);

                return NextResponse.json({
                  jobId: job.job_id,
                  status: 'completed',
                  result: {
                    videoUrl: videoUrl,
                    thumbnailUrl: job.input_image_url
                  }
                });
              }
            }
          } else if (statusData.status === 'FAILED') {
            // 실패 처리
            const { createServiceClient } = await import('@/lib/supabase/service');
            const serviceSupabase = createServiceClient();
            
            await serviceSupabase
              .from('video_generations')
              .update({
                status: 'failed',
                error_message: statusData.error || 'Video generation failed',
                webhook_status: job.webhook_status === 'pending' ? 'timeout' : job.webhook_status,
                updated_at: new Date().toISOString()
              })
              .eq('job_id', jobId);

            return NextResponse.json({
              jobId: job.job_id,
              status: 'failed',
              error: statusData.error || 'Video generation failed'
            });
          } else if (statusData.status === 'IN_QUEUE') {
            return NextResponse.json({
              jobId: job.job_id,
              status: 'processing',
              progress: 25,
              queuePosition: statusData.queue_position
            });
          } else if (statusData.status === 'IN_PROGRESS') {
            return NextResponse.json({
              jobId: job.job_id,
              status: 'processing',
              progress: 50
            });
          }
        }
      } catch (error) {
        console.error('Error polling fal.ai:', error);
      }
    }

    // 아직 처리 중
    return NextResponse.json({
      jobId: job.job_id,
      status: job.status,
      progress: job.status === 'processing' ? 50 : 0
    });

  } catch (error) {
    console.error('Poll error:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/jobs/[jobId]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{
    jobId: string;
  }>;
}

export async function GET(
  request: NextRequest,
  props: RouteParams
) {
  try {
    const params = await props.params;
    const { jobId } = params;

    if (!jobId) {
      return NextResponse.json(
        { error: 'Job ID가 필요합니다.' },
        { status: 400 }
      );
    }

    // Supabase에서 job 상태 조회
    const supabase = await createClient();
    
    const { data, error } = await supabase
      .from('video_generations')
      .select('job_id, status, created_at, updated_at, output_video_url, input_image_url, is_favorite, error_message')
      .eq('job_id', jobId)
      .single();

    if (error || !data) {
      return NextResponse.json(
        { error: '작업을 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    // 클라이언트에 반환할 데이터 구성 (민감한 정보 제외)
    const response = {
      jobId: data.job_id,
      status: data.status,
      createdAt: data.created_at,
      updatedAt: data.updated_at,
      progress: getProgressPercentage(data.status),
      result: data.status === 'completed' ? {
        videoUrl: data.output_video_url,
        thumbnailUrl: data.input_image_url,
        isFavorite: data.is_favorite || false
      } : null,
      error: data.status === 'failed' ? data.error_message : null
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('GET job status error:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}

/**
 * 상태에 따른 진행률 계산
 */
function getProgressPercentage(status: string): number {
  switch (status) {
    case 'pending':
      return 0;
    case 'processing':
      return 50;
    case 'completed':
      return 100;
    case 'failed':
      return 0;
    default:
      return 0;
  }
}
</file>

<file path="app/canvas/_components/EffectsGallery.tsx">
import { useEffectsData } from "@/app/canvas/_hooks/useEffectsData";
import { HoverVideo } from "@/components/ui/hover-video";

interface EffectsGalleryProps {
  onEffectClick?: () => void;
}

export function EffectsGallery({ onEffectClick }: EffectsGalleryProps) {
  const { getRepresentativeEffects, isLoading, error } = useEffectsData();
  const representativeEffects = getRepresentativeEffects();

  if (isLoading) {
    return (
      <div className="mb-4">
        <h2 className="text-sm font-medium mb-3 text-foreground">Effect Category</h2>
        <div className="grid grid-cols-3 gap-2">
          {[1, 2, 3, 4, 5, 6].map((i) => (
            <div key={i} className="aspect-square rounded-full bg-surface animate-pulse" />
          ))}
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="mb-4">
        <h2 className="text-sm font-medium mb-3 text-foreground">Effect Category</h2>
        <div className="text-sm text-destructive">{error}</div>
      </div>
    );
  }

  return (
    <div className="mb-4">
      <h2 className="text-sm font-medium mb-3 text-foreground">Effect Category</h2>
      <div className="grid grid-cols-3 gap-2">
        {representativeEffects.map((effect) => (
          <div key={effect.id} className="flex flex-col gap-1">
            <button
              onClick={onEffectClick}
              className="aspect-square rounded-full overflow-hidden relative group hover:ring-2 hover:ring-primary transition-all"
            >
              {effect.previewUrl ? (
                <HoverVideo
                  src={effect.previewUrl}
                  className="w-full h-full object-cover"
                />
              ) : (
                <div className="w-full h-full bg-gradient-to-br from-primary/20 to-primary/40 flex items-center justify-center">
                  <span className="text-white text-[10px] font-medium px-1 text-center">{effect.name}</span>
                </div>
              )}
              <div className="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors rounded-full" />
            </button>
            <p className="text-[10px] text-muted-foreground text-center capitalize">
              {effect.category.name}
            </p>
          </div>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="app/canvas/_components/EffectsSection.tsx">
import type { EffectTemplateWithMedia } from "@/types/database";
import { X } from "lucide-react";
import { HoverVideo } from "@/components/ui/hover-video";

export interface Effect {
  id: string;
  name: string;
  image?: string;
  type?: 'motion' | 'style' | 'filter';
}

interface EffectsSectionProps {
  onEffectClick?: () => void;
  selectedEffects?: EffectTemplateWithMedia[];
  onEffectRemove?: (effectId: number) => void;
}

export function EffectsSection({ onEffectClick, selectedEffects, onEffectRemove }: EffectsSectionProps) {

  // Always show 2 slots
  const slots = [0, 1];
  
  return (
    <div className="mb-4">
      <h2 className="text-sm font-medium mb-3 text-foreground">Selected Effects</h2>
      <div className="grid grid-cols-2 gap-1">
        {slots.map((slotIndex) => {
          const effect = selectedEffects?.[slotIndex];
          
          if (effect) {
            return (
              <div
                key={`slot-${slotIndex}`}
                className="bg-surface rounded-md overflow-hidden relative group"
              >
                {effect.previewUrl ? (
                  <div className="relative">
                    <HoverVideo
                      src={effect.previewUrl}
                      className="w-full h-auto"
                    />
                  </div>
                ) : (
                  <div className="aspect-square bg-gradient-to-br from-primary/20 to-primary/40 flex items-center justify-center">
                    <span className="text-white text-xs font-medium px-2 text-center">{effect.name}</span>
                  </div>
                )}
                {/* Effect name overlay */}
                <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-2">
                  <p className="text-white text-xs font-medium truncate">{effect.name}</p>
                </div>
                {/* Remove button */}
                {onEffectRemove && (
                  <button
                    onClick={() => onEffectRemove(effect.id)}
                    className="absolute top-1 right-1 p-1 bg-black/60 rounded-full opacity-0 group-hover:opacity-100 transition-opacity hover:bg-black/80"
                  >
                    <X className="w-3 h-3 text-white" />
                  </button>
                )}
              </div>
            );
          }
          
          // Empty slot
          return (
            <button
              key={`slot-${slotIndex}`}
              onClick={onEffectClick}
              className="min-h-[100px] bg-surface rounded-md overflow-hidden relative group hover:ring-1 hover:ring-primary transition-all flex items-center justify-center"
            >
              <div className="text-2xl text-muted-foreground group-hover:text-primary transition-colors">+</div>
            </button>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="app/canvas/_components/PrompterSection.tsx">
import { useRef, useEffect } from "react";
import { ChevronDown } from "lucide-react";

interface PrompterSectionProps {
  isOpen: boolean;
  onToggle: () => void;
  promptText?: string;
  onPromptChange?: (text: string) => void;
}

export function PrompterSection({
  isOpen,
  onToggle,
  promptText = "",
  onPromptChange,
}: PrompterSectionProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  // Auto-resize textarea
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
    }
  }, [promptText]);


  return (
    <div className="mb-4">
      <button
        className="flex items-center justify-between w-full text-sm font-medium mb-3 text-foreground hover:text-primary transition-colors"
        onClick={onToggle}
        aria-expanded={isOpen}
        aria-controls="prompter-content"
      >
        <h2>Prompter</h2>
        <ChevronDown
          className={`w-4 h-4 transition-transform ${
            isOpen ? "rotate-180" : ""
          }`}
        />
      </button>
      
      {isOpen && (
        <div id="prompter-content" className="bg-surface rounded-lg border border-border p-3">
          <div className="space-y-3">
            {/* Prompt Input */}
            <div className="space-y-2">
              <label htmlFor="prompt-input" className="text-xs font-medium text-foreground">
                Enter your prompt
              </label>
              <textarea
                ref={textareaRef}
                id="prompt-input"
                value={promptText}
                onChange={(e) => onPromptChange?.(e.target.value)}
                placeholder="Describe the motion or effect you want to create..."
                className="textarea-prompter"
                maxLength={500}
              />
              <div className="flex justify-between text-xs text-muted-foreground">
                <span>Use descriptive words for better results</span>
                <span>{promptText.length}/500</span>
              </div>
            </div>


          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/canvas/_components/QuickActionsBar.tsx">
interface QuickActionsBarProps {
  onGenerateClick?: () => void;
  isGenerating?: boolean;
  onMergeClick?: () => void;
}

export function QuickActionsBar({
  onGenerateClick,
  isGenerating,
  onMergeClick,
}: QuickActionsBarProps) {
  return (
    <div className="mt-auto space-y-2">
      <button
        onClick={onGenerateClick}
        disabled={isGenerating}
        className="w-full py-2.5 px-4 bg-primary hover:bg-primary/90 disabled:bg-primary/50 text-primary-foreground rounded-md font-medium text-sm transition-colors"
      >
        {isGenerating ? 'Generating...' : 'Generate'}
      </button>
      
      <button
        onClick={onMergeClick}
        className="w-full py-2.5 px-4 bg-muted hover:bg-muted/80 text-foreground rounded-md font-medium text-sm transition-colors"
      >
        Merge
      </button>
    </div>
  );
}
</file>

<file path="app/canvas/_hooks/useBeforeUnload.ts">
import { useEffect } from 'react';

/**
 * 브라우저 탭/창을 닫거나 새로고침할 때 경고를 표시하는 훅
 * @param shouldWarn - 경고를 표시할지 여부
 * @param message - 경고 메시지 (브라우저에 따라 무시될 수 있음)
 */
export function useBeforeUnload(
  shouldWarn: boolean,
  message: string = '진행 중인 작업이 있습니다. 정말 나가시겠습니까?'
) {
  useEffect(() => {
    if (!shouldWarn) return;

    const handleBeforeUnload = (event: BeforeUnloadEvent) => {
      event.preventDefault();
      // 대부분의 브라우저는 커스텀 메시지를 무시하고 기본 메시지를 표시합니다
      event.returnValue = message;
      return message;
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [shouldWarn, message]);
}
</file>

<file path="app/canvas/_hooks/useEffectsData.tsx">
"use client"

import { createContext, useContext, useState, useEffect, ReactNode } from 'react'
import type { EffectTemplateWithMedia } from '@/types/database'

interface Category {
  id: number
  name: string
}

interface EffectsDataContextType {
  effects: EffectTemplateWithMedia[]
  categories: Category[]
  isLoading: boolean
  error: string | null
  refetchEffects: () => Promise<void>
  getEffectsByCategory: (category: string) => EffectTemplateWithMedia[]
  getRepresentativeEffects: () => EffectTemplateWithMedia[]
}

const EffectsDataContext = createContext<EffectsDataContextType | undefined>(undefined)

export function EffectsDataProvider({ children }: { children: ReactNode }) {
  const [effects, setEffects] = useState<EffectTemplateWithMedia[]>([])
  const [categories, setCategories] = useState<Category[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchData = async () => {
    try {
      setIsLoading(true)
      setError(null)
      
      // 병렬로 effects와 categories 로드
      const [effectsResponse, categoriesResponse] = await Promise.all([
        fetch('/api/canvas/effects?category=all'),
        fetch('/api/canvas/categories')
      ])
      
      if (!effectsResponse.ok || !categoriesResponse.ok) {
        throw new Error('Failed to fetch data')
      }
      
      const [effectsData, categoriesData] = await Promise.all([
        effectsResponse.json(),
        categoriesResponse.json()
      ])
      
      setEffects(effectsData.effects || [])
      setCategories(categoriesData.categories || [])
    } catch (err) {
      console.error('Error fetching data:', err)
      setError('Failed to load data')
    } finally {
      setIsLoading(false)
    }
  }

  useEffect(() => {
    fetchData()
  }, [])

  const getEffectsByCategory = (category: string) => {
    if (category === 'all' || category === 'All') {
      return effects
    }
    
    // 카테고리 이름을 소문자로 정규화
    const normalizedCategory = category.toLowerCase()
    return effects.filter(effect => effect.category?.name === normalizedCategory)
  }

  const getRepresentativeEffects = () => {
    const representativeEffects: EffectTemplateWithMedia[] = []
    const seenCategories = new Set<number>()
    
    // display_order로 정렬된 effects에서 각 카테고리의 첫 번째 효과만 선택
    for (const effect of effects) {
      if (effect.category && !seenCategories.has(effect.category.id)) {
        seenCategories.add(effect.category.id)
        representativeEffects.push(effect)
      }
    }
    
    return representativeEffects
  }

  const value: EffectsDataContextType = {
    effects,
    categories,
    isLoading,
    error,
    refetchEffects: fetchData,
    getEffectsByCategory,
    getRepresentativeEffects
  }

  return (
    <EffectsDataContext.Provider value={value}>
      {children}
    </EffectsDataContext.Provider>
  )
}

export function useEffectsData() {
  const context = useContext(EffectsDataContext)
  if (context === undefined) {
    throw new Error('useEffectsData must be used within an EffectsDataProvider')
  }
  return context
}
</file>

<file path="app/gallery/_components/CategoryFilter.tsx">
"use client"

import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import type { Category } from "@/types/database"

interface CategoryFilterProps {
  categories: Category[]
  selectedCategory: number | null
}

export function CategoryFilter({ categories, selectedCategory }: CategoryFilterProps) {
  const router = useRouter()

  const handleCategoryClick = (categoryId: number | null) => {
    if (categoryId === null) {
      router.push('/gallery')
    } else {
      router.push(`/gallery?category=${categoryId}`)
    }
  }

  return (
    <div className="flex flex-wrap gap-3 mb-12 justify-center">
      {/* All category */}
      <button
        onClick={() => handleCategoryClick(null)}
        className={cn(
          "px-6 py-2.5 rounded-full font-medium text-sm transition-all duration-200",
          selectedCategory === null
            ? "bg-white text-black hover:bg-gray-100"
            : "bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white"
        )}
      >
        All
      </button>

      {/* Dynamic categories from DB */}
      {categories.map((category) => {
        return (
          <button
            key={category.id}
            onClick={() => handleCategoryClick(category.id)}
            className={cn(
              "px-6 py-2.5 rounded-full font-medium text-sm transition-all duration-200",
              selectedCategory === category.id
                ? "bg-white text-black hover:bg-gray-100"
                : "bg-gray-800 text-gray-300 hover:bg-gray-700 hover:text-white"
            )}
          >
            {category.name}
          </button>
        )
      })}
    </div>
  )
}
</file>

<file path="app/gallery/_components/GalleryGrid.tsx">
import { GalleryItem } from "./GalleryItem"
import type { EffectTemplateWithMedia } from "@/types/database"

interface GalleryGridProps {
  items: EffectTemplateWithMedia[]
}

export function GalleryGrid({ items }: GalleryGridProps) {
  if (items.length === 0) {
    return (
      <div className="text-center py-24">
        <p className="text-gray-400 text-lg">No effects found in this category.</p>
      </div>
    )
  }

  return (
    <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
      {items.map((item) => (
        <GalleryItem key={item.id} item={item} />
      ))}
    </div>
  )
}
</file>

<file path="app/gallery/_components/GalleryGridSkeleton.tsx">
export function GalleryGridSkeleton() {
  return (
    <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
      {[...Array(12)].map((_, index) => (
        <div
          key={index}
          className="relative aspect-[9/16] bg-gray-900 rounded-2xl overflow-hidden animate-pulse"
        >
          <div className="absolute inset-0 bg-gradient-to-t from-gray-800 to-gray-900" />
          <div className="absolute bottom-0 left-0 right-0 p-4 sm:p-6">
            <div className="h-6 bg-gray-700 rounded mb-2" />
            <div className="h-4 bg-gray-700 rounded w-3/4 mb-2" />
            <div className="h-3 bg-gray-700 rounded w-1/2" />
          </div>
        </div>
      ))}
    </div>
  )
}
</file>

<file path="app/gallery/_components/GalleryHeader.tsx">
export function GalleryHeader() {
  return (
    <div className="text-center mb-12">
      <h1 className="text-4xl sm:text-5xl md:text-6xl font-bold mb-4">
        Visual Effects Gallery
      </h1>
      <p className="text-lg sm:text-xl text-gray-400 max-w-3xl mx-auto">
        Discover our collection of premium fashion video effects
      </p>
    </div>
  )
}
</file>

<file path="app/gallery/_components/GalleryItem.tsx">
"use client"

import { useState } from "react"
import { Play } from "lucide-react"
import Image from "next/image"
import { getPublicUrl } from "@/lib/supabase"
import type { EffectTemplateWithMedia } from "@/types/database"

interface GalleryItemProps {
  item: EffectTemplateWithMedia
}

export function GalleryItem({ item }: GalleryItemProps) {
  const [isHovered, setIsHovered] = useState(false)
  
  const mediaUrl = item.preview_media?.storage_path 
    ? getPublicUrl(item.preview_media.storage_path)
    : null
    
  const isVideo = mediaUrl && (mediaUrl.endsWith('.mp4') || mediaUrl.endsWith('.webm'))

  return (
    <div
      className="group relative aspect-[9/16] bg-gray-900 rounded-2xl overflow-hidden cursor-pointer transform transition-all duration-300 hover:scale-[1.02]"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      {/* Gradient overlay */}
      <div className="absolute inset-0 bg-gradient-to-t from-black/90 via-black/20 to-transparent z-10" />
      
      {/* Background fallback */}
      <div className="w-full h-full bg-gradient-to-br from-purple-900/20 to-blue-900/20 absolute inset-0" />
      
      {/* Media content */}
      {mediaUrl && (
        <>
          {isVideo ? (
            <video
              src={mediaUrl}
              className="w-full h-full object-cover z-[1]"
              autoPlay
              loop
              muted
              playsInline
              onError={(e) => {
                e.currentTarget.style.display = 'none'
              }}
            />
          ) : (
            <Image
              src={mediaUrl}
              alt={item.name || "Gallery item"}
              fill
              className="object-cover z-[1]"
              sizes="(max-width: 640px) 50vw, (max-width: 1024px) 33vw, 25vw"
              onError={(e) => {
                e.currentTarget.style.display = 'none'
              }}
            />
          )}
        </>
      )}
      
      {/* Content overlay */}
      <div className="absolute bottom-0 left-0 right-0 p-4 sm:p-6 z-20">
        <h3 className="font-semibold text-lg sm:text-xl line-clamp-1">
          {item.name}
        </h3>
      </div>
      
      {/* Play button on hover */}
      <div className={`absolute inset-0 flex items-center justify-center transition-opacity duration-300 z-30 ${isHovered ? 'opacity-100' : 'opacity-0'}`}>
        <div className="w-16 h-16 bg-white/20 backdrop-blur-sm rounded-full flex items-center justify-center transform transition-transform hover:scale-110">
          <Play className="w-7 h-7 ml-1 text-white" fill="white" />
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/gallery/_components/GalleryPageClient.tsx">
"use client"

import { HomeHeader } from "@/app/(home)/_components/HomeHeader"

export function GalleryPageClient({ children }: { children: React.ReactNode }) {
  return (
    <>
      <HomeHeader />
      {children}
    </>
  )
}
</file>

<file path="app/gallery/_components/GallerySection.tsx">
import { GalleryItem } from "./GalleryItem"
import type { Category, EffectTemplateWithMedia } from "@/types/database"
import { ChevronRight } from "lucide-react"
import Link from "next/link"

interface GallerySectionProps {
  category: Category
  items: EffectTemplateWithMedia[]
}

export function GallerySection({ category, items }: GallerySectionProps) {
  return (
    <section className="space-y-6">
      <div className="flex items-center justify-between">
        <h2 className="text-2xl sm:text-3xl font-bold">{category.name}</h2>
        <Link 
          href={`/gallery?category=${category.id}`}
          className="flex items-center gap-1 text-sm text-gray-400 hover:text-white transition-colors"
        >
          View all
          <ChevronRight className="w-4 h-4" />
        </Link>
      </div>
      
      <div className="grid grid-cols-2 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
        {items.slice(0, 8).map((item) => (
          <GalleryItem key={item.id} item={item} />
        ))}
      </div>
    </section>
  )
}
</file>

<file path="app/gallery/page.tsx">
import { Suspense } from "react"
import { getGalleryItems, getCategories } from "@/lib/api/gallery"
import { GalleryPageClient } from "./_components/GalleryPageClient"
import { GalleryHeader } from "./_components/GalleryHeader"
import { CategoryFilter } from "./_components/CategoryFilter"
import { GallerySection } from "./_components/GallerySection"
import { GalleryGrid } from "./_components/GalleryGrid"
import { GalleryGridSkeleton } from "./_components/GalleryGridSkeleton"
import type { EffectTemplateWithMedia } from "@/types/database"

export const dynamic = 'force-dynamic'
export const revalidate = 0

interface PageProps {
  searchParams: Promise<{ category?: string }>
}

export default async function GalleryPage({ searchParams }: PageProps) {
  const params = await searchParams
  
  const [items, categories] = await Promise.all([
    getGalleryItems(),
    getCategories()
  ])

  const selectedCategory = params.category ? parseInt(params.category) : null

  // Group items by category
  const itemsByCategory = categories.reduce((acc, category) => {
    const categoryItems = items.filter(item => item.category_id === category.id)
    if (categoryItems.length > 0) {
      acc[category.id] = {
        category,
        items: categoryItems
      }
    }
    return acc
  }, {} as Record<number, { category: typeof categories[0], items: EffectTemplateWithMedia[] }>)

  return (
    <GalleryPageClient>
      <div className="min-h-screen bg-black text-white pt-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 py-12">
          <GalleryHeader />
        
        <CategoryFilter 
          categories={categories} 
          selectedCategory={selectedCategory} 
        />
        
        {selectedCategory === null ? (
          // Show all categories with sections
          <div className="space-y-16">
            {Object.values(itemsByCategory).map(({ category, items }) => (
              <GallerySection 
                key={category.id} 
                category={category} 
                items={items} 
              />
            ))}
          </div>
        ) : (
          // Show only selected category
          <Suspense fallback={<GalleryGridSkeleton />}>
            <GalleryGrid 
              items={items.filter(item => item.category_id === selectedCategory)} 
            />
          </Suspense>
        )}
        </div>
      </div>
    </GalleryPageClient>
  )
}
</file>

<file path="app/external-imports.css">
@import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');
@import url('https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css');
</file>

<file path="app/loading.tsx">
export default function Loading() {
  return null
}
</file>

<file path="app/page.tsx">
import { HeroSection } from "./(home)/_components/HeroSection"
import { FeaturesSection } from "./(home)/_components/FeaturesSection"
import { HowItWorksSection } from "./(home)/_components/HowItWorksSection"
import { GallerySection } from "./(home)/_components/GallerySection"
import { CTASection } from "./(home)/_components/CTASection"
import { Footer } from "./(home)/_components/Footer"
import homeTexts from "@/locales/en/home.json"

export const dynamic = 'force-dynamic'
export const revalidate = 0

export default function HomePage() {
  return (
    <div className="min-h-screen bg-black text-white">
      <HeroSection texts={homeTexts.hero} />
      <FeaturesSection texts={homeTexts.features} />
      <HowItWorksSection />
      <GallerySection texts={homeTexts.gallery} />
      <CTASection texts={homeTexts.cta} />
      <Footer texts={homeTexts.footer} />
    </div>
  )
}
</file>

<file path="components/modals/BaseModal.tsx">
import { X } from "lucide-react"

interface BaseModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: React.ReactNode
  className?: string
}

export function BaseModal({ isOpen, onClose, title, children, className = "bg-white" }: BaseModalProps) {
  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center">
      <div className={`${className} w-[800px] max-h-[600px] rounded-xl p-6 relative`}>
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-xl font-medium text-black">{title}</h2>
          <button className="text-gray-400 hover:text-gray-600" onClick={onClose}>
            <X className="w-6 h-6" />
          </button>
        </div>
        {children}
      </div>
    </div>
  )
}
</file>

<file path="components/modals/CameraModal.tsx">
import { BaseModal } from "./BaseModal"
import { Camera, Video, Upload } from "lucide-react"
import { Button } from "@/components/ui/button"
import { useState } from "react"

interface CameraModalProps {
  isOpen: boolean
  onClose: () => void
  onCapture: (imageData: string) => void
}

export function CameraModal({ isOpen, onClose, onCapture }: CameraModalProps) {
  const [activeTab, setActiveTab] = useState<"camera" | "upload">("camera")
  const [isCameraActive, setIsCameraActive] = useState(false)

  const handleCapture = () => {
    // Simulate camera capture
    onCapture("/placeholder.svg?height=640&width=480&query=camera-captured-image")
    onClose()
  }

  const handleFileUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onload = (e) => {
        onCapture(e.target?.result as string)
        onClose()
      }
      reader.readAsDataURL(file)
    }
  }

  return (
    <BaseModal isOpen={isOpen} onClose={onClose} title="Camera / Upload">
      <div className="flex flex-col gap-4">
        {/* Tab Navigation */}
        <div className="flex gap-2 p-1 bg-gray-100 rounded-lg">
          <button
            onClick={() => setActiveTab("camera")}
            className={`flex-1 py-2 px-4 rounded-md transition-colors ${
              activeTab === "camera"
                ? "bg-white text-black shadow-sm"
                : "text-gray-600 hover:text-black"
            }`}
          >
            <Camera className="w-4 h-4 inline-block mr-2" />
            Camera
          </button>
          <button
            onClick={() => setActiveTab("upload")}
            className={`flex-1 py-2 px-4 rounded-md transition-colors ${
              activeTab === "upload"
                ? "bg-white text-black shadow-sm"
                : "text-gray-600 hover:text-black"
            }`}
          >
            <Upload className="w-4 h-4 inline-block mr-2" />
            Upload
          </button>
        </div>

        {/* Content */}
        {activeTab === "camera" ? (
          <div className="space-y-4">
            <div className="aspect-[4/3] bg-gray-100 rounded-lg overflow-hidden relative">
              {isCameraActive ? (
                <div className="w-full h-full bg-gradient-to-br from-gray-200 to-gray-300 flex items-center justify-center">
                  <Video className="w-16 h-16 text-gray-500" />
                  <div className="absolute bottom-4 left-4 text-sm text-gray-600">
                    Camera preview
                  </div>
                </div>
              ) : (
                <div className="w-full h-full flex items-center justify-center">
                  <div className="text-center">
                    <Camera className="w-16 h-16 text-gray-400 mx-auto mb-4" />
                    <p className="text-gray-600 mb-4">Camera is not active</p>
                    <Button
                      onClick={() => setIsCameraActive(true)}
                      className="bg-primary text-black hover:bg-primary/90"
                    >
                      Start Camera
                    </Button>
                  </div>
                </div>
              )}
            </div>

            {isCameraActive && (
              <div className="flex justify-center gap-4">
                <Button
                  variant="outline"
                  onClick={() => setIsCameraActive(false)}
                  className="text-black"
                >
                  Stop Camera
                </Button>
                <Button
                  onClick={handleCapture}
                  className="bg-primary text-black hover:bg-primary/90"
                >
                  Capture Photo
                </Button>
              </div>
            )}
          </div>
        ) : (
          <div className="space-y-4">
            <div className="border-2 border-dashed border-gray-300 rounded-lg p-8">
              <div className="text-center">
                <Upload className="w-16 h-16 text-gray-400 mx-auto mb-4" />
                <p className="text-gray-600 mb-2">
                  Drag and drop your image here, or click to browse
                </p>
                <p className="text-sm text-gray-500 mb-4">
                  Supports: JPG, PNG, GIF (max 10MB)
                </p>
                <input
                  type="file"
                  accept="image/*"
                  onChange={handleFileUpload}
                  className="hidden"
                  id="image-upload"
                />
                <Button
                  onClick={() => document.getElementById("image-upload")?.click()}
                  className="bg-primary text-black hover:bg-primary/90"
                >
                  Browse Files
                </Button>
              </div>
            </div>

            <div className="text-center text-sm text-gray-500">
              Uploaded images will be used as reference for your fashion generation
            </div>
          </div>
        )}
      </div>
    </BaseModal>
  )
}
</file>

<file path="components/modals/EffectModal.tsx">
import { BaseModal } from "./BaseModal"
import type { EffectTemplateWithMedia } from "@/types/database"
import { useEffectsData } from "@/app/canvas/_hooks/useEffectsData"
import { HoverVideo } from "@/components/ui/hover-video"

interface EffectModalProps {
  isOpen: boolean
  onClose: () => void
  onSelectEffect?: (effect: EffectTemplateWithMedia) => void
  selectedEffects?: EffectTemplateWithMedia[]
}

export function EffectModal({ isOpen, onClose, onSelectEffect, selectedEffects = [] }: EffectModalProps) {
  const { getEffectsByCategory, isLoading, error } = useEffectsData()
  
  const effects = getEffectsByCategory("All")

  const handleEffectClick = (effect: EffectTemplateWithMedia) => {
    if (onSelectEffect) {
      onSelectEffect(effect)
    }
  }

  const isEffectSelected = (effectId: number) => {
    return selectedEffects.some(e => e.id === effectId)
  }

  if (!isOpen) return null

  return (
    <BaseModal isOpen={isOpen} onClose={onClose} title="Effect Gallery">
      {isLoading ? (
        <div className="flex items-center justify-center h-64">
          <div className="text-gray-500">Loading effects...</div>
        </div>
      ) : error ? (
        <div className="flex items-center justify-center h-64">
          <div className="text-red-500">{error}</div>
        </div>
      ) : (
        <>
          <div className="grid grid-cols-4 gap-4 overflow-y-auto max-h-[500px] pr-2">
            {effects.map((effect) => (
              <div 
                key={effect.id} 
                onClick={() => handleEffectClick(effect)}
                className={`aspect-[3/4] rounded-xl overflow-hidden relative group cursor-pointer ${
                  isEffectSelected(effect.id) ? 'ring-2 ring-primary' : ''
                }`}
              >
                {effect.previewUrl ? (
                  <HoverVideo
                    src={effect.previewUrl}
                    className="w-full h-full object-cover"
                  />
                ) : (
                  <div className="w-full h-full bg-gradient-to-br from-gray-200 to-gray-300 flex items-center justify-center p-4">
                    <span className="text-gray-700 font-medium text-center">{effect.name}</span>
                  </div>
                )}
                <div className="absolute inset-0 bg-gradient-to-t from-black/60 to-transparent flex items-end p-4 pointer-events-none">
                  <span className="text-white font-medium drop-shadow-lg">{effect.name}</span>
                </div>
                {isEffectSelected(effect.id) && (
                  <div className="absolute top-2 right-2 w-6 h-6 bg-primary rounded-full flex items-center justify-center pointer-events-none">
                    <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
                    </svg>
                  </div>
                )}
              </div>
            ))}
          </div>
        </>
      )}
    </BaseModal>
  )
}
</file>

<file path="components/modals/ModelModal.tsx">
import { BaseModal } from "./BaseModal"
import { User, Users, Check } from "lucide-react"
import { Button } from "@/components/ui/button"
import { useState } from "react"
import Image from "next/image"

interface ModelOption {
  id: string
  name: string
  description: string
  imageUrl: string
  category: "male" | "female" | "unisex"
}

interface ModelModalProps {
  isOpen: boolean
  onClose: () => void
  onSelectModel: (modelId: string) => void
  selectedModelId?: string
}

const modelOptions: ModelOption[] = [
  {
    id: "model-1",
    name: "Classic Male",
    description: "Athletic build, 180cm",
    imageUrl: "https://readdy.ai/api/search-image?query=Professional male fashion model with athletic build in modern clothing&width=200&height=300&seq=31&orientation=portrait",
    category: "male"
  },
  {
    id: "model-2",
    name: "Urban Female",
    description: "Contemporary style, 170cm",
    imageUrl: "https://readdy.ai/api/search-image?query=Contemporary female fashion model with urban style in trendy outfit&width=200&height=300&seq=32&orientation=portrait",
    category: "female"
  },
  {
    id: "model-3",
    name: "Fashion Forward",
    description: "Androgynous look, 175cm",
    imageUrl: "https://readdy.ai/api/search-image?query=Fashion forward androgynous model with minimalist styling&width=200&height=300&seq=33&orientation=portrait",
    category: "unisex"
  },
  {
    id: "model-4",
    name: "Street Style Male",
    description: "Casual aesthetic, 185cm",
    imageUrl: "https://readdy.ai/api/search-image?query=Street style male model with casual aesthetic in urban fashion&width=200&height=300&seq=34&orientation=portrait",
    category: "male"
  },
  {
    id: "model-5",
    name: "Elegant Female",
    description: "Sophisticated look, 168cm",
    imageUrl: "https://readdy.ai/api/search-image?query=Elegant female fashion model with sophisticated look in haute couture&width=200&height=300&seq=35&orientation=portrait",
    category: "female"
  },
  {
    id: "model-6",
    name: "Minimalist",
    description: "Clean aesthetic, 178cm",
    imageUrl: "https://readdy.ai/api/search-image?query=Minimalist unisex model with clean aesthetic in contemporary fashion&width=200&height=300&seq=36&orientation=portrait",
    category: "unisex"
  }
]

export function ModelModal({ isOpen, onClose, onSelectModel, selectedModelId }: ModelModalProps) {
  const [filter, setFilter] = useState<"all" | "male" | "female" | "unisex">("all")
  const [selectedModel, setSelectedModel] = useState<string>(selectedModelId || "")

  const filteredModels = filter === "all" 
    ? modelOptions 
    : modelOptions.filter(model => model.category === filter)

  const handleApply = () => {
    if (selectedModel) {
      onSelectModel(selectedModel)
      onClose()
    }
  }

  return (
    <BaseModal isOpen={isOpen} onClose={onClose} title="Select Model">
      <div className="flex flex-col gap-4">
        {/* Filter Tabs */}
        <div className="flex gap-2 p-1 bg-gray-100 rounded-lg">
          <button
            onClick={() => setFilter("all")}
            className={`flex-1 py-2 px-3 rounded-md transition-colors text-sm ${
              filter === "all"
                ? "bg-white text-black shadow-sm"
                : "text-gray-600 hover:text-black"
            }`}
          >
            All
          </button>
          <button
            onClick={() => setFilter("male")}
            className={`flex-1 py-2 px-3 rounded-md transition-colors text-sm ${
              filter === "male"
                ? "bg-white text-black shadow-sm"
                : "text-gray-600 hover:text-black"
            }`}
          >
            <User className="w-3 h-3 inline-block mr-1" />
            Male
          </button>
          <button
            onClick={() => setFilter("female")}
            className={`flex-1 py-2 px-3 rounded-md transition-colors text-sm ${
              filter === "female"
                ? "bg-white text-black shadow-sm"
                : "text-gray-600 hover:text-black"
            }`}
          >
            <User className="w-3 h-3 inline-block mr-1" />
            Female
          </button>
          <button
            onClick={() => setFilter("unisex")}
            className={`flex-1 py-2 px-3 rounded-md transition-colors text-sm ${
              filter === "unisex"
                ? "bg-white text-black shadow-sm"
                : "text-gray-600 hover:text-black"
            }`}
          >
            <Users className="w-3 h-3 inline-block mr-1" />
            Unisex
          </button>
        </div>

        {/* Model Grid */}
        <div className="grid grid-cols-3 gap-4 max-h-[400px] overflow-y-auto p-1">
          {filteredModels.map((model) => (
            <div
              key={model.id}
              onClick={() => setSelectedModel(model.id)}
              className={`relative cursor-pointer rounded-lg overflow-hidden border-2 transition-all ${
                selectedModel === model.id
                  ? "border-primary shadow-lg"
                  : "border-gray-200 hover:border-gray-300"
              }`}
            >
              <div className="relative h-48">
                <Image
                  src={model.imageUrl}
                  alt={model.name}
                  className="w-full h-full object-cover"
                  fill
                  sizes="(max-width: 768px) 50vw, 33vw"
                />
                {selectedModel === model.id && (
                  <div className="absolute top-2 right-2 w-6 h-6 bg-primary rounded-full flex items-center justify-center z-10">
                    <Check className="w-4 h-4 text-black" />
                  </div>
                )}
              </div>
              <div className="p-3 bg-white">
                <h4 className="font-medium text-sm text-black">{model.name}</h4>
                <p className="text-xs text-gray-600 mt-1">{model.description}</p>
              </div>
            </div>
          ))}
        </div>

        {/* Action Buttons */}
        <div className="flex justify-end gap-2 pt-2 border-t">
          <Button variant="outline" onClick={onClose} className="text-black">
            Cancel
          </Button>
          <Button
            onClick={handleApply}
            disabled={!selectedModel}
            className="bg-primary text-black hover:bg-primary/90"
          >
            Apply Model
          </Button>
        </div>
      </div>
    </BaseModal>
  )
}
</file>

<file path="components/modals/ProjectTitleModal.tsx">
import { useState } from "react"
import { X } from "lucide-react"

interface ProjectTitleModalProps {
  isOpen: boolean
  onClose: () => void
  onConfirm: (title: string) => void
}

export function ProjectTitleModal({ isOpen, onClose, onConfirm }: ProjectTitleModalProps) {
  const [title, setTitle] = useState("")

  if (!isOpen) return null

  const handleConfirm = () => {
    const finalTitle = title.trim() || "Untitled Project"
    onConfirm(finalTitle)
    onClose()
  }

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-surface rounded-lg p-6 w-full max-w-md">
        <div className="flex items-center justify-between mb-4">
          <h2 className="text-lg font-semibold text-text-primary">Enter Project Title</h2>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center text-text-tertiary hover:text-text-primary rounded-lg hover:bg-surface-secondary transition-all"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === 'Enter') {
              handleConfirm()
            } else if (e.key === 'Escape') {
              onClose()
            }
          }}
          placeholder="Enter project title..."
          className="input-base"
          autoFocus
        />

        <div className="flex gap-3 mt-6">
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 bg-surface-secondary text-text-secondary rounded-button hover:bg-surface-tertiary transition-colors"
          >
            Cancel
          </button>
          <button
            onClick={handleConfirm}
            className="flex-1 px-4 py-2 bg-primary text-primary-foreground rounded-button hover:bg-primary/90 transition-colors"
          >
            Continue to Editor
          </button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="components/modals/PromptModal.tsx">
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { BaseModal } from "./BaseModal"

interface PromptModalProps {
  isOpen: boolean
  onClose: () => void
  promptText: string
  negativePrompt: string
  onPromptChange: (text: string) => void
  onNegativePromptChange: (text: string) => void
  onApply: () => void
}

export function PromptModal({
  isOpen,
  onClose,
  promptText,
  negativePrompt,
  onPromptChange,
  onNegativePromptChange,
  onApply,
}: PromptModalProps) {
  return (
    <BaseModal isOpen={isOpen} onClose={onClose} title="Prompt">
      <div className="flex flex-col gap-4">
        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-black">Prompt</label>
          <Textarea
            className="w-full h-32 p-3 bg-gray-50 text-black text-sm resize-none"
            placeholder="Enter your prompt here..."
            value={promptText}
            onChange={(e) => onPromptChange(e.target.value)}
          />
          <div className="flex justify-between items-center text-xs text-gray-500">
            <span>Be specific about what you want to create</span>
            <span>{promptText.length}/500</span>
          </div>
        </div>

        <div className="flex flex-col gap-2">
          <label className="text-sm font-medium text-black">Negative Prompt</label>
          <Textarea
            className="w-full h-24 p-3 bg-gray-50 text-black text-sm resize-none"
            placeholder="Enter what you don't want to see..."
            value={negativePrompt}
            onChange={(e) => onNegativePromptChange(e.target.value)}
          />
          <div className="flex justify-between items-center text-xs text-gray-500">
            <span>Describe what you want to exclude</span>
            <span>{negativePrompt.length}/500</span>
          </div>
        </div>

        <div className="flex justify-end gap-2 mt-2">
          <Button variant="outline" onClick={onClose} className="text-black">
            Cancel
          </Button>
          <Button
            className="bg-primary text-white hover:bg-primary/90"
            onClick={() => {
              onApply()
              onClose()
            }}
          >
            Apply
          </Button>
        </div>
      </div>
    </BaseModal>
  )
}
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="components/ui/hover-video.tsx">
"use client"

import { useState, useRef, useEffect } from 'react'
import Image from 'next/image'

interface HoverVideoProps {
  src: string
  className?: string
  fallbackContent?: React.ReactNode
}

export function HoverVideo({
  src,
  className = "",
  fallbackContent
}: HoverVideoProps) {
  const [isHovered, setIsHovered] = useState(false)
  const videoRef = useRef<HTMLVideoElement>(null)

  useEffect(() => {
    if (videoRef.current && isHovered) {
      videoRef.current.play().catch(() => {
        // Handle autoplay failure silently
      })
    } else if (videoRef.current) {
      videoRef.current.pause()
      videoRef.current.currentTime = 0
    }
  }, [isHovered])

  const isVideo = src.endsWith('.mp4') || src.endsWith('.webm')

  if (!isVideo) {
    return (
      <div className="relative w-full">
        <Image
          src={src}
          alt=""
          width={0}
          height={0}
          sizes="100vw"
          className={className}
          style={{ width: '100%', height: 'auto' }}
        />
      </div>
    )
  }

  return (
    <div
      className="relative"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <video
        ref={videoRef}
        src={src}
        className={className}
        muted
        loop
        playsInline
        preload="metadata"
      />
      {!src && fallbackContent}
    </div>
  )
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

function Slider({
  className,
  defaultValue,
  value,
  min = 0,
  max = 100,
  ...props
}: React.ComponentProps<typeof SliderPrimitive.Root>) {
  const _values = React.useMemo(
    () =>
      Array.isArray(value)
        ? value
        : Array.isArray(defaultValue)
          ? defaultValue
          : [min, max],
    [value, defaultValue, min, max]
  )

  return (
    <SliderPrimitive.Root
      data-slot="slider"
      defaultValue={defaultValue}
      value={value}
      min={min}
      max={max}
      className={cn(
        "relative flex w-full touch-none items-center select-none data-[disabled]:opacity-50 data-[orientation=vertical]:h-full data-[orientation=vertical]:min-h-44 data-[orientation=vertical]:w-auto data-[orientation=vertical]:flex-col",
        className
      )}
      {...props}
    >
      <SliderPrimitive.Track
        data-slot="slider-track"
        className={cn(
          "bg-muted relative grow overflow-hidden rounded-full data-[orientation=horizontal]:h-1.5 data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-1.5"
        )}
      >
        <SliderPrimitive.Range
          data-slot="slider-range"
          className={cn(
            "bg-primary absolute data-[orientation=horizontal]:h-full data-[orientation=vertical]:w-full"
          )}
        />
      </SliderPrimitive.Track>
      {Array.from({ length: _values.length }, (_, index) => (
        <SliderPrimitive.Thumb
          data-slot="slider-thumb"
          key={index}
          className="border-primary bg-background ring-ring/50 block size-4 shrink-0 rounded-full border shadow-sm transition-[color,box-shadow] hover:ring-4 focus-visible:ring-4 focus-visible:outline-hidden disabled:pointer-events-none disabled:opacity-50"
        />
      ))}
    </SliderPrimitive.Root>
  )
}

export { Slider }
</file>

<file path="components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="components/ui/video-preview.tsx">
"use client"

import { useState, useRef, useEffect } from 'react'

interface VideoPreviewProps {
  src: string
  fallbackImage?: string
  className?: string
  autoPlayOnHover?: boolean
  muted?: boolean
  loop?: boolean
}

export function VideoPreview({
  src,
  fallbackImage,
  className = "",
  autoPlayOnHover = true,
  muted = true,
  loop = true
}: VideoPreviewProps) {
  const [isHovered, setIsHovered] = useState(false)
  const [showVideo, setShowVideo] = useState(false)
  const [isMobile, setIsMobile] = useState(false)
  const videoRef = useRef<HTMLVideoElement>(null)

  // Detect mobile device
  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768 || 'ontouchstart' in window)
    }
    checkMobile()
    window.addEventListener('resize', checkMobile)
    return () => window.removeEventListener('resize', checkMobile)
  }, [])

  // Handle video playback
  useEffect(() => {
    if (videoRef.current && showVideo && isHovered && !isMobile) {
      videoRef.current.play().catch(() => {
        // Handle autoplay failure silently
      })
    } else if (videoRef.current) {
      videoRef.current.pause()
      videoRef.current.currentTime = 0
    }
  }, [isHovered, showVideo, isMobile])

  const handleMouseEnter = () => {
    setIsHovered(true)
    if (autoPlayOnHover && !isMobile) {
      setShowVideo(true)
    }
  }

  const handleMouseLeave = () => {
    setIsHovered(false)
  }

  return (
    <div 
      className={`relative ${className}`}
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
    >
      {/* Always show video, but control playback based on hover */}
      <video
        ref={videoRef}
        src={src}
        className="w-full h-full object-cover"
        muted={muted}
        loop={loop}
        playsInline
        preload="metadata"
        poster={fallbackImage}
      />
    </div>
  )
}
</file>

<file path="contexts/CanvasContext.tsx">
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";
import { CanvasImage, useCanvas } from "@/app/canvas/_hooks/useCanvas";

interface CanvasContextType {
  images: CanvasImage[];
  thumbnails: CanvasImage[];
  selectedThumbnailIndex: number;
  toggleFavorite: (index: number) => void;
  selectThumbnail: (index: number) => void;
  addNewImage: () => void;
  brushSize: number;
  setBrushSize: (size: number) => void;
  selectedResolution: string;
  setSelectedResolution: (resolution: string) => void;
  selectedSize: string;
  setSelectedSize: (size: string) => void;
}

const CanvasContext = createContext<CanvasContextType | undefined>(undefined);

export function CanvasProvider({ children }: { children: ReactNode }) {
  const canvas = useCanvas();
  const [brushSize, setBrushSize] = useState(50);
  const [selectedResolution, setSelectedResolution] = useState("16:9");
  const [selectedSize, setSelectedSize] = useState("1920×1080");

  const value: CanvasContextType = {
    ...canvas,
    brushSize,
    setBrushSize,
    selectedResolution,
    setSelectedResolution,
    selectedSize,
    setSelectedSize,
  };

  return (
    <CanvasContext.Provider value={value}>
      {children}
    </CanvasContext.Provider>
  );
}

export function useCanvasContext() {
  const context = useContext(CanvasContext);
  if (!context) {
    throw new Error("useCanvasContext must be used within CanvasProvider");
  }
  return context;
}
</file>

<file path="contexts/ModalContext.tsx">
"use client";

import React, { createContext, useContext, useState, ReactNode } from "react";

interface ModalContextType {
  isLibraryOpen: boolean;
  setIsLibraryOpen: (open: boolean) => void;
  isEffectModalOpen: boolean;
  setIsEffectModalOpen: (open: boolean) => void;
  isPromptModalOpen: boolean;
  setIsPromptModalOpen: (open: boolean) => void;
  isCameraModalOpen: boolean;
  setIsCameraModalOpen: (open: boolean) => void;
  isModelModalOpen: boolean;
  setIsModelModalOpen: (open: boolean) => void;
  isBrushPopupOpen: boolean;
  setIsBrushPopupOpen: (open: boolean) => void;
  isPrompterOpen: boolean;
  setIsPrompterOpen: (open: boolean) => void;
}

const ModalContext = createContext<ModalContextType | undefined>(undefined);

export function ModalProvider({ children }: { children: ReactNode }) {
  const [isLibraryOpen, setIsLibraryOpen] = useState(false);
  const [isEffectModalOpen, setIsEffectModalOpen] = useState(false);
  const [isPromptModalOpen, setIsPromptModalOpen] = useState(false);
  const [isCameraModalOpen, setIsCameraModalOpen] = useState(false);
  const [isModelModalOpen, setIsModelModalOpen] = useState(false);
  const [isBrushPopupOpen, setIsBrushPopupOpen] = useState(false);
  const [isPrompterOpen, setIsPrompterOpen] = useState(false);

  const value: ModalContextType = {
    isLibraryOpen,
    setIsLibraryOpen,
    isEffectModalOpen,
    setIsEffectModalOpen,
    isPromptModalOpen,
    setIsPromptModalOpen,
    isCameraModalOpen,
    setIsCameraModalOpen,
    isModelModalOpen,
    setIsModelModalOpen,
    isBrushPopupOpen,
    setIsBrushPopupOpen,
    isPrompterOpen,
    setIsPrompterOpen,
  };

  return (
    <ModalContext.Provider value={value}>
      {children}
    </ModalContext.Provider>
  );
}

export function useModalContext() {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error("useModalContext must be used within ModalProvider");
  }
  return context;
}
</file>

<file path="contexts/ThemeContext.tsx">
"use client";

import React, { createContext, useContext, useState, useEffect, ReactNode } from "react";

type Theme = "light" | "dark" | "system";

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  resolvedTheme: "light" | "dark";
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState<Theme>("system");
  const [resolvedTheme, setResolvedTheme] = useState<"light" | "dark">("dark");

  useEffect(() => {
    const stored = localStorage.getItem("theme") as Theme | null;
    if (stored) {
      setTheme(stored);
    }
  }, []);

  useEffect(() => {
    const root = window.document.documentElement;
    
    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light";
      setResolvedTheme(systemTheme);
      root.classList.remove("light", "dark");
      root.classList.add(systemTheme);
    } else {
      setResolvedTheme(theme);
      root.classList.remove("light", "dark");
      root.classList.add(theme);
    }
    
    localStorage.setItem("theme", theme);
  }, [theme]);

  useEffect(() => {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    const handleChange = () => {
      if (theme === "system") {
        const systemTheme = mediaQuery.matches ? "dark" : "light";
        setResolvedTheme(systemTheme);
        const root = window.document.documentElement;
        root.classList.remove("light", "dark");
        root.classList.add(systemTheme);
      }
    };

    mediaQuery.addEventListener("change", handleChange);
    return () => mediaQuery.removeEventListener("change", handleChange);
  }, [theme]);

  const value: ThemeContextType = {
    theme,
    setTheme,
    resolvedTheme,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
}

export function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error("useTheme must be used within ThemeProvider");
  }
  return context;
}
</file>

<file path="docs/features/canvas-ai-video-generation-mvp.md">
# Canvas AI 영상 생성 기능 구현 문서 (MVP)

## MVP 핵심 원칙
- **Simple is Better**: 가장 간단한 방법으로 구현
- **Direct API Calls**: 큐 시스템 없이 직접 API 호출
- **Minimal Infrastructure**: 추가 인프라 최소화

## 기능 요구사항 (그대로 유지)
1. 이미지 업로드 (1장)
2. 효과/카메라/모델 선택 (각 카테고리에서 선택, 최대 4개 조합)
3. 영상 생성 (fal.ai Seedance/Hailo)
4. 생성된 영상 표시 (최대 3개)
5. 우측 패널 영상 로그
6. 다운로드 기능

## 간소화된 구현 방식

### 1. Next.js API Routes 직접 사용
```typescript
// app/api/canvas/generate/route.ts
export async function POST(request: Request) {
  const body = await request.json();
  
  // 1. DB에 생성 요청 저장 (pending 상태)
  const generation = await saveGeneration(body);
  
  // 2. fal.ai 직접 호출 (30-60초 소요)
  try {
    const videoUrl = await generateWithFal(body);
    
    // 3. 성공시 DB 업데이트
    await updateGeneration(generation.id, {
      status: 'completed',
      videoUrl
    });
    
    return Response.json({ 
      success: true, 
      generationId: generation.id,
      videoUrl 
    });
    
  } catch (error) {
    // 4. 실패시 에러 처리
    await updateGeneration(generation.id, {
      status: 'failed',
      error: error.message
    });
    
    return Response.json({ 
      success: false, 
      error: '영상 생성 실패' 
    }, { status: 500 });
  }
}
```

### 2. 클라이언트 처리 방식
```typescript
// 영상 생성 요청
const generateVideo = async () => {
  setIsGenerating(true);
  
  const response = await fetch('/api/canvas/generate', {
    method: 'POST',
    body: JSON.stringify({
      userId: session?.user?.id || 'anonymous',
      imageUrl: uploadedImage,
      selectedEffects,
      modelType: 'seedance'
    })
  });
  
  const data = await response.json();
  
  if (data.success) {
    // 성공시 영상 표시
    setGeneratedVideos(prev => [data.videoUrl, ...prev].slice(0, 3));
  } else {
    // 실패시 에러 표시
    toast.error(data.error);
  }
  
  setIsGenerating(false);
};
```

### 3. 이미지 업로드 간소화
```typescript
// app/api/canvas/upload/route.ts
export async function POST(request: Request) {
  const formData = await request.formData();
  const file = formData.get('file') as File;
  
  // Supabase Storage에 직접 업로드
  const fileName = `${Date.now()}_${file.name}`;
  const { data, error } = await supabase.storage
    .from('media-asset')
    .upload(`temp/${fileName}`, file);
  
  if (error) throw error;
  
  // Public URL 반환
  const publicUrl = supabase.storage
    .from('media-asset')
    .getPublicUrl(`temp/${fileName}`).data.publicUrl;
  
  return Response.json({ url: publicUrl });
}
```

## 데이터베이스 스키마 (기존 활용 + 최소 추가)

```sql
-- 기존 테이블 그대로 활용
-- categories, media_assets, creations

-- 효과 템플릿 (신규)
CREATE TABLE public.effect_templates (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category_id bigint NOT NULL REFERENCES public.categories(id),
  prompt text NOT NULL,
  preview_media_id bigint REFERENCES public.media_assets(id),
  display_order integer DEFAULT 0,
  is_active boolean DEFAULT true
);

-- 영상 생성 기록 (간소화)
CREATE TABLE public.video_generations (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id text NOT NULL DEFAULT 'anonymous', -- 인증 없이도 사용 가능
  source_image_url text NOT NULL,
  selected_effects jsonb NOT NULL,
  combined_prompt text NOT NULL,
  model_type text NOT NULL,
  status text NOT NULL DEFAULT 'pending',
  result_video_url text,
  error_message text,
  created_at timestamp with time zone DEFAULT now()
);
```

## 컴포넌트 구조

### Canvas 페이지 레이아웃
```typescript
// app/canvas/page.tsx
export default function CanvasPage() {
  return (
    <div className="flex h-screen">
      {/* 좌측: 프롬프터 섹션 */}
      <div className="w-80 border-r">
        <PrompterSection onEffectSelect={handleEffectSelect} />
      </div>
      
      {/* 중앙: 메인 작업 영역 */}
      <div className="flex-1 flex flex-col">
        <QuickActionsBar onGenerate={handleGenerate} />
        <div className="flex-1 grid grid-cols-2 gap-4 p-4">
          <ImageSection onImageUpload={handleImageUpload} />
          <EffectsSection selectedEffects={selectedEffects} />
        </div>
      </div>
      
      {/* 우측: 히스토리 패널 */}
      <div className="w-80 border-l">
        <VideoLogPanel />
      </div>
    </div>
  );
}
```

## fal.ai 통합 (간단 버전)

```typescript
// lib/fal-ai.ts
import * as fal from "@fal-ai/serverless-client";

// 서버사이드 전용
if (typeof window === 'undefined') {
  fal.config({
    credentials: process.env.FAL_API_KEY
  });
}

export async function generateVideo(
  imageUrl: string,
  prompt: string,
  modelType: 'seedance' | 'hailo' = 'seedance'
) {
  const model = modelType === 'seedance' 
    ? "fal-ai/fast-sdxl/image-to-video"  // 실제 모델명 확인 필요
    : "fal-ai/hailo";
    
  const result = await fal.run(model, {
    input: {
      image_url: imageUrl,
      prompt: prompt,
      // 기본 파라미터
      num_frames: 25,
      fps: 8,
      motion_strength: 0.7
    }
  });
  
  return result.video.url;
}
```

## 구현 순서 (2주 MVP)

### Week 1: 기본 기능
1. **Day 1-2**: DB 세팅 & 효과 템플릿 데이터
   ```sql
   -- 카테고리 추가
   INSERT INTO categories (name) VALUES ('effect'), ('camera'), ('model');
   
   -- 효과 템플릿 예시
   INSERT INTO effect_templates (name, category_id, prompt) VALUES
   ('Zoom In', 2, 'camera slowly zooming in'),
   ('Dreamy', 1, 'dreamy ethereal atmosphere'),
   ('Fashion Walk', 3, 'model walking on runway');
   ```

2. **Day 3-4**: API Routes
   - `/api/canvas/effects` - 효과 목록
   - `/api/canvas/upload` - 이미지 업로드
   - `/api/canvas/generate` - 영상 생성
   - `/api/canvas/history` - 생성 기록

3. **Day 5-7**: UI 컴포넌트 구현
   - 각 섹션별 컴포넌트
   - 상태 관리 (useState)

### Week 2: 통합 및 개선
1. **Day 8-9**: fal.ai 연동 및 테스트
2. **Day 10-11**: 에러 처리 및 로딩 상태
3. **Day 12-13**: 다운로드 기능 추가
4. **Day 14**: 최종 테스트 및 배포

## 주요 차이점 (원본 대비)

1. **동기식 처리**: 백그라운드 작업 대신 API Route에서 직접 처리
2. **폴링 제거**: 생성 완료까지 대기 (로딩 표시)
3. **인증 선택적**: 로그인 없이도 사용 가능 (세션 기반)
4. **스토리지 간소화**: 임시 폴더 사용, 정리는 나중에

## 예상 문제 및 해결

1. **타임아웃 (30초 제한)**
   - Vercel 함수 타임아웃 60초로 설정
   - 또는 Edge Function 사용 (300초)

2. **동시 요청 처리**
   - 클라이언트에서 중복 요청 방지
   - 생성 중일 때 버튼 비활성화

3. **비용 관리**
   - 일일 한도 설정 (환경변수)
   - 생성 횟수 카운트

## 환경 변수
```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
FAL_API_KEY=

# 옵션
DAILY_GENERATION_LIMIT=100
MAX_IMAGE_SIZE_MB=5
```

이 MVP 접근법으로 2주 내에 모든 기능을 구현할 수 있습니다.
</file>

<file path="docs/features/canvas-ai-video-generation.md">
# Canvas AI 영상 생성 기능 구현 문서

## 기능 개요

VogueDrop의 Canvas 페이지에서 사용자가 이미지를 업로드하고, AI 효과를 선택하여 동영상을 생성하는 기능입니다. fal.ai의 Seedance와 Hailo 모델을 활용하여 이미지를 동영상으로 변환합니다.

## 사용자 워크플로우

1. **이미지 업로드**: 사용자가 Image 섹션에 원본 이미지 1장 업로드
2. **효과 선택**: 
   - 효과/카메라/모델 카테고리별로 갤러리 형태의 예시 영상 제공
   - 사용자가 각 카테고리에서 원하는 효과 선택
   - 최대 4개까지 효과 조합 가능
3. **효과 미리보기**: Effect 섹션에 선택한 효과들의 예시 표시
4. **영상 생성**: Generate 버튼 클릭하여 AI 영상 생성 시작
5. **결과 확인**: 
   - Image 섹션에 생성된 영상 표시 (최대 3개)
   - 우측 패널에 생성 영상 로그 표시

## 기술 스택

- **Frontend**: Next.js, React, TypeScript
- **AI API**: fal.ai (Seedance, Hailo 모델)
- **Storage**: Supabase Storage
- **Database**: Supabase (PostgreSQL)
- **인증**: Supabase Auth

## 데이터베이스 스키마

### 기존 테이블 활용

```sql
-- categories 테이블: 효과/카메라/모델 카테고리 저장
-- 'effect', 'camera', 'model' 카테고리 추가 필요

-- media_assets 테이블: 
-- 1. 효과별 예시 영상 저장
-- 2. 사용자가 업로드한 원본 이미지 저장
-- 3. AI가 생성한 결과 영상 저장

-- creations 테이블: 
-- AI 영상 생성 결과물 메타데이터 저장
-- prompt 필드에 조합된 효과 프롬프트 저장
```

### 신규 테이블 필요

```sql
-- 효과 템플릿 테이블 (효과/카메라/모델의 옵션들)
CREATE TABLE public.effect_templates (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category_id bigint NOT NULL REFERENCES public.categories(id),
  prompt text NOT NULL, -- fal.ai에 전달할 프롬프트
  preview_media_id bigint REFERENCES public.media_assets(id), -- 예시 영상
  display_order integer DEFAULT 0,
  is_active boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now()
);

-- 사용자별 영상 생성 요청 기록
CREATE TABLE public.video_generations (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES auth.users(id),
  source_image_id bigint NOT NULL REFERENCES public.media_assets(id), -- 원본 이미지
  creation_id bigint REFERENCES public.creations(id), -- 생성 완료시 연결
  selected_effects jsonb NOT NULL, -- 선택한 effect_template id 배열
  combined_prompt text NOT NULL, -- 조합된 최종 프롬프트
  model_type text NOT NULL CHECK (model_type IN ('seedance', 'hailo')),
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  error_message text,
  fal_job_id text, -- fal.ai 작업 ID
  created_at timestamp with time zone DEFAULT now(),
  completed_at timestamp with time zone
);

-- 인덱스 추가
CREATE INDEX idx_video_generations_user_id ON public.video_generations(user_id);
CREATE INDEX idx_video_generations_status ON public.video_generations(status);
CREATE INDEX idx_effect_templates_category ON public.effect_templates(category_id);
```

## API 구조

### 1. Effect Templates API

```typescript
// /lib/api/canvas/effects.ts
import { createClient } from '@/lib/supabase';
import { getPublicUrl } from '@/lib/supabase';

export interface EffectTemplate {
  id: number;
  name: string;
  categoryId: number;
  categoryName: string;
  prompt: string;
  previewVideoUrl: string | null;
  displayOrder: number;
}

// 카테고리별 효과 템플릿 조회
export async function getEffectTemplatesByCategory(
  categoryName: 'effect' | 'camera' | 'model'
): Promise<EffectTemplate[]> {
  const supabase = createClient();
  
  const { data, error } = await supabase
    .from('effect_templates')
    .select(`
      id,
      name,
      prompt,
      display_order,
      category:categories!inner(id, name),
      preview_media:media_assets(storage_path)
    `)
    .eq('categories.name', categoryName)
    .eq('is_active', true)
    .order('display_order');

  if (error) throw error;

  return data.map(item => ({
    id: item.id,
    name: item.name,
    categoryId: item.category.id,
    categoryName: item.category.name,
    prompt: item.prompt,
    previewVideoUrl: item.preview_media ? 
      getPublicUrl(item.preview_media.storage_path) : null,
    displayOrder: item.display_order
  }));
}

// 선택한 효과들의 프롬프트 조합
export function combineEffectPrompts(effects: EffectTemplate[]): string {
  return effects.map(effect => effect.prompt).join(', ');
}
```

### 2. Video Generation API

```typescript
// /lib/api/canvas/video-generation.ts
import { createClient } from '@/lib/supabase';
import { generateSeedanceVideo, generateHailoVideo } from '@/lib/fal-ai';

export interface VideoGenerationRequest {
  userId: string;
  sourceImageId: number;
  selectedEffectIds: number[];
  modelType: 'seedance' | 'hailo';
}

export interface VideoGenerationResponse {
  generationId: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  videoUrl?: string;
  error?: string;
}

// 영상 생성 요청
export async function requestVideoGeneration(
  request: VideoGenerationRequest
): Promise<VideoGenerationResponse> {
  const supabase = createClient();
  
  // 1. 선택한 효과들 조회
  const { data: effects } = await supabase
    .from('effect_templates')
    .select('prompt')
    .in('id', request.selectedEffectIds);
  
  // 2. 프롬프트 조합
  const combinedPrompt = effects
    .map(e => e.prompt)
    .join(', ');
  
  // 3. 생성 요청 기록 저장
  const { data: generation, error } = await supabase
    .from('video_generations')
    .insert({
      user_id: request.userId,
      source_image_id: request.sourceImageId,
      selected_effects: request.selectedEffectIds,
      combined_prompt: combinedPrompt,
      model_type: request.modelType,
      status: 'pending'
    })
    .select()
    .single();
  
  if (error) throw error;
  
  // 4. 백그라운드에서 영상 생성 시작
  processVideoGeneration(generation.id);
  
  return {
    generationId: generation.id,
    status: 'pending'
  };
}

// 백그라운드 영상 생성 처리
async function processVideoGeneration(generationId: number) {
  const supabase = createClient();
  
  try {
    // 1. 생성 요청 정보 조회
    const { data: generation } = await supabase
      .from('video_generations')
      .select(`
        *,
        source_image:media_assets!source_image_id(storage_path)
      `)
      .eq('id', generationId)
      .single();
    
    // 2. 상태를 processing으로 업데이트
    await supabase
      .from('video_generations')
      .update({ status: 'processing' })
      .eq('id', generationId);
    
    // 3. fal.ai로 영상 생성
    const sourceImageUrl = getPublicUrl(generation.source_image.storage_path);
    let videoUrl: string;
    
    if (generation.model_type === 'seedance') {
      videoUrl = await generateSeedanceVideo(
        sourceImageUrl,
        generation.combined_prompt
      );
    } else {
      videoUrl = await generateHailoVideo(
        sourceImageUrl,
        generation.combined_prompt
      );
    }
    
    // 4. 생성된 영상을 Supabase Storage에 저장
    const videoPath = await saveGeneratedVideo(
      videoUrl,
      generation.user_id,
      generationId
    );
    
    // 5. media_assets에 영상 정보 저장
    const { data: mediaAsset } = await supabase
      .from('media_assets')
      .insert({
        storage_path: videoPath,
        file_name: `generated_${generationId}.mp4`,
        media_type: 'video'
      })
      .select()
      .single();
    
    // 6. creations에 결과물 저장
    const { data: creation } = await supabase
      .from('creations')
      .insert({
        title: `AI Generated Video ${new Date().toISOString()}`,
        prompt: generation.combined_prompt,
        category_id: 1, // TODO: 적절한 카테고리 ID
        product_id: mediaAsset.id
      })
      .select()
      .single();
    
    // 7. 생성 완료 상태 업데이트
    await supabase
      .from('video_generations')
      .update({
        status: 'completed',
        creation_id: creation.id,
        completed_at: new Date().toISOString()
      })
      .eq('id', generationId);
    
  } catch (error) {
    // 에러 발생시 상태 업데이트
    await supabase
      .from('video_generations')
      .update({
        status: 'failed',
        error_message: error.message
      })
      .eq('id', generationId);
  }
}

// 생성 상태 조회
export async function getGenerationStatus(
  generationId: number
): Promise<VideoGenerationResponse> {
  const supabase = createClient();
  
  const { data, error } = await supabase
    .from('video_generations')
    .select(`
      status,
      error_message,
      creation:creations(
        product:media_assets!product_id(storage_path)
      )
    `)
    .eq('id', generationId)
    .single();
  
  if (error) throw error;
  
  return {
    generationId,
    status: data.status,
    videoUrl: data.creation?.product ? 
      getPublicUrl(data.creation.product.storage_path) : undefined,
    error: data.error_message
  };
}

// 사용자의 생성 히스토리 조회
export async function getUserGenerationHistory(
  userId: string,
  limit = 20,
  offset = 0
) {
  const supabase = createClient();
  
  const { data, error } = await supabase
    .from('video_generations')
    .select(`
      *,
      source_image:media_assets!source_image_id(storage_path),
      creation:creations(
        product:media_assets!product_id(storage_path)
      )
    `)
    .eq('user_id', userId)
    .eq('status', 'completed')
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);
  
  if (error) throw error;
  
  return data.map(item => ({
    id: item.id,
    sourceImageUrl: getPublicUrl(item.source_image.storage_path),
    videoUrl: item.creation?.product ? 
      getPublicUrl(item.creation.product.storage_path) : null,
    createdAt: item.created_at,
    modelType: item.model_type
  }));
}
```

### 3. Storage 관리

```typescript
// /lib/api/canvas/storage.ts
import { createClient } from '@/lib/supabase';

// 사용자별 스토리지 경로 생성
export function getUserStoragePath(
  userId: string, 
  type: 'source' | 'generated'
): string {
  return `${userId}/${type}`;
}

// 이미지 업로드
export async function uploadSourceImage(
  file: File,
  userId: string
): Promise<number> {
  const supabase = createClient();
  
  // 1. 파일 유효성 검사
  if (!['image/jpeg', 'image/png'].includes(file.type)) {
    throw new Error('JPG, PNG 형식만 지원됩니다.');
  }
  
  if (file.size > 10 * 1024 * 1024) {
    throw new Error('파일 크기는 10MB 이하여야 합니다.');
  }
  
  // 2. Storage에 업로드
  const fileName = `${Date.now()}_${file.name}`;
  const storagePath = `${getUserStoragePath(userId, 'source')}/${fileName}`;
  
  const { error: uploadError } = await supabase.storage
    .from('media-asset')
    .upload(storagePath, file);
  
  if (uploadError) throw uploadError;
  
  // 3. media_assets 테이블에 기록
  const { data, error } = await supabase
    .from('media_assets')
    .insert({
      storage_path: storagePath,
      file_name: fileName,
      media_type: 'image'
    })
    .select()
    .single();
  
  if (error) throw error;
  
  return data.id;
}

// 생성된 영상 저장
export async function saveGeneratedVideo(
  videoUrl: string,
  userId: string,
  generationId: number
): Promise<string> {
  const supabase = createClient();
  
  // 1. 외부 URL에서 영상 다운로드
  const response = await fetch(videoUrl);
  const blob = await response.blob();
  
  // 2. Storage에 저장
  const fileName = `generation_${generationId}.mp4`;
  const storagePath = `${getUserStoragePath(userId, 'generated')}/${fileName}`;
  
  const { error } = await supabase.storage
    .from('media-asset')
    .upload(storagePath, blob);
  
  if (error) throw error;
  
  return storagePath;
}

// 다운로드 URL 생성
export async function getVideoDownloadUrl(
  videoPath: string
): Promise<string> {
  const supabase = createClient();
  
  const { data } = supabase.storage
    .from('media-asset')
    .getPublicUrl(videoPath, {
      download: true
    });
  
  return data.publicUrl;
}
```

### 4. fal.ai 연동

```typescript
// /lib/fal-ai/client.ts
import * as fal from "@fal-ai/serverless-client";

// 서버 사이드에서만 실행
if (typeof window === 'undefined') {
  fal.config({
    credentials: process.env.FAL_API_KEY
  });
}

export { fal };

// /lib/fal-ai/models.ts
import { fal } from './client';

// Seedance 모델
export async function generateSeedanceVideo(
  imageUrl: string,
  prompt: string
): Promise<string> {
  const result = await fal.run("fal-ai/seedance", {
    input: {
      image_url: imageUrl,
      prompt: prompt,
      num_frames: 25,
      fps: 7,
      seed: -1
    }
  });
  
  return result.video.url;
}

// Hailo 모델
export async function generateHailoVideo(
  imageUrl: string,
  prompt: string
): Promise<string> {
  const result = await fal.run("fal-ai/hailo", {
    input: {
      image_url: imageUrl,
      prompt: prompt,
      duration: 4,
      aspect_ratio: "16:9"
    }
  });
  
  return result.video.url;
}
```

## 컴포넌트 구조 업데이트

### 1. ImageSection 컴포넌트

```typescript
// /app/canvas/_components/ImageSection.tsx
interface ImageSectionProps {
  onImageUpload: (imageId: number) => void;
  generatedVideos: GeneratedVideo[];
  isGenerating: boolean;
}

// 주요 기능:
// - 이미지 드래그 앤 드롭 업로드
// - 업로드 진행률 표시
// - 생성된 영상 최대 3개 표시
// - "Generating..." 로딩 애니메이션
// - 영상 미리보기 및 다운로드
```

### 2. PrompterSection 컴포넌트

```typescript
// /app/canvas/_components/PrompterSection.tsx
interface PrompterSectionProps {
  onEffectSelect: (effect: EffectTemplate) => void;
  selectedEffects: EffectTemplate[];
}

// 주요 기능:
// - 3개 탭 (효과, 카메라, 모델)
// - 각 탭별 예시 영상 갤러리
// - 호버시 영상 자동 재생
// - 선택 상태 표시
// - 스켈레톤 로딩
```

### 3. EffectsSection 컴포넌트

```typescript
// /app/canvas/_components/EffectsSection.tsx
interface EffectsSectionProps {
  selectedEffects: EffectTemplate[];
  onEffectRemove: (effectId: number) => void;
  onEffectReorder: (effects: EffectTemplate[]) => void;
}

// 주요 기능:
// - 선택한 효과 카드 표시 (최대 4개)
// - X 버튼으로 효과 제거
// - 드래그 앤 드롭으로 순서 변경
// - 빈 슬롯 표시
```

### 4. VideoLogPanel 컴포넌트 (신규)

```typescript
// /app/canvas/_components/VideoLogPanel.tsx
interface VideoLogPanelProps {
  userId: string;
}

// 주요 기능:
// - 생성된 영상 히스토리 표시
// - 무한 스크롤
// - 다운로드 버튼
// - 생성 시간 표시
// - 영상 호버 미리보기
```

## 보안 및 권한

### RLS 정책

```sql
-- effect_templates: 모든 사용자 읽기 가능
ALTER TABLE public.effect_templates ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can read effect templates" 
ON public.effect_templates FOR SELECT 
USING (true);

-- video_generations: 사용자별 접근 제한
ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view own generations" 
ON public.video_generations FOR SELECT 
USING (auth.uid() = user_id);

CREATE POLICY "Users can create own generations" 
ON public.video_generations FOR INSERT 
WITH CHECK (auth.uid() = user_id);

-- Storage 정책은 STORAGE_BUCKET_SETUP.md 참조
```

## 구현 우선순위

### Phase 1: 기본 기능 (1주)
1. [ ] DB 스키마 생성 및 마이그레이션
2. [ ] Effect Templates 시드 데이터 입력
3. [ ] 이미지 업로드 API 및 UI
4. [ ] 효과 선택 갤러리 UI
5. [ ] fal.ai Seedance 연동
6. [ ] 영상 생성 및 표시

### Phase 2: 사용자 경험 개선 (1주)
1. [ ] 생성 진행 상태 실시간 업데이트
2. [ ] 에러 처리 및 재시도
3. [ ] 영상 로그 패널
4. [ ] 다운로드 기능
5. [ ] Hailo 모델 추가

### Phase 3: 고급 기능 (2주)
1. [ ] 효과 순서 드래그 앤 드롭
2. [ ] 커스텀 프롬프트 입력
3. [ ] 배치 생성 (여러 효과 조합 동시 생성)
4. [ ] 생성 영상 갤러리 공유

## 에러 처리

```typescript
// 에러 메시지 상수
export const ERROR_MESSAGES = {
  UPLOAD_FAILED: '이미지 업로드에 실패했습니다. 다시 시도해주세요.',
  GENERATION_FAILED: '영상 생성에 실패했습니다. 다시 시도해주세요.',
  NETWORK_ERROR: '네트워크 연결을 확인해주세요.',
  FILE_TOO_LARGE: '파일 크기는 10MB 이하여야 합니다.',
  INVALID_FORMAT: 'JPG, PNG 형식만 지원됩니다.',
  MAX_EFFECTS_REACHED: '최대 4개까지 효과를 선택할 수 있습니다.',
  NO_EFFECTS_SELECTED: '최소 1개 이상의 효과를 선택해주세요.'
};
```

## 성능 최적화

1. **이미지 최적화**
   - 클라이언트: 업로드 전 브라우저에서 리사이징
   - 서버: Sharp를 사용한 이미지 최적화

2. **비디오 스트리밍**
   - HLS 스트리밍 지원
   - 썸네일 자동 생성

3. **캐싱 전략**
   - Effect Templates: 24시간 캐싱
   - 생성된 영상: CDN 캐싱

4. **API 최적화**
   - 배치 요청 지원
   - GraphQL 고려 (향후)
</file>

<file path="docs/features/fal.ai.md">
Queue API | fal.ai Reference
For requests that take longer than several seconds, as it is usually the case with AI models, we provide a queue system.

It offers granular control in dealing with surges in traffic, allows you to cancel requests and monitor the current position within the queue, and removes the need to keep long running connections open.

Queue endpoints
The queue functionality is exposed via standardized per-model paths under https://queue.fal.run.

Endpoint	Method	Description
https://queue.fal.run/{model_id}	POST	Adds a request to the queue for a top-level path
https://queue.fal.run/{model_id}/{subpath}	POST	Adds a request to the queue for an optional subpath
https://queue.fal.run/{model_id}/requests/{request_id}/status	GET	Gets the status of a request
https://queue.fal.run/{model_id}/requests/{request_id}/status/stream	GET	Streams the status of a request until it’s completed
https://queue.fal.run/{model_id}/requests/{request_id}	GET	Gets the response of a request
https://queue.fal.run/{model_id}/requests/{request_id}/cancel	PUT	Cancels a request that has not started processing
Parameters:

model_id: the model ID consists of a namespace and model name separated by a slash, e.g. fal-ai/fast-sdxl. Many models expose only a single top-level endpoint, so you can directly call them by model_id.
subpath: some models expose different capabilities at different sub-paths, e.g. fal-ai/flux/dev. The subpath (/dev in this case) should be used when making the request, but not when getting request status or results
request_id is returned after adding a request to the queue. This is the identifier you use to check the status and get results and logs
Submit a request
Here is an example of using curl to submit a request which will add it to the queue:

Terminal window
curl -X POST https://queue.fal.run/fal-ai/fast-sdxl \
  -H "Authorization: Key $FAL_KEY" \
  -d '{"prompt": "a cat"}'

Here’s an example of a response with the request_id:

{
  "request_id": "80e732af-660e-45cd-bd63-580e4f2a94cc",
  "response_url": "https://queue.fal.run/fal-ai/fast-sdxl/requests/80e732af-660e-45cd-bd63-580e4f2a94cc",
  "status_url": "https://queue.fal.run/fal-ai/fast-sdxl/requests/80e732af-660e-45cd-bd63-580e4f2a94cc/status",
  "cancel_url": "https://queue.fal.run/fal-ai/fast-sdxl/requests/80e732af-660e-45cd-bd63-580e4f2a94cc/cancel"
}

The payload helps you to keep track of your request with the request_id, and provides you with the necessary information to get the status of your request, cancel it or get the response once it’s ready, so you don’t have to build these endpoints yourself.

Request status
Once you have the request id you may use this request id to get the status of the request. This endpoint will give you information about your request’s status, it’s position in the queue or the response itself if the response is ready.

Terminal window
curl -X GET https://queue.fal.run/fal-ai/fast-sdxl/requests/{request_id}/status

Here’s an example of a response with the IN_QUEUE status:

{
  "status": "IN_QUEUE",
  "queue_position": 0,
  "response_url": "https://queue.fal.run/fal-ai/fast-sdxl/requests/80e732af-660e-45cd-bd63-580e4f2a94cc"
}

Status types
Queue status can have one of the following types and their respective properties:

IN_QUEUE:

queue_position: The current position of the task in the queue.
response_url: The URL where the response will be available once the task is processed.
IN_PROGRESS:

logs: An array of logs related to the request. Note that it needs to be enabled, as explained in the next section.
response_url: The URL where the response will be available.
COMPLETED:

logs: An array of logs related to the request. Note that it needs to be enabled, as explained in the next section.
response_url: The URL where the response is available.
Logs
Logs are disabled by default. In order to enable logs for your request, you need to send the logs=1 query parameter when getting the status of your request. For example:

Terminal window
curl -X GET https://queue.fal.run/fal-ai/fast-sdxl/requests/{request_id}/status?logs=1

When enabled, the logs attribute in the queue status contains an array of log entries, each represented by the RequestLog type. A RequestLog object has the following attributes:

message: a string containing the log message.
level: the severity of the log, it can be one of the following:
STDERR | STDOUT | ERROR | INFO | WARN | DEBUG
source: indicates the source of the log.
timestamp: a string representing the time when the log was generated.
These logs offer valuable insights into the status and progress of your queued tasks, facilitating effective monitoring and debugging.

Streaming status
If you want to keep track of the status of your request in real-time, you can use the streaming endpoint. The response is text/event-stream and each event is a JSON object with the status of the request exactly as the non-stream endpoint.

This endpoint will keep the connection open until the status of the request changes to COMPLETED.

It supports the same logs query parameter as the status.

Terminal window
curl -X GET https://queue.fal.run/fal-ai/fast-sdxl/requests/{request_id}/status/stream

Here is an example of a stream of status updates:

Terminal window
$ curl https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/status/stream?logs=1 --header "Authorization: Key $FAL_KEY"

data: {"status": "IN_PROGRESS", "request_id": "3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "response_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "status_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/status", "cancel_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/cancel", "logs": [], "metrics": {}}

data: {"status": "IN_PROGRESS", "request_id": "3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "response_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "status_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/status", "cancel_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/cancel", "logs": [{"timestamp": "2024-12-20T15:37:17.120314", "message": "INFO:TRYON:Preprocessing images...", "labels": {}}, {"timestamp": "2024-12-20T15:37:17.286519", "message": "INFO:TRYON:Running try-on model...", "labels": {}}], "metrics": {}}

data: {"status": "IN_PROGRESS", "request_id": "3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "response_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "status_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/status", "cancel_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/cancel", "logs": [], "metrics": {}}

: ping

data: {"status": "IN_PROGRESS", "request_id": "3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "response_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "status_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/status", "cancel_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/cancel", "logs": [], "metrics": {}}

data: {"status": "COMPLETED", "request_id": "3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "response_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf", "status_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/status", "cancel_url": "https://queue.fal.run/fashn/tryon/requests/3e3e5b55-45fb-4e5c-b4d1-05702dffc8bf/cancel", "logs": [{"timestamp": "2024-12-20T15:37:32.161184", "message": "INFO:TRYON:Finished running try-on model.", "labels": {}}], "metrics": {"inference_time": 17.795265674591064}}

Cancelling a request
If your request has not started processing (status is IN_QUEUE), you may attempt to cancel it.

Terminal window
curl -X PUT https://queue.fal.run/fal-ai/fast-sdxl/requests/{request_id}/cancel

If the request has not already started processing, you will get a 202 Accepted response with the following body:

{
  "status": "CANCELLATION_REQUESTED"
}

Note that a request may still be executed after getting this response if it was very late in the queue process.

If the request is already processed, you will get a 400 Bad Request response with this body:

{
  "status": "ALREADY_COMPLETED"
}

Getting the response
Once you get the COMPLETED status, the response will be available along with its logs.

Terminal window
curl -X GET https://queue.fal.run/fal-ai/fast-sdxl/requests/{request_id}

Here’s an example of a response with the COMPLETED status:

{
  "status": "COMPLETED",
  "logs": [
    {
      "message": "2020-05-04 14:00:00.000000",
      "level": "INFO",
      "source": "stdout",
      "timestamp": "2020-05-04T14:00:00.000000Z"
    }
  ],
  "response": {
    "message": "Hello World!"
  }
}

Webhooks API | fal.ai Reference
Webhooks work in tandem with the queue system explained above, it is another way to interact with our queue. By providing us a webhook endpoint you get notified when the request is done as opposed to polling it.

Here is how this works in practice, it is very similar to submitting something to the queue but we require you to pass an extra fal_webhook query parameter.

To utilize webhooks, your requests should be directed to the queue.fal.run endpoint, instead of the standard fal.run. This distinction is crucial for enabling webhook functionality, as it ensures your request is handled by the queue system designed to support asynchronous operations and notifications.

Terminal window
curl --request POST \
  --url 'https://queue.fal.run/fal-ai/flux/dev?fal_webhook=https://url.to.your.app/api/fal/webhook' \
  --header "Authorization: Key $FAL_KEY" \
  --header 'Content-Type: application/json' \
  --data '{
  "prompt": "Photo of a cute dog"
}'

The request will be queued and you will get a response with the request_id and gateway_request_id:

{
  "request_id": "024ca5b1-45d3-4afd-883e-ad3abe2a1c4d",
  "gateway_request_id": "024ca5b1-45d3-4afd-883e-ad3abe2a1c4d"
}

These two will be mostly the same, but if the request failed and was retried, gateway_request_id will have the value of the last tried request, while request_id will be the value used in the queue API.

Once the request is done processing in the queue, a POST request is made to the webhook URL, passing the request info and the resulting payload. The status indicates whether the request was successful or not.

When to use it?

Webhooks are particularly useful for requests that can take a while to process and/or the result is not needed immediately. For example, if you are training a model, which is a process than can take several minutes or even hours, webhooks could be the perfect tool for the job.

Successful result
The following is an example of a successful request:

{
  "request_id": "123e4567-e89b-12d3-a456-426614174000",
  "gateway_request_id": "123e4567-e89b-12d3-a456-426614174000",
  "status": "OK",
  "payload": {
    "images": [
      {
        "url": "https://url.to/image.png",
        "content_type": "image/png",
        "file_name": "image.png",
        "file_size": 1824075,
        "width": 1024,
        "height": 1024
      }
    ],
    "seed": 196619188014358660
  }
}

Response errors
When an error happens, the status will be ERROR. The error property will contain a message and the payload will provide the error details. For example, if you forget to pass the required model_name parameter, you will get the following response:

{
  "request_id": "123e4567-e89b-12d3-a456-426614174000",
  "gateway_request_id": "123e4567-e89b-12d3-a456-426614174000",
  "status": "ERROR",
  "error": "Invalid status code: 422",
  "payload": {
    "detail": [
      {
        "loc": ["body", "prompt"],
        "msg": "field required",
        "type": "value_error.missing"
      }
    ]
  }
}

Payload errors
For the webhook to include the payload, it must be valid JSON. So if there is an error serializing it, payload is set to null and a payload_error will include details about the error.

{
  "request_id": "123e4567-e89b-12d3-a456-426614174000",
  "gateway_request_id": "123e4567-e89b-12d3-a456-426614174000",
  "status": "OK",
  "payload": null,
  "payload_error": "Response payload is not JSON serializable. Either return a JSON serializable object or use the queue endpoint to retrieve the response."
}

Retry policy
If the webhook fails to deliver the payload, it will retry 10 times in the span of 2 hours.

Verifying Your Webhook
To ensure the security and integrity of incoming webhook requests, you must verify that they originate from the expected source. This involves validating a cryptographic signature included in the request using a set of public keys. Below is a step-by-step guide to the verification process, followed by example implementations in Python and JavaScript.

Verification Process
Fetch the JSON Web Key Set (JWKS):

Retrieve the public keys from the JWKS endpoint: https://rest.alpha.fal.ai/.well-known/jwks.json.
The JWKS contains a list of public keys in JSON format, each with an x field holding a base64url-encoded ED25519 public key.
Note: The JWKS is cacheable to reduce network requests. Ensure your implementation caches the keys and refreshes them after the cache duration expires. Do not cache longer than 24 hours since they can change.
Extract Required Headers:

Obtain the following headers from the incoming webhook request:
X-Fal-Webhook-Request-Id: The unique request ID.
X-Fal-Webhook-User-Id: Your user ID.
X-Fal-Webhook-Timestamp: The timestamp when the request was generated (in Unix epoch seconds).
X-Fal-Webhook-Signature: The cryptographic signature in hexadecimal format.
If any header is missing, the request is invalid.
Verify the Timestamp:

Compare the X-Fal-Webhook-Timestamp with the current Unix timestamp.
Allow a leeway of ±5 minutes (300 seconds) to account for clock skew and network delays.
If the timestamp differs by more than 300 seconds, reject the request to prevent replay attacks.
Construct the Message:

Compute the SHA-256 hash of the request body (raw bytes, not JSON-parsed).
Concatenate the following in strict order, separated by newline characters (\n):
X-Fal-Webhook-Request-Id
X-Fal-Webhook-User-Id
X-Fal-Webhook-Timestamp
Hex-encoded SHA-256 hash of the request body
Encode the resulting string as UTF-8 bytes to form the message to verify.
Verify the Signature:

Decode the X-Fal-Webhook-Signature from hexadecimal to bytes.
For each public key in the JWKS:
Decode the x field from base64url to bytes.
Use an ED25519 verification function (e.g., from PyNaCl in Python or libsodium in JavaScript) to verify the signature against the constructed message.
If any key successfully verifies the signature, the request is valid.
If no key verifies the signature, the request is invalid.
Example Implementations
Below are simplified functions to verify webhook signatures by passing the header values and request body directly. These examples handle the verification process as described above and include JWKS caching.

python
javascript
Install dependencies:

Terminal window
pip install pynacl requests

Verification function:

import base64
import hashlib
import time
from typing import Optional
import requests
from nacl.signing import VerifyKey
from nacl.exceptions import BadSignatureError
from nacl.encoding import HexEncoder

JWKS_URL = "https://rest.alpha.fal.ai/.well-known/jwks.json"
JWKS_CACHE_DURATION = 24 * 60 * 60  # 24 hours in seconds
_jwks_cache = None
_jwks_cache_time = 0

def fetch_jwks() -> list:
    """Fetch and cache JWKS, refreshing after 24 hours."""
    global _jwks_cache, _jwks_cache_time
    current_time = time.time()
    if _jwks_cache is None or (current_time - _jwks_cache_time) > JWKS_CACHE_DURATION:
        response = requests.get(JWKS_URL, timeout=10)
        response.raise_for_status()
        _jwks_cache = response.json().get("keys", [])
        _jwks_cache_time = current_time
    return _jwks_cache

def verify_webhook_signature(
    request_id: str,
    user_id: str,
    timestamp: str,
    signature_hex: str,
    body: bytes
) -> bool:
    """
    Verify a webhook signature using provided headers and body.

    Args:
        request_id: Value of X-Fal-Webhook-Request-Id header.
        user_id: Value of X-Fal-Webhook-User-Id header.
        timestamp: Value of X-Fal-Webhook-Timestamp header.
        signature_hex: Value of X-Fal-Webhook-Signature header (hex-encoded).
        body: Raw request body as bytes.

    Returns:
        bool: True if the signature is valid, False otherwise.
    """
    # Validate timestamp (within ±5 minutes)
    try:
        timestamp_int = int(timestamp)
        current_time = int(time.time())
        if abs(current_time - timestamp_int) > 300:
            print("Timestamp is too old or in the future.")
            return False
    except ValueError:
        print("Invalid timestamp format.")
        return False

    # Construct the message to verify
    try:
        message_parts = [
            request_id,
            user_id,
            timestamp,
            hashlib.sha256(body).hexdigest()
        ]
        if any(part is None for part in message_parts):
            print("Missing required header value.")
            return False
        message_to_verify = "\n".join(message_parts).encode("utf-8")
    except Exception as e:
        print(f"Error constructing message: {e}")
        return False

    # Decode signature
    try:
        signature_bytes = bytes.fromhex(signature_hex)
    except ValueError:
        print("Invalid signature format (not hexadecimal).")
        return False

    # Fetch public keys
    try:
        public_keys_info = fetch_jwks()
        if not public_keys_info:
            print("No public keys found in JWKS.")
            return False
    except Exception as e:
        print(f"Error fetching JWKS: {e}")
        return False

    # Verify signature with each public key
    for key_info in public_keys_info:
        try:
            public_key_b64url = key_info.get("x")
            if not isinstance(public_key_b64url, str):
                continue
            public_key_bytes = base64.urlsafe_b64decode(public_key_b64url)
            verify_key = VerifyKey(public_key_bytes.hex(), encoder=HexEncoder)
            verify_key.verify(message_to_verify, signature_bytes)
            return True
        except (BadSignatureError, Exception) as e:
            print(f"Verification failed with a key: {e}")
            continue

    print("Signature verification failed with all keys.")
    return False

Usage Notes
Caching the JWKS: The JWKS can be cached for 24 hours to minimize network requests. The example implementations include basic in-memory caching.
Timestamp Validation: The ±5-minute leeway ensures robustness against minor clock differences. Adjust this value if your use case requires stricter or looser validation.
Error Handling: The examples include comprehensive error handling for missing headers, invalid signatures, and network issues. Log errors appropriately for debugging.
Framework Integration: For frameworks like FastAPI (Python) or Express (JavaScript), ensure the raw request body is accessible. For Express, use express.raw({ type: 'application/json' }) middleware before JSON parsing.
</file>

<file path="docs/frontend-architecture.md">
# VogueDrop Frontend Architecture Document

## Template and Framework Selection

This document outlines the frontend architecture for VogueDrop MVP, based on the existing implementation using Next.js 14+ with App Router. The project is a greenfield implementation without using any starter template, following modern React patterns and best practices.

### Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-30 | 1.0 | Initial frontend architecture based on existing implementation | BMad Master |

## Frontend Tech Stack

### Technology Stack Table
| Category | Technology | Version | Purpose | Rationale |
|----------|------------|---------|---------|-----------|
| Framework | Next.js | 14.2+ | React framework with App Router | Server-side rendering, file-based routing, API routes |
| UI Library | React | 18.2+ | Component-based UI library | Industry standard, great ecosystem |
| State Management | React Hooks | Built-in | Local component state | Simple, sufficient for MVP needs |
| Routing | Next.js App Router | 14.2+ | File-based routing | Built into framework, type-safe |
| Build Tool | Next.js CLI | 14.2+ | Build and development | Zero configuration needed |
| Styling | Tailwind CSS | 3.4+ | Utility-first CSS | Rapid development, consistent design |
| Testing | Vitest | 1.2+ | Unit and component testing | Fast, Jest-compatible |
| Component Library | Custom | - | Project-specific components | Full control over design |
| Form Handling | Native React | - | Controlled components | Simple forms, no complex validation yet |
| Animation | CSS/Tailwind | - | Basic transitions | Sufficient for MVP animations |
| Dev Tools | TypeScript | 5.3+ | Type safety | Prevents runtime errors |

## Project Structure

```
voguedrop/
├── app/                          # Next.js App Router
│   ├── (auth)/                   # Authentication route group
│   │   ├── login/
│   │   │   └── page.tsx
│   │   └── signup/
│   │       └── page.tsx
│   ├── (home)/                   # Public route group
│   │   └── _components/
│   │       ├── GalleryItems.tsx
│   │       └── HeroSection.tsx
│   ├── canvas/                   # Canvas AI feature
│   │   ├── _components/          # Feature-specific components
│   │   │   ├── Canvas.tsx
│   │   │   ├── CanvasControls.tsx
│   │   │   ├── EffectsSection.tsx
│   │   │   ├── ImageSection.tsx
│   │   │   ├── LeftPanel.tsx
│   │   │   ├── PrompterSection.tsx
│   │   │   ├── QuickActionsBar.tsx
│   │   │   └── VideoLogPanel.tsx
│   │   ├── _hooks/              # Feature-specific hooks
│   │   │   └── useCanvas.ts
│   │   └── page.tsx
│   ├── video-editor/            # Video editor feature
│   │   ├── _components/
│   │   │   ├── ControlBar.tsx
│   │   │   ├── Header.tsx
│   │   │   ├── SoundLibraryModal.tsx
│   │   │   ├── Timeline.tsx
│   │   │   ├── VideoLibraryModal.tsx
│   │   │   └── VideoPreview.tsx
│   │   └── page.tsx
│   ├── api/                     # API routes
│   │   ├── auth/
│   │   ├── canvas/
│   │   └── editor/
│   ├── globals.css              # Global styles
│   ├── layout.tsx               # Root layout
│   └── page.tsx                 # Home page
├── components/                   # Shared components
│   ├── layout/
│   │   └── Header.tsx
│   ├── modals/                  # Shared modal components
│   │   ├── CameraModal.tsx
│   │   ├── EffectModal.tsx
│   │   ├── LibraryModal.tsx
│   │   ├── ModelModal.tsx
│   │   └── PromptModal.tsx
│   └── ui/                      # Base UI components
│       ├── Button.tsx
│       ├── Input.tsx
│       └── Modal.tsx
├── lib/                         # Utilities and configurations
│   ├── api/
│   │   ├── client.ts
│   │   └── gallery.ts
│   ├── supabase/
│   │   └── client.ts
│   └── utils/
│       └── cn.ts
├── hooks/                       # Global hooks
│   └── useAuth.ts
├── stores/                      # Global state stores (future)
├── types/                       # TypeScript definitions
│   ├── api.ts
│   └── database.ts
└── public/                      # Static assets
```

## Component Standards

### Component Template
```typescript
// Example: components/features/FeatureName/ComponentName.tsx
"use client"; // Only if client component

import { FC, ReactNode } from 'react';
import { cn } from '@/lib/utils/cn';

interface ComponentNameProps {
  children?: ReactNode;
  className?: string;
  // Other props with TypeScript types
  title: string;
  onAction?: () => void;
  isActive?: boolean;
}

export const ComponentName: FC<ComponentNameProps> = ({ 
  children,
  className,
  title,
  onAction,
  isActive = false,
}) => {
  // Component logic here
  const handleClick = () => {
    onAction?.();
  };

  return (
    <div className={cn(
      "base-classes",
      isActive && "active-classes",
      className
    )}>
      <h2>{title}</h2>
      {children}
      <button onClick={handleClick}>Action</button>
    </div>
  );
};

// Default export for pages
export default ComponentName;
```

### Naming Conventions
- **Components**: PascalCase (e.g., `VideoPreview.tsx`, `EffectSelector.tsx`)
- **Files**: Same as component name for components, kebab-case for utilities
- **Hooks**: camelCase with 'use' prefix (e.g., `useCanvas.ts`, `useVideoEditor.ts`)
- **Types/Interfaces**: PascalCase with descriptive suffixes (e.g., `VideoGenerationProps`, `CanvasState`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_EFFECTS_COUNT`, `API_ENDPOINTS`)
- **Functions**: camelCase (e.g., `generateVideo`, `uploadImage`)
- **CSS Classes**: Tailwind utilities, custom classes use kebab-case
- **Route Groups**: Parentheses for grouping without affecting URL (e.g., `(auth)`, `(app)`)

## State Management

### Store Structure
```
stores/
├── canvas.store.ts       # Canvas feature state
├── editor.store.ts       # Video editor state
├── auth.store.ts         # Authentication state
└── ui.store.ts          # UI state (modals, themes)

hooks/
├── useCanvas.ts         # Canvas-specific hook
├── useVideoEditor.ts    # Editor-specific hook
└── useAuth.ts          # Auth hook
```

### State Management Template
```typescript
// Example: Local state with custom hook (current pattern)
// hooks/useCanvas.ts
import { useState, useCallback } from 'react';

export interface CanvasState {
  uploadedImage: string | null;
  selectedEffects: string[];
  isGenerating: boolean;
}

export function useCanvas() {
  const [state, setState] = useState<CanvasState>({
    uploadedImage: null,
    selectedEffects: [],
    isGenerating: false,
  });

  const uploadImage = useCallback((imageUrl: string) => {
    setState(prev => ({ ...prev, uploadedImage: imageUrl }));
  }, []);

  const toggleEffect = useCallback((effectId: string) => {
    setState(prev => ({
      ...prev,
      selectedEffects: prev.selectedEffects.includes(effectId)
        ? prev.selectedEffects.filter(id => id !== effectId)
        : [...prev.selectedEffects, effectId].slice(0, 4), // Max 4 effects
    }));
  }, []);

  const generateVideo = useCallback(async () => {
    setState(prev => ({ ...prev, isGenerating: true }));
    try {
      // API call here
      await canvasService.generateVideo(state);
    } finally {
      setState(prev => ({ ...prev, isGenerating: false }));
    }
  }, [state]);

  return {
    ...state,
    uploadImage,
    toggleEffect,
    generateVideo,
  };
}

// Future: Zustand store pattern
// stores/canvas.store.ts
import { create } from 'zustand';

interface CanvasStore extends CanvasState {
  uploadImage: (url: string) => void;
  toggleEffect: (effectId: string) => void;
  generateVideo: () => Promise<void>;
}

export const useCanvasStore = create<CanvasStore>((set, get) => ({
  uploadedImage: null,
  selectedEffects: [],
  isGenerating: false,
  
  uploadImage: (url) => set({ uploadedImage: url }),
  
  toggleEffect: (effectId) => set((state) => ({
    selectedEffects: state.selectedEffects.includes(effectId)
      ? state.selectedEffects.filter(id => id !== effectId)
      : [...state.selectedEffects, effectId].slice(0, 4),
  })),
  
  generateVideo: async () => {
    set({ isGenerating: true });
    try {
      const state = get();
      await canvasService.generateVideo(state);
    } finally {
      set({ isGenerating: false });
    }
  },
}));
```

## API Integration

### Service Template
```typescript
// lib/api/services/canvas.service.ts
import { apiClient } from '@/lib/api/client';
import type { VideoGeneration, GenerateVideoParams } from '@/types/api';

export const canvasService = {
  /**
   * Upload image for video generation
   */
  async uploadImage(file: File): Promise<{ url: string }> {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/api/canvas/upload', {
      method: 'POST',
      body: formData,
    });
    
    if (!response.ok) {
      throw new Error('Failed to upload image');
    }
    
    return response.json();
  },

  /**
   * Get available effects by category
   */
  async getEffects(category?: string): Promise<EffectTemplate[]> {
    return apiClient.get('/canvas/effects', { 
      params: { category } 
    });
  },

  /**
   * Generate AI video
   */
  async generateVideo(params: GenerateVideoParams): Promise<VideoGeneration> {
    return apiClient.post('/canvas/generate', params);
  },

  /**
   * Get user's generation history
   */
  async getHistory(page = 1, limit = 20): Promise<{
    data: VideoGeneration[];
    total: number;
    page: number;
  }> {
    return apiClient.get('/canvas/history', {
      params: { page, limit }
    });
  },
};
```

### API Client Configuration
```typescript
// lib/api/client.ts
import { createClient } from '@supabase/supabase-js';

class ApiClient {
  private baseUrl = '/api';
  
  private async request<T>(
    endpoint: string,
    options: RequestInit & { params?: Record<string, any> } = {}
  ): Promise<T> {
    const { params, ...init } = options;
    
    // Build URL with query params
    const url = new URL(`${this.baseUrl}${endpoint}`, window.location.origin);
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined) {
          url.searchParams.append(key, String(value));
        }
      });
    }
    
    // Get auth token from Supabase
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );
    
    const { data: { session } } = await supabase.auth.getSession();
    
    const response = await fetch(url.toString(), {
      ...init,
      headers: {
        'Content-Type': 'application/json',
        ...(session && { 'Authorization': `Bearer ${session.access_token}` }),
        ...init.headers,
      },
    });
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({ 
        message: 'Network error' 
      }));
      throw new Error(error.message || `HTTP ${response.status}`);
    }
    
    return response.json();
  }
  
  async get<T>(endpoint: string, options?: RequestInit & { params?: Record<string, any> }): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'GET' });
  }
  
  async post<T>(endpoint: string, data?: any, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: data ? JSON.stringify(data) : undefined,
    });
  }
  
  async put<T>(endpoint: string, data?: any, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, {
      ...options,
      method: 'PUT',
      body: data ? JSON.stringify(data) : undefined,
    });
  }
  
  async delete<T>(endpoint: string, options?: RequestInit): Promise<T> {
    return this.request<T>(endpoint, { ...options, method: 'DELETE' });
  }
}

export const apiClient = new ApiClient();
```

## Routing

### Route Configuration
```typescript
// app/(app)/layout.tsx - Protected routes
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';

export default async function ProtectedLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = createServerComponentClient({ cookies });
  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    redirect('/login');
  }

  return <>{children}</>;
}

// middleware.ts - Route protection
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });

  const {
    data: { session },
  } = await supabase.auth.getSession();

  // Protected routes
  const protectedRoutes = ['/canvas', '/video-editor', '/history'];
  const isProtectedRoute = protectedRoutes.some(route => 
    req.nextUrl.pathname.startsWith(route)
  );

  if (isProtectedRoute && !session) {
    return NextResponse.redirect(new URL('/login', req.url));
  }

  // Redirect to dashboard if logged in and accessing auth pages
  const authRoutes = ['/login', '/signup'];
  const isAuthRoute = authRoutes.some(route => 
    req.nextUrl.pathname.startsWith(route)
  );

  if (isAuthRoute && session) {
    return NextResponse.redirect(new URL('/canvas', req.url));
  }

  return res;
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)'],
};
```

## Styling Guidelines

### Styling Approach
VogueDrop uses Tailwind CSS for styling with a utility-first approach. This enables rapid development while maintaining consistency across the application.

Key principles:
- Use Tailwind utilities for all styling
- Create custom components for repeated patterns
- Use CSS variables for theming
- Leverage Tailwind's dark mode support

### Global Theme Variables
```css
/* app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    /* Colors */
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    
    /* Spacing */
    --spacing-xs: 0.25rem;
    --spacing-sm: 0.5rem;
    --spacing-md: 1rem;
    --spacing-lg: 1.5rem;
    --spacing-xl: 2rem;
    --spacing-2xl: 3rem;
    
    /* Typography */
    --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    --font-mono: "SF Mono", Consolas, "Liberation Mono", monospace;
    
    /* Shadows */
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
  }
}

@layer components {
  /* Custom component styles */
  .btn-primary {
    @apply bg-primary text-primary-foreground hover:bg-primary/90 
           px-4 py-2 rounded-md font-medium transition-colors;
  }
  
  .modal-overlay {
    @apply fixed inset-0 bg-black/50 z-50 flex items-center justify-center;
  }
  
  .card {
    @apply rounded-lg border bg-card text-card-foreground shadow-sm;
  }
}
```

## Testing Requirements

### Component Test Template
```typescript
// __tests__/components/Canvas/EffectSelector.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { EffectSelector } from '@/app/canvas/_components/EffectSelector';

// Mock dependencies
vi.mock('@/lib/api/services/canvas.service', () => ({
  canvasService: {
    getEffects: vi.fn().mockResolvedValue([
      { id: '1', name: 'RGB Split', category: 'effect' },
      { id: '2', name: 'Wave Flow', category: 'effect' },
    ]),
  },
}));

describe('EffectSelector', () => {
  const mockOnSelect = vi.fn();
  
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('renders effect options', async () => {
    render(
      <EffectSelector 
        category="effect" 
        onSelect={mockOnSelect}
        selectedEffects={[]}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('RGB Split')).toBeInTheDocument();
      expect(screen.getByText('Wave Flow')).toBeInTheDocument();
    });
  });

  it('limits selection to 4 effects', async () => {
    const selectedEffects = ['1', '2', '3', '4'];
    
    render(
      <EffectSelector 
        category="effect" 
        onSelect={mockOnSelect}
        selectedEffects={selectedEffects}
        maxSelection={4}
      />
    );

    await waitFor(() => {
      const newEffect = screen.getByText('New Effect');
      fireEvent.click(newEffect);
      
      expect(mockOnSelect).not.toHaveBeenCalled();
      expect(screen.getByText('Maximum 4 effects')).toBeInTheDocument();
    });
  });

  it('handles API errors gracefully', async () => {
    vi.mocked(canvasService.getEffects).mockRejectedValueOnce(
      new Error('Network error')
    );

    render(
      <EffectSelector 
        category="effect" 
        onSelect={mockOnSelect}
        selectedEffects={[]}
      />
    );

    await waitFor(() => {
      expect(screen.getByText('Failed to load effects')).toBeInTheDocument();
    });
  });
});
```

### Testing Best Practices
1. **Unit Tests**: Test individual components in isolation
2. **Integration Tests**: Test component interactions
3. **E2E Tests**: Test critical user flows (using Cypress/Playwright)
4. **Coverage Goals**: Aim for 80% code coverage
5. **Test Structure**: Arrange-Act-Assert pattern
6. **Mock External Dependencies**: API calls, routing, state management

## Environment Configuration

```bash
# .env.local - Frontend environment variables
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
NEXT_PUBLIC_FAL_API_URL=https://api.fal.ai
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Feature flags
NEXT_PUBLIC_ENABLE_VIDEO_EDITOR=true
NEXT_PUBLIC_ENABLE_SOCIAL_LOGIN=false

# Analytics (optional)
NEXT_PUBLIC_GA_ID=G-XXXXXXXXXX
NEXT_PUBLIC_VERCEL_ANALYTICS_ID=your-analytics-id
```

## Frontend Developer Standards

### Critical Coding Rules
1. **Always use TypeScript**: Never use `any` type, define proper interfaces
2. **Component Organization**: Use feature-based folders with `_components` and `_hooks`
3. **Client Components**: Mark with `"use client"` only when necessary (state, effects, browser APIs)
4. **Error Boundaries**: Wrap feature sections with error boundaries
5. **Loading States**: Always show loading indicators during async operations
6. **Accessibility**: Use semantic HTML, ARIA labels, keyboard navigation
7. **Image Optimization**: Use Next.js Image component for all images
8. **API Error Handling**: Always handle errors with user-friendly messages
9. **Form Validation**: Validate on client before submission
10. **Performance**: Lazy load heavy components, use React.memo for expensive renders

### Quick Reference

**Common Commands:**
```bash
# Development
npm run dev          # Start dev server (http://localhost:3000)
npm run build        # Build for production
npm run start        # Start production server
npm run lint         # Run ESLint
npm run type-check   # Run TypeScript compiler

# Testing
npm test            # Run unit tests
npm run test:watch  # Run tests in watch mode
npm run test:e2e    # Run E2E tests
```

**Key Import Patterns:**
```typescript
// Components
import { ComponentName } from '@/components/ui/ComponentName';
import { FeatureComponent } from '@/app/feature/_components/FeatureComponent';

// Hooks
import { useCanvas } from '@/app/canvas/_hooks/useCanvas';
import { useAuth } from '@/hooks/useAuth';

// Services
import { canvasService } from '@/lib/api/services/canvas.service';

// Types
import type { VideoGeneration } from '@/types/api';
import type { Database } from '@/types/database';

// Utils
import { cn } from '@/lib/utils/cn';
```

**File Naming Conventions:**
- Components: `ComponentName.tsx`
- Hooks: `useHookName.ts`
- Services: `service-name.service.ts`
- Types: `type-name.ts`
- Utils: `util-name.ts`

**Project-Specific Patterns:**
- Modal Management: Use portal pattern with `@/components/modals`
- Feature Hooks: Create custom hooks in `_hooks` folder
- API Integration: Use service layer pattern
- State Management: Local state with hooks, prepare for Zustand
- Error Handling: Consistent error boundaries and toast notifications

## Component Library Architecture

### Base UI Components
Located in `components/ui/`, these are the foundational building blocks:
- Button
- Input
- Modal
- Card
- Select
- Tooltip

### Feature Components
Located in `app/[feature]/_components/`, these are feature-specific:
- Canvas components (ImageSection, EffectsSection, etc.)
- Video Editor components (Timeline, VideoPreview, etc.)

### Shared Components
Located in `components/`, these are used across features:
- Layout components (Header, Footer)
- Modal components (shared across features)
- Common patterns (LoadingSpinner, ErrorBoundary)

## Performance Optimization Guidelines

1. **Code Splitting**: Use dynamic imports for heavy components
2. **Image Optimization**: Always use Next.js Image with proper sizing
3. **Bundle Size**: Monitor with `@next/bundle-analyzer`
4. **Caching**: Leverage SWR or React Query for data fetching (future)
5. **Memoization**: Use React.memo and useMemo for expensive operations
6. **Virtual Lists**: Implement for large lists (video history)

## Security Best Practices

1. **Input Sanitization**: Sanitize all user inputs
2. **XSS Prevention**: Use React's built-in escaping
3. **CSP Headers**: Configure in next.config.js
4. **Secure Storage**: Never store sensitive data in localStorage
5. **API Security**: Always validate on backend, frontend validation is UX only

## Deployment Considerations

1. **Build Optimization**: Use production builds with proper env vars
2. **Static Generation**: Leverage SSG where possible
3. **Edge Functions**: Use for API routes when applicable
4. **CDN Strategy**: Serve assets through Vercel's CDN
5. **Monitoring**: Implement error tracking and analytics
</file>

<file path="docs/fullstack-architecture.md">
# VogueDrop Fullstack Architecture Document

## Introduction

This document outlines the complete fullstack architecture for VogueDrop MVP, including backend systems, frontend implementation, and their integration. It serves as the single source of truth for AI-driven development, ensuring consistency across the entire technology stack.

This unified approach combines what would traditionally be separate backend and frontend architecture documents, streamlining the development process for modern fullstack applications where these concerns are increasingly intertwined.

### Starter Template or Existing Project
N/A - Greenfield project with existing partial implementation

### Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-30 | 1.0 | Initial architecture document | BMad Master |

## High Level Architecture

### Technical Summary
VogueDrop is a serverless fullstack application built with Next.js 14+ and deployed on Vercel, utilizing Supabase for authentication, database, and storage. The architecture follows a Jamstack pattern with server-side rendering for optimal performance and SEO. Frontend and backend are tightly integrated through Next.js API Routes, providing a seamless development experience. The system integrates with fal.ai for AI video generation capabilities. This architecture enables rapid MVP development while maintaining scalability for future growth.

### Platform and Infrastructure Choice
**Platform:** Vercel + Supabase
**Key Services:** 
- Vercel (Hosting, Edge Functions, CDN)
- Supabase (PostgreSQL, Auth, Storage, Realtime)
- fal.ai (AI Video Generation)
**Deployment Host and Regions:** Vercel Global Edge Network (Auto-scaling)

### Repository Structure
**Structure:** Monorepo
**Monorepo Tool:** npm workspaces (built into npm 7+)
**Package Organization:** Feature-based co-location within Next.js app directory

### High Level Architecture Diagram

```mermaid
graph TB
    subgraph "Client"
        A[Browser - Desktop]
    end
    
    subgraph "Vercel Edge Network"
        B[CDN]
        C[Next.js App]
        D[API Routes]
    end
    
    subgraph "Supabase"
        E[PostgreSQL]
        F[Auth Service]
        G[Storage]
    end
    
    subgraph "External Services"
        H[fal.ai API]
    end
    
    A --> B
    B --> C
    C --> D
    D --> E
    D --> F
    D --> G
    D --> H
    C --> F
```

### Architectural Patterns
- **Jamstack Architecture:** Static generation with dynamic API routes - _Rationale:_ Optimal performance for content-heavy pages with dynamic user data
- **Feature-First Co-location:** Components, hooks, and utilities organized by feature - _Rationale:_ Better maintainability and developer experience for small teams
- **Server Components (RSC):** React Server Components for data fetching - _Rationale:_ Reduced client bundle size and improved initial page load
- **API Route Handlers:** Next.js 14 route handlers for backend logic - _Rationale:_ Simplified backend development without separate server
- **Optimistic UI Updates:** Client-side state updates before server confirmation - _Rationale:_ Better perceived performance for AI generation workflows

## Tech Stack

### Technology Stack Table
| Category | Technology | Version | Purpose | Rationale |
|----------|------------|---------|---------|-----------|
| Frontend Language | TypeScript | 5.3+ | Type-safe frontend development | Prevents runtime errors, better IDE support |
| Frontend Framework | Next.js | 14.2+ | React framework with SSR/SSG | Full-stack capabilities, Vercel optimization |
| UI Component Library | Tailwind CSS | 3.4+ | Utility-first CSS | Rapid UI development, consistent styling |
| State Management | Zustand | 4.5+ | Client state management | Simple API, TypeScript support, small bundle |
| Backend Language | TypeScript | 5.3+ | Type-safe backend development | Shared types with frontend |
| Backend Framework | Next.js API Routes | 14.2+ | Serverless API endpoints | Integrated with frontend, automatic scaling |
| API Style | REST | - | HTTP API design | Simple, well-understood, fits use case |
| Database | PostgreSQL | 15+ | Primary data store | Relational data, Supabase integration |
| Cache | Vercel Edge Cache | - | CDN caching | Automatic caching, no setup required |
| File Storage | Supabase Storage | - | Media file storage | Integrated auth, direct browser uploads |
| Authentication | Supabase Auth | 2.0+ | User authentication | Built-in email/password, session management |
| Frontend Testing | Vitest | 1.2+ | Unit testing | Fast, Jest-compatible, ESM support |
| Backend Testing | Vitest | 1.2+ | API testing | Same as frontend for consistency |
| E2E Testing | Playwright | 1.40+ | End-to-end testing | Cross-browser support, reliable |
| Build Tool | Next.js CLI | 14.2+ | Build orchestration | Integrated with framework |
| Bundler | Turbopack | Beta | Fast bundling | Next.js integration, fast HMR |
| IaC Tool | N/A | - | Infrastructure as Code | Using platform services, no custom infra |
| CI/CD | GitHub Actions | - | Continuous integration | Free for public repos, Vercel integration |
| Monitoring | Vercel Analytics | - | Performance monitoring | Built-in, zero config |
| Logging | Vercel Functions Logs | - | Application logging | Automatic, integrated with platform |
| CSS Framework | Tailwind CSS | 3.4+ | Styling system | Utility classes, tree-shaking |

## Data Models

### User
**Purpose:** Represents authenticated users of the platform

**Key Attributes:**
- id: uuid - Unique identifier from Supabase Auth
- email: string - User's email address
- created_at: timestamp - Account creation time
- updated_at: timestamp - Last profile update

**TypeScript Interface:**
```typescript
interface User {
  id: string;
  email: string;
  created_at: string;
  updated_at: string;
}
```

**Relationships:**
- Has many VideoGenerations
- Has many Projects (future)

### Category
**Purpose:** Categorizes effects for video generation (effect, camera, model)

**Key Attributes:**
- id: bigint - Unique identifier
- name: string - Category name (unique)
- created_at: timestamp - Creation time

**TypeScript Interface:**
```typescript
interface Category {
  id: string;
  name: 'effect' | 'camera' | 'model';
  created_at: string;
}
```

**Relationships:**
- Has many EffectTemplates

### EffectTemplate
**Purpose:** Pre-defined effects/prompts for video generation

**Key Attributes:**
- id: bigint - Unique identifier
- name: string - Display name
- category_id: bigint - Reference to category
- prompt: string - AI prompt text
- preview_media_id: bigint? - Preview image/video
- display_order: number - UI ordering
- is_active: boolean - Enable/disable flag

**TypeScript Interface:**
```typescript
interface EffectTemplate {
  id: string;
  name: string;
  category_id: string;
  category?: Category;
  prompt: string;
  preview_media_id?: string;
  preview_media?: MediaAsset;
  display_order: number;
  is_active: boolean;
  created_at: string;
}
```

**Relationships:**
- Belongs to Category
- Has optional MediaAsset for preview

### MediaAsset
**Purpose:** Stores references to uploaded media files

**Key Attributes:**
- id: bigint - Unique identifier
- storage_path: string - Supabase storage path (unique)
- file_name: string? - Original filename
- media_type: string? - MIME type
- created_at: timestamp - Upload time

**TypeScript Interface:**
```typescript
interface MediaAsset {
  id: string;
  storage_path: string;
  file_name?: string;
  media_type?: string;
  created_at: string;
  public_url?: string; // Computed field
}
```

**Relationships:**
- Referenced by EffectTemplates
- Referenced by VideoGenerations (future)

### VideoGeneration
**Purpose:** Tracks AI video generation requests and results

**Key Attributes:**
- id: bigint - Unique identifier
- user_id: string - User ID or 'anonymous'
- source_image_url: string - Uploaded image URL
- selected_effects: jsonb - Array of selected effect IDs
- combined_prompt: string - Final prompt sent to AI
- model_type: string - 'seedance' or 'hailo'
- status: string - pending/processing/completed/failed
- result_video_url: string? - Generated video URL
- error_message: string? - Error details if failed
- created_at: timestamp - Generation time

**TypeScript Interface:**
```typescript
interface VideoGeneration {
  id: string;
  user_id: string;
  source_image_url: string;
  selected_effects: string[];
  combined_prompt: string;
  model_type: 'seedance' | 'hailo';
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result_video_url?: string;
  error_message?: string;
  created_at: string;
}
```

**Relationships:**
- Belongs to User (if authenticated)
- References EffectTemplates (via selected_effects)

## API Specification

### REST API Specification

```yaml
openapi: 3.0.0
info:
  title: VogueDrop API
  version: 1.0.0
  description: API for AI video generation and editing
servers:
  - url: https://voguedrop.vercel.app/api
    description: Production API

paths:
  /auth/signup:
    post:
      summary: Create new user account
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                password:
                  type: string
      responses:
        200:
          description: User created successfully
          
  /auth/login:
    post:
      summary: Login user
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                email:
                  type: string
                password:
                  type: string
      responses:
        200:
          description: Login successful
          
  /auth/logout:
    post:
      summary: Logout user
      responses:
        200:
          description: Logout successful
          
  /canvas/effects:
    get:
      summary: Get all effect templates
      parameters:
        - name: category
          in: query
          schema:
            type: string
            enum: [effect, camera, model]
      responses:
        200:
          description: List of effect templates
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/EffectTemplate'
                  
  /canvas/upload:
    post:
      summary: Upload image for generation
      requestBody:
        required: true
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                file:
                  type: string
                  format: binary
      responses:
        200:
          description: Upload successful
          content:
            application/json:
              schema:
                type: object
                properties:
                  url:
                    type: string
                    
  /canvas/generate:
    post:
      summary: Generate AI video
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                imageUrl:
                  type: string
                selectedEffects:
                  type: array
                  items:
                    type: string
                modelType:
                  type: string
                  enum: [seedance, hailo]
      responses:
        200:
          description: Generation started
          content:
            application/json:
              schema:
                type: object
                properties:
                  generationId:
                    type: string
                  videoUrl:
                    type: string
                    
  /canvas/history:
    get:
      summary: Get user's generation history
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
      responses:
        200:
          description: List of generations
          content:
            application/json:
              schema:
                type: object
                properties:
                  data:
                    type: array
                    items:
                      $ref: '#/components/schemas/VideoGeneration'
                  total:
                    type: integer
                  page:
                    type: integer
                    
  /editor/export:
    post:
      summary: Export edited video
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                timeline:
                  type: object
                quality:
                  type: string
                  enum: [720p, 1080p]
      responses:
        200:
          description: Export started
          content:
            application/json:
              schema:
                type: object
                properties:
                  exportUrl:
                    type: string

components:
  schemas:
    EffectTemplate:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        category:
          type: string
        prompt:
          type: string
        preview_url:
          type: string
          
    VideoGeneration:
      type: object
      properties:
        id:
          type: string
        source_image_url:
          type: string
        result_video_url:
          type: string
        status:
          type: string
        created_at:
          type: string
```

## Components

### Frontend Application
**Responsibility:** Next.js application serving UI and handling client-side logic

**Key Interfaces:**
- Server Components for initial page renders
- Client Components for interactive features
- API client services for backend communication

**Dependencies:** Supabase Auth SDK, fal.ai client

**Technology Stack:** Next.js 14+, React 18+, TypeScript, Tailwind CSS

### API Routes
**Responsibility:** Serverless backend endpoints handling business logic

**Key Interfaces:**
- REST endpoints for all operations
- Middleware for authentication
- Error handling and validation

**Dependencies:** Supabase Admin SDK, fal.ai SDK

**Technology Stack:** Next.js API Routes, TypeScript

### Canvas AI Service
**Responsibility:** Manages AI video generation workflow

**Key Interfaces:**
- POST /api/canvas/generate
- GET /api/canvas/effects
- POST /api/canvas/upload

**Dependencies:** Supabase Storage, fal.ai API

**Technology Stack:** TypeScript, fal.ai SDK

### Video Editor Service
**Responsibility:** Handles video editing operations

**Key Interfaces:**
- Timeline manipulation APIs
- Export functionality
- Media management

**Dependencies:** FFmpeg.wasm (client-side)

**Technology Stack:** TypeScript, FFmpeg.wasm

### Authentication Service
**Responsibility:** User authentication and session management

**Key Interfaces:**
- Supabase Auth integration
- Session middleware
- Protected route handling

**Dependencies:** Supabase Auth

**Technology Stack:** Supabase Auth SDK, Next.js middleware

## External APIs

### fal.ai API
- **Purpose:** AI video generation from images
- **Documentation:** https://fal.ai/docs
- **Base URL(s):** https://api.fal.ai
- **Authentication:** API Key (Bearer token)
- **Rate Limits:** Based on subscription tier

**Key Endpoints Used:**
- `POST /fal-ai/fast-sdxl/image-to-video` - Generate video from image

**Integration Notes:** Handle timeout scenarios, implement retry logic for failed generations

## Core Workflows

### User Registration and Login Flow
```mermaid
sequenceDiagram
    participant U as User
    participant C as Client
    participant A as API Routes
    participant S as Supabase Auth
    participant D as Database

    U->>C: Enter email/password
    C->>A: POST /api/auth/signup
    A->>S: Create user
    S->>D: Store user profile
    S-->>A: Return session
    A-->>C: Set cookies
    C-->>U: Redirect to dashboard
```

### AI Video Generation Flow
```mermaid
sequenceDiagram
    participant U as User
    participant C as Client
    participant A as API Routes
    participant S as Supabase Storage
    participant F as fal.ai
    participant D as Database

    U->>C: Upload image
    C->>A: POST /api/canvas/upload
    A->>S: Store image
    S-->>A: Return URL
    A-->>C: Image URL
    
    U->>C: Select effects & generate
    C->>A: POST /api/canvas/generate
    A->>D: Create generation record
    A->>F: Call AI API
    F-->>A: Video URL (30-60s)
    A->>D: Update record
    A-->>C: Success + video URL
    C-->>U: Display video
```

## Database Schema

```sql
-- Users table managed by Supabase Auth
-- Reference via auth.users

-- Categories for effects
CREATE TABLE public.categories (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text NOT NULL UNIQUE,
  created_at timestamp with time zone DEFAULT now()
);

-- Effect templates
CREATE TABLE public.effect_templates (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category_id bigint NOT NULL REFERENCES categories(id),
  prompt text NOT NULL,
  preview_media_id bigint REFERENCES media_assets(id),
  display_order integer DEFAULT 0,
  is_active boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now()
);

-- Media assets storage references
CREATE TABLE public.media_assets (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  storage_path text NOT NULL UNIQUE,
  file_name text,
  media_type text,
  created_at timestamp with time zone DEFAULT now()
);

-- Video generation history
CREATE TABLE public.video_generations (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id text NOT NULL DEFAULT 'anonymous',
  source_image_url text NOT NULL,
  selected_effects jsonb NOT NULL,
  combined_prompt text NOT NULL,
  model_type text NOT NULL CHECK (model_type IN ('seedance', 'hailo')),
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  result_video_url text,
  error_message text,
  created_at timestamp with time zone DEFAULT now()
);

-- Indexes for performance
CREATE INDEX idx_video_generations_user_id ON video_generations(user_id);
CREATE INDEX idx_video_generations_status ON video_generations(status);
CREATE INDEX idx_effect_templates_category ON effect_templates(category_id);
```

## Frontend Architecture

### Component Architecture

#### Component Organization
```
app/
├── (auth)/
│   ├── login/
│   │   └── page.tsx
│   └── signup/
│       └── page.tsx
├── (app)/
│   ├── canvas/
│   │   ├── _components/
│   │   │   ├── ImageUpload.tsx
│   │   │   ├── EffectSelector.tsx
│   │   │   ├── VideoPreview.tsx
│   │   │   └── GenerationHistory.tsx
│   │   └── page.tsx
│   ├── history/
│   │   └── page.tsx
│   └── editor/
│       ├── _components/
│       │   ├── Timeline.tsx
│       │   ├── VideoControls.tsx
│       │   └── ExportDialog.tsx
│       └── page.tsx
├── _components/
│   ├── ui/              # Shared UI components
│   └── layout/          # Layout components
└── api/                 # API routes
```

#### Component Template
```typescript
// Example component structure
import { FC } from 'react';

interface ComponentProps {
  // Props definition
}

export const Component: FC<ComponentProps> = ({ ...props }) => {
  // Component logic
  
  return (
    <div className="...">
      {/* Component JSX */}
    </div>
  );
};
```

### State Management Architecture

#### State Structure
```typescript
// stores/canvas.store.ts
interface CanvasState {
  uploadedImage: string | null;
  selectedEffects: string[];
  isGenerating: boolean;
  generatedVideos: VideoGeneration[];
  
  // Actions
  setUploadedImage: (url: string) => void;
  toggleEffect: (effectId: string) => void;
  generateVideo: () => Promise<void>;
}

// stores/editor.store.ts
interface EditorState {
  timeline: TimelineItem[];
  currentTime: number;
  isPlaying: boolean;
  
  // Actions
  addToTimeline: (item: TimelineItem) => void;
  updateTimeline: (items: TimelineItem[]) => void;
  exportVideo: (quality: string) => Promise<string>;
}
```

#### State Management Patterns
- Use Zustand for global client state
- Server state handled by React Query (future)
- Form state with react-hook-form
- URL state with Next.js router

### Routing Architecture

#### Route Organization
```
app/
├── (auth)/          # Auth layout group
│   ├── layout.tsx   # Public layout
│   ├── login/
│   └── signup/
├── (app)/           # Protected layout group
│   ├── layout.tsx   # Authenticated layout
│   ├── canvas/
│   ├── history/
│   └── editor/
└── api/             # API routes
```

#### Protected Route Pattern
```typescript
// app/(app)/layout.tsx
import { createServerComponentClient } from '@supabase/auth-helpers-nextjs';
import { redirect } from 'next/navigation';

export default async function ProtectedLayout({
  children
}: {
  children: React.ReactNode;
}) {
  const supabase = createServerComponentClient({ cookies });
  const { data: { session } } = await supabase.auth.getSession();
  
  if (!session) {
    redirect('/login');
  }
  
  return <>{children}</>;
}
```

### Frontend Services Layer

#### API Client Setup
```typescript
// lib/api-client.ts
class ApiClient {
  private baseUrl = '/api';
  
  async request<T>(
    endpoint: string,
    options?: RequestInit
  ): Promise<T> {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.statusText}`);
    }
    
    return response.json();
  }
}

export const api = new ApiClient();
```

#### Service Example
```typescript
// services/canvas.service.ts
export const canvasService = {
  async uploadImage(file: File): Promise<{ url: string }> {
    const formData = new FormData();
    formData.append('file', file);
    
    const response = await fetch('/api/canvas/upload', {
      method: 'POST',
      body: formData,
    });
    
    return response.json();
  },
  
  async generateVideo(params: GenerateParams): Promise<VideoGeneration> {
    return api.request('/canvas/generate', {
      method: 'POST',
      body: JSON.stringify(params),
    });
  },
  
  async getEffects(category?: string): Promise<EffectTemplate[]> {
    const query = category ? `?category=${category}` : '';
    return api.request(`/canvas/effects${query}`);
  }
};
```

## Backend Architecture

### Service Architecture

#### Function Organization
```
app/api/
├── auth/
│   ├── signup/
│   │   └── route.ts
│   ├── login/
│   │   └── route.ts
│   └── logout/
│       └── route.ts
├── canvas/
│   ├── effects/
│   │   └── route.ts
│   ├── upload/
│   │   └── route.ts
│   ├── generate/
│   │   └── route.ts
│   └── history/
│       └── route.ts
└── editor/
    └── export/
        └── route.ts
```

#### Function Template
```typescript
// app/api/canvas/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    
    // Check authentication
    const { data: { session } } = await supabase.auth.getSession();
    const userId = session?.user?.id || 'anonymous';
    
    // Parse request body
    const body = await request.json();
    
    // Business logic
    const result = await generateVideo(body, userId);
    
    return NextResponse.json(result);
  } catch (error) {
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### Database Architecture

#### Data Access Layer
```typescript
// lib/db/repositories/video-generation.repository.ts
export class VideoGenerationRepository {
  constructor(private supabase: SupabaseClient) {}
  
  async create(data: Partial<VideoGeneration>) {
    const { data: generation, error } = await this.supabase
      .from('video_generations')
      .insert(data)
      .select()
      .single();
      
    if (error) throw error;
    return generation;
  }
  
  async updateStatus(id: string, status: string, videoUrl?: string) {
    const { error } = await this.supabase
      .from('video_generations')
      .update({ 
        status, 
        result_video_url: videoUrl,
        updated_at: new Date().toISOString()
      })
      .eq('id', id);
      
    if (error) throw error;
  }
  
  async getUserHistory(userId: string, page = 1, limit = 20) {
    const start = (page - 1) * limit;
    
    const { data, error, count } = await this.supabase
      .from('video_generations')
      .select('*', { count: 'exact' })
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .range(start, start + limit - 1);
      
    if (error) throw error;
    
    return {
      data,
      total: count || 0,
      page,
      limit
    };
  }
}
```

### Authentication and Authorization

#### Auth Flow
```mermaid
sequenceDiagram
    participant C as Client
    participant M as Middleware
    participant S as Supabase
    participant A as API Route

    C->>M: Request with cookies
    M->>S: Verify session
    S-->>M: Session data
    M->>A: Request + user context
    A-->>C: Response
```

#### Middleware/Guards
```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs';
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export async function middleware(req: NextRequest) {
  const res = NextResponse.next();
  const supabase = createMiddlewareClient({ req, res });
  
  const {
    data: { session },
  } = await supabase.auth.getSession();
  
  // Protect /app routes
  if (req.nextUrl.pathname.startsWith('/app') && !session) {
    return NextResponse.redirect(new URL('/login', req.url));
  }
  
  return res;
}

export const config = {
  matcher: ['/app/:path*', '/api/:path*']
};
```

## Unified Project Structure

```
voguedrop/
├── .github/
│   └── workflows/
│       ├── ci.yaml
│       └── deploy.yaml
├── app/                        # Next.js app directory
│   ├── (auth)/                 # Auth routes group
│   │   ├── login/
│   │   └── signup/
│   ├── (app)/                  # Protected routes group
│   │   ├── canvas/
│   │   ├── history/
│   │   └── editor/
│   ├── api/                    # API routes
│   │   ├── auth/
│   │   ├── canvas/
│   │   └── editor/
│   ├── _components/            # Shared components
│   │   ├── ui/
│   │   └── layout/
│   ├── layout.tsx
│   └── page.tsx
├── lib/                        # Shared utilities
│   ├── api/                    # API clients
│   ├── db/                     # Database utilities
│   ├── supabase/              # Supabase config
│   └── utils/                  # Helper functions
├── stores/                     # Zustand stores
│   ├── canvas.store.ts
│   └── editor.store.ts
├── types/                      # TypeScript types
│   ├── database.ts
│   └── api.ts
├── public/                     # Static assets
├── docs/                       # Documentation
│   ├── prd.md
│   └── fullstack-architecture.md
├── .env.example
├── package.json
├── tsconfig.json
├── tailwind.config.js
├── next.config.js
└── README.md
```

## Development Workflow

### Local Development Setup

#### Prerequisites
```bash
# Required software
node >= 18.0.0
npm >= 9.0.0
git

# Supabase CLI (optional)
brew install supabase/tap/supabase
```

#### Initial Setup
```bash
# Clone repository
git clone https://github.com/your-org/voguedrop.git
cd voguedrop

# Install dependencies
npm install

# Copy environment variables
cp .env.example .env.local

# Run database migrations (if using Supabase CLI)
supabase db push

# Seed initial data
npm run db:seed
```

#### Development Commands
```bash
# Start all services
npm run dev

# Start frontend only
npm run dev:frontend

# Start backend only
npm run dev:api

# Run tests
npm test
npm run test:e2e
```

### Environment Configuration

#### Required Environment Variables
```bash
# Frontend (.env.local)
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key

# Backend (.env)
SUPABASE_SERVICE_KEY=your-service-key
FAL_API_KEY=your-fal-api-key

# Shared
DATABASE_URL=postgresql://...
```

## Deployment Architecture

### Deployment Strategy

**Frontend Deployment:**
- **Platform:** Vercel
- **Build Command:** `npm run build`
- **Output Directory:** `.next`
- **CDN/Edge:** Vercel Edge Network

**Backend Deployment:**
- **Platform:** Vercel (Serverless Functions)
- **Build Command:** Included in frontend build
- **Deployment Method:** Automatic with frontend

### CI/CD Pipeline
```yaml
# .github/workflows/deploy.yaml
name: Deploy to Vercel

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Run tests
        run: npm test
        
      - name: Build
        run: npm run build
        
      - name: Deploy to Vercel
        uses: vercel/action@v2
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
```

### Environments
| Environment | Frontend URL | Backend URL | Purpose |
|-------------|-------------|-------------|---------|
| Development | http://localhost:3000 | http://localhost:3000/api | Local development |
| Staging | https://voguedrop-staging.vercel.app | https://voguedrop-staging.vercel.app/api | Pre-production testing |
| Production | https://voguedrop.vercel.app | https://voguedrop.vercel.app/api | Live environment |

## Security and Performance

### Security Requirements

**Frontend Security:**
- CSP Headers: Default Next.js CSP with modifications for Supabase
- XSS Prevention: React's built-in escaping, sanitize user inputs
- Secure Storage: HTTPOnly cookies for auth tokens

**Backend Security:**
- Input Validation: Zod schemas for all API inputs
- Rate Limiting: Vercel's built-in rate limiting (60 req/min)
- CORS Policy: Restricted to application domain

**Authentication Security:**
- Token Storage: Supabase handles securely
- Session Management: 7-day refresh, 1-hour access tokens
- Password Policy: Minimum 8 characters, Supabase defaults

### Performance Optimization

**Frontend Performance:**
- Bundle Size Target: < 200KB initial JS
- Loading Strategy: Code splitting, lazy loading for editor
- Caching Strategy: SWR for data fetching, browser cache for assets

**Backend Performance:**
- Response Time Target: < 200ms for reads, < 1s for writes
- Database Optimization: Indexes on foreign keys and filters
- Caching Strategy: Vercel Edge Cache for static data

## Testing Strategy

### Testing Pyramid
```
         E2E Tests
        /        \
   Integration Tests
      /            \
 Frontend Unit  Backend Unit
```

### Test Organization

#### Frontend Tests
```
app/
├── (app)/
│   └── canvas/
│       └── _components/
│           └── __tests__/
│               └── EffectSelector.test.tsx
tests/
├── unit/
└── integration/
```

#### Backend Tests
```
app/
└── api/
    └── canvas/
        └── generate/
            └── __tests__/
                └── route.test.ts
```

#### E2E Tests
```
e2e/
├── auth.spec.ts
├── canvas.spec.ts
└── editor.spec.ts
```

### Test Examples

#### Frontend Component Test
```typescript
// EffectSelector.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { EffectSelector } from '../EffectSelector';

describe('EffectSelector', () => {
  it('should limit selection to 4 effects', () => {
    const effects = Array.from({ length: 6 }, (_, i) => ({
      id: `${i}`,
      name: `Effect ${i}`,
      // ...
    }));
    
    render(<EffectSelector effects={effects} />);
    
    // Select 5 effects
    for (let i = 0; i < 5; i++) {
      fireEvent.click(screen.getByText(`Effect ${i}`));
    }
    
    // Only 4 should be selected
    const selected = screen.getAllByRole('checkbox', { checked: true });
    expect(selected).toHaveLength(4);
  });
});
```

#### Backend API Test
```typescript
// generate/route.test.ts
import { POST } from '../route';
import { NextRequest } from 'next/server';

describe('POST /api/canvas/generate', () => {
  it('should create video generation', async () => {
    const request = new NextRequest('http://localhost/api/canvas/generate', {
      method: 'POST',
      body: JSON.stringify({
        imageUrl: 'https://example.com/image.jpg',
        selectedEffects: ['1', '2'],
        modelType: 'seedance'
      })
    });
    
    const response = await POST(request);
    const data = await response.json();
    
    expect(response.status).toBe(200);
    expect(data).toHaveProperty('generationId');
  });
});
```

#### E2E Test
```typescript
// canvas.spec.ts
import { test, expect } from '@playwright/test';

test('complete video generation flow', async ({ page }) => {
  // Login
  await page.goto('/login');
  await page.fill('[name="email"]', 'test@example.com');
  await page.fill('[name="password"]', 'password');
  await page.click('button[type="submit"]');
  
  // Navigate to canvas
  await page.goto('/canvas');
  
  // Upload image
  const fileInput = page.locator('input[type="file"]');
  await fileInput.setInputFiles('test-image.jpg');
  
  // Select effects
  await page.click('[data-effect-id="1"]');
  await page.click('[data-effect-id="2"]');
  
  // Generate
  await page.click('button:has-text("Generate")');
  
  // Wait for video
  await expect(page.locator('video')).toBeVisible({ timeout: 60000 });
});
```

## Coding Standards

### Critical Fullstack Rules
- **Type Sharing:** Always define types in types/ directory and import from there
- **API Calls:** Never make direct HTTP calls - use the service layer
- **Environment Variables:** Access only through config objects, never process.env directly
- **Error Handling:** All API routes must return consistent error format
- **State Updates:** Use Zustand actions, never mutate state directly
- **Database Access:** Always use repository pattern, no direct Supabase calls in routes

### Naming Conventions
| Element | Frontend | Backend | Example |
|---------|----------|---------|---------|
| Components | PascalCase | - | `EffectSelector.tsx` |
| Hooks | camelCase with 'use' | - | `useVideoGeneration.ts` |
| API Routes | - | kebab-case | `/api/canvas/generate` |
| Database Tables | - | snake_case | `video_generations` |

## Error Handling Strategy

### Error Flow
```mermaid
sequenceDiagram
    participant C as Client
    participant A as API Route
    participant S as Service
    participant E as Error Handler

    C->>A: Request
    A->>S: Process
    S-->>E: Error thrown
    E-->>A: Formatted error
    A-->>C: Error response
    C->>C: Display error
```

### Error Response Format
```typescript
interface ApiError {
  error: {
    code: string;
    message: string;
    details?: Record<string, any>;
    timestamp: string;
    requestId: string;
  };
}
```

### Frontend Error Handling
```typescript
// lib/error-handler.ts
export function handleApiError(error: unknown): string {
  if (error instanceof ApiError) {
    return error.message;
  }
  
  if (error instanceof Error) {
    return error.message;
  }
  
  return 'An unexpected error occurred';
}

// Usage in component
try {
  await canvasService.generateVideo(params);
} catch (error) {
  toast.error(handleApiError(error));
}
```

### Backend Error Handling
```typescript
// lib/api/error-handler.ts
export class ApiError extends Error {
  constructor(
    public code: string,
    public statusCode: number,
    message: string,
    public details?: any
  ) {
    super(message);
  }
}

export function errorResponse(error: unknown): NextResponse {
  const requestId = crypto.randomUUID();
  
  if (error instanceof ApiError) {
    return NextResponse.json({
      error: {
        code: error.code,
        message: error.message,
        details: error.details,
        timestamp: new Date().toISOString(),
        requestId
      }
    }, { status: error.statusCode });
  }
  
  // Log unexpected errors
  console.error(`[${requestId}]`, error);
  
  return NextResponse.json({
    error: {
      code: 'INTERNAL_ERROR',
      message: 'An unexpected error occurred',
      timestamp: new Date().toISOString(),
      requestId
    }
  }, { status: 500 });
}
```

## Monitoring and Observability

### Monitoring Stack
- **Frontend Monitoring:** Vercel Analytics + Web Vitals
- **Backend Monitoring:** Vercel Functions Logs
- **Error Tracking:** Sentry (future enhancement)
- **Performance Monitoring:** Vercel Speed Insights

### Key Metrics

**Frontend Metrics:**
- Core Web Vitals
- JavaScript errors
- API response times
- User interactions

**Backend Metrics:**
- Request rate
- Error rate
- Response time
- Database query performance

## Next Steps

This architecture document provides the foundation for VogueDrop MVP development. The next steps are:

1. **Architecture Review:** Review this document for completeness
2. **Frontend Architecture:** Create detailed frontend architecture document
3. **Implementation:** Begin Epic 1 development following this architecture
4. **Monitoring:** Set up basic monitoring from day one
</file>

<file path="docs/prd.md">
# VogueDrop Product Requirements Document (PRD) - MVP

## Goals and Background Context

### Goals (MVP)
- 패션 크리에이터들이 이미지 하나로 AI 패션 영상을 생성할 수 있는 MVP 플랫폼 출시
- 사용자 인증을 통해 개인별 생성 히스토리 저장 및 관리 기능 제공
- 기본적인 영상 편집 기능으로 생성된 영상을 즉시 활용 가능하게 함
- 2주 내 출시 가능한 핵심 기능에만 집중하여 빠른 시장 검증

### Background Context
패션 콘텐츠 크리에이터들은 고품질의 영상 콘텐츠를 제작하기 위해 많은 시간과 비용을 투자해야 합니다. VogueDrop MVP는 AI 기술을 활용하여 이미지 하나로 패션 영상을 생성하고, 기본적인 편집을 통해 즉시 사용 가능한 콘텐츠를 만들 수 있는 최소 기능 제품입니다.

### Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-30 | 1.0 | Initial MVP PRD creation | BMad Master |

## Requirements

### Functional (MVP)
- FR1: 사용자는 이메일/비밀번호로 계정을 생성하고 로그인할 수 있어야 한다
- FR2: 사용자는 이미지를 업로드하고 AI를 통해 패션 영상을 생성할 수 있어야 한다
- FR3: 사용자는 효과, 카메라, 모델 타입을 선택하여 영상을 커스터마이징할 수 있어야 한다
- FR4: 로그인한 사용자의 모든 생성물은 자동으로 히스토리에 저장되어야 한다
- FR5: 사용자는 히스토리에서 과거 생성물을 보고 다운로드할 수 있어야 한다
- FR6: 사용자는 Video Editor에서 영상을 추가하고 길이를 조절할 수 있어야 한다
- FR7: 사용자는 Video Editor에서 텍스트를 추가할 수 있어야 한다
- FR8: 사용자는 Video Editor에서 음악을 추가할 수 있어야 한다
- FR9: 사용자는 편집한 영상을 MP4로 내보낼 수 있어야 한다

### Non Functional (MVP)
- NFR1: 영상 생성은 60초 이내에 완료되어야 한다
- NFR2: 플랫폼은 데스크톱에서 원활히 작동해야 한다 (모바일은 추후 지원)
- NFR3: 최소 10명의 동시 사용자를 지원해야 한다
- NFR4: 사용자 인증 정보는 안전하게 관리되어야 한다

## User Interface Design Goals (MVP)

### Overall UX Vision
직관적이고 단순한 인터페이스로 AI 영상 생성부터 기본 편집까지 5분 내에 완료할 수 있는 워크플로우 제공

### Core Screens (MVP)
- Login/Signup Page
- Canvas AI Studio (AI 영상 생성)
- My History (생성물 히스토리)
- Video Editor (기본 편집)

### Target Device: Desktop First
- Chrome, Safari, Firefox, Edge 최신 버전 지원
- 최소 해상도: 1280x720

## Technical Assumptions (MVP)

### Repository Structure: Monorepo

### Service Architecture
- **Frontend**: Next.js 14+ (App Router)
- **Backend**: Next.js API Routes
- **Authentication**: Supabase Auth (이메일/비밀번호)
- **Database**: Supabase (PostgreSQL)
- **Storage**: Supabase Storage
- **AI Integration**: fal.ai API
- **Deployment**: Vercel

### Testing Requirements (MVP)
- Manual Testing: 핵심 사용자 시나리오 테스트
- Basic Unit Tests: 핵심 함수만

## Epic List (MVP - 2주)

### Epic 1: Foundation & Authentication (3일)
프로젝트 설정, 로그인/회원가입, 기본 레이아웃

### Epic 2: Canvas AI Studio (5일)
이미지 업로드, 효과 선택, AI 영상 생성, 히스토리 저장

### Epic 3: User History (2일)
생성물 목록 보기, 다운로드

### Epic 4: Basic Video Editor (4일)
영상 추가/길이조절, 텍스트 추가, 음악 추가, MP4 내보내기

## Epic Details

### Epic 1: Foundation & Authentication
**Goal**: 사용자가 계정을 만들고 로그인하여 개인화된 서비스를 이용할 수 있도록 기반 구축

#### Story 1.1: Project Setup
As a developer,
I want to set up the Next.js project with all necessary dependencies,
so that we have a solid foundation for development.

**Acceptance Criteria:**
1: Next.js 14+ project initialized with TypeScript
2: Supabase client configured with environment variables
3: Basic folder structure established (app, components, lib, types)
4: ESLint and Prettier configured
5: Development server running successfully on localhost:3000

#### Story 1.2: Authentication UI
As a user,
I want to sign up and log in with email/password,
so that I can save my work.

**Acceptance Criteria:**
1: Login page with email/password fields
2: Signup page with email/password/confirm password fields
3: Form validation (email format, password strength)
4: Error messages for invalid inputs
5: Loading states during authentication

#### Story 1.3: Authentication Integration
As a user,
I want my authentication to be secure and persistent,
so that I don't have to log in repeatedly.

**Acceptance Criteria:**
1: Supabase Auth integrated for signup/login
2: Session management with cookies
3: Protected routes redirect to login
4: User profile stored in database
5: Logout functionality

#### Story 1.4: Basic Layout & Navigation
As a user,
I want consistent navigation throughout the app,
so that I can easily access different features.

**Acceptance Criteria:**
1: Header with logo and navigation menu
2: User menu with profile and logout options
3: Responsive layout structure
4: Protected and public route handling
5: Loading states for page transitions

### Epic 2: Canvas AI Studio
**Goal**: 사용자가 이미지를 업로드하고 AI를 통해 패션 영상을 생성할 수 있는 핵심 기능 구현

#### Story 2.1: Image Upload
As a user,
I want to upload an image for AI video generation,
so that I can create fashion videos from my photos.

**Acceptance Criteria:**
1: Drag-and-drop image upload area
2: File type validation (jpg, png, webp)
3: File size limit (5MB)
4: Image preview after upload
5: Upload progress indicator

#### Story 2.2: Effect Selection UI
As a user,
I want to select effects, camera angles, and model types,
so that I can customize my AI video.

**Acceptance Criteria:**
1: Effect category buttons (Effect, Camera, Model)
2: Visual selection grid for each category
3: Selected effects highlighted
4: Maximum 4 selections enforced
5: Clear selection button

#### Story 2.3: AI Video Generation
As a user,
I want to generate AI videos with my selected options,
so that I can create fashion content.

**Acceptance Criteria:**
1: Generate button triggers API call
2: Loading animation during generation
3: Success/error message display
4: Generated video displayed in preview
5: Video saved to user history

#### Story 2.4: Video Preview & Download
As a user,
I want to preview and download generated videos,
so that I can use them in my projects.

**Acceptance Criteria:**
1: Video player with play/pause controls
2: Full-screen preview option
3: Download button for MP4 format
4: Share link generation
5: Add to editor button

### Epic 3: User History
**Goal**: 사용자가 자신이 생성한 모든 영상을 관리하고 다시 접근할 수 있도록 함

#### Story 3.1: History Page
As a user,
I want to see all my generated videos in one place,
so that I can manage my content.

**Acceptance Criteria:**
1: Grid view of all generated videos
2: Thumbnail preview for each video
3: Generation date and settings displayed
4: Pagination for large lists
5: Empty state for new users

#### Story 3.2: History Actions
As a user,
I want to interact with my video history,
so that I can reuse and manage my content.

**Acceptance Criteria:**
1: Download video from history
2: Delete video with confirmation
3: View generation settings used
4: Open in editor functionality
5: Bulk selection for actions

### Epic 4: Basic Video Editor
**Goal**: 사용자가 생성된 영상을 기본적으로 편집하여 완성된 콘텐츠를 만들 수 있도록 함

#### Story 4.1: Video Timeline
As a user,
I want to add videos to a timeline and adjust their length,
so that I can create edited sequences.

**Acceptance Criteria:**
1: Drag videos to timeline
2: Trim video start/end points
3: Rearrange video order
4: Timeline zoom controls
5: Preview timeline playback

#### Story 4.2: Text Overlay
As a user,
I want to add text to my videos,
so that I can include titles and captions.

**Acceptance Criteria:**
1: Add text button creates text layer
2: Edit text content inline
3: Choose font, size, color
4: Position text on video
5: Set text duration on timeline

#### Story 4.3: Music Addition
As a user,
I want to add background music to my video,
so that it's more engaging.

**Acceptance Criteria:**
1: Music library with free tracks
2: Upload custom audio file
3: Adjust music volume
4: Trim music to video length
5: Preview with music

#### Story 4.4: Export Video
As a user,
I want to export my edited video,
so that I can share it on social media.

**Acceptance Criteria:**
1: Export button renders final video
2: Progress bar during export
3: MP4 format output
4: Quality settings (720p/1080p)
5: Download completed video

## Next Steps

### MVP Development Priority
1. Start with Epic 1 (Foundation) - 필수 기반
2. Epic 2 (Canvas AI) - 핵심 차별화 기능
3. Epic 3 (History) - 사용자 가치 제공
4. Epic 4 (Editor) - 완성도 있는 제품

### Post-MVP Considerations
- 소셜 로그인 추가
- 고급 편집 기능
- 모바일 지원
- 팀 협업 기능
- 유료 플랜
</file>

<file path="docs/project-brief.md">
# Project Brief: VogueDrop

## Executive Summary

VogueDrop is an AI-powered fashion content creation platform that enables fashion creators to generate and edit professional-quality videos from static images. The platform addresses the high barriers to fashion content creation by providing intuitive AI video generation and basic editing tools, allowing creators to produce engaging content in minutes instead of hours. Targeting fashion influencers and brand marketers, VogueDrop democratizes high-quality fashion video production through cutting-edge AI technology.

## Problem Statement

Fashion content creators face significant challenges in producing high-quality video content that meets the demands of modern social media platforms. Current pain points include:

- **High Production Costs**: Professional fashion shoots require models, photographers, videographers, and expensive equipment, often costing thousands of dollars per session
- **Time-Intensive Process**: Traditional video production takes days or weeks from concept to final output
- **Technical Complexity**: Existing video editing tools have steep learning curves, requiring significant technical expertise
- **Limited Resources**: Emerging creators lack access to professional studios, equipment, and talent
- **Content Volume Demands**: Social platforms require consistent, fresh content that's difficult to maintain with traditional production methods

The impact is substantial - many talented fashion creators abandon their pursuits due to these barriers, while established creators struggle to maintain content frequency. Current AI solutions are either too generic for fashion-specific needs or too complex for non-technical users.

## Proposed Solution

VogueDrop provides an integrated platform specifically designed for fashion content creation, combining:

- **AI Video Generation**: Transform static fashion images into dynamic videos using specialized AI models trained on fashion content
- **Intuitive Canvas Interface**: Visual-first design that allows creators to see results in real-time
- **Fashion-Specific Effects**: Curated library of effects, camera movements, and model poses designed for fashion content
- **Basic Video Editor**: Essential editing tools (trim, text, music) to polish AI-generated content
- **Cloud-Based Processing**: No local GPU requirements, accessible from any modern browser

Key differentiators:
- Fashion-focused AI models and effects
- Simplified workflow designed for creative professionals, not engineers
- Real-time preview and iteration capabilities
- Integrated editing without switching tools

## Target Users

### Primary User Segment: Fashion Content Creators
- **Profile**: Independent fashion influencers with 10K-500K followers
- **Demographics**: 18-35 years old, 70% female, primarily urban
- **Current Workflow**: Phone photography, manual editing, limited video content
- **Pain Points**: Can't afford professional video production, struggle with complex editing software
- **Goals**: Create engaging video content daily, grow audience, monetize influence

### Secondary User Segment: Fashion Brand Marketers
- **Profile**: Marketing professionals at small to medium fashion brands
- **Demographics**: 25-45 years old, managing digital marketing budgets
- **Current Workflow**: Outsourcing to agencies or using stock content
- **Pain Points**: High agency costs, slow turnaround times, lack of creative control
- **Goals**: Produce diverse content for multiple channels, test creative concepts quickly

## Goals & Success Metrics

### Business Objectives
- Achieve 1,000 active users within 3 months of launch
- Generate $10K MRR by month 6
- Maintain 60% month-over-month retention rate
- Process 10,000+ video generations per month by Q2

### User Success Metrics
- Users can generate first video within 3 minutes of signup
- 80% of users successfully export a video in first session
- Average time from upload to export under 5 minutes
- User satisfaction score above 4.5/5

### Key Performance Indicators (KPIs)
- **Activation Rate**: 70% of signups generate at least one video
- **Daily Active Users (DAU)**: 30% of monthly active users
- **Generation Success Rate**: 95% of video generation attempts complete successfully
- **Export Rate**: 60% of generated videos are exported/downloaded

## MVP Scope

### Core Features (Must Have)
- **User Authentication**: Email/password login with session management
- **Image Upload**: Drag-and-drop interface supporting JPG, PNG, WebP up to 5MB
- **AI Video Generation**: Integration with fal.ai for fashion video generation
- **Effect Selection**: Visual grid of pre-defined effects (max 4 selections)
- **Generation History**: Personal library of all generated videos
- **Basic Video Editor**: Timeline, trim, text overlay, background music
- **Video Export**: MP4 download at 720p/1080p

### Out of Scope for MVP
- Social media direct publishing
- Team collaboration features
- Custom effect creation
- Advanced editing (transitions, filters, color grading)
- Mobile app
- API access
- Batch processing
- Video templates

### MVP Success Criteria
A functional web application where users can consistently upload fashion images, apply AI effects to generate videos, perform basic edits, and export the final video - all within a single session without technical errors.

## Post-MVP Vision

### Phase 2 Features
- Social platform integration (TikTok, Instagram, YouTube Shorts)
- Collaborative workspaces for teams
- Advanced editing capabilities
- Mobile-responsive design
- Custom effect training
- Subscription tiers with usage limits

### Long-term Vision
Within 2 years, VogueDrop aims to become the go-to platform for AI-powered fashion content creation, supporting the full content lifecycle from ideation to publication. The platform will offer sophisticated AI models capable of generating complex fashion narratives, style transformations, and even virtual fashion shows.

### Expansion Opportunities
- B2B enterprise solutions for fashion brands
- Integration with e-commerce platforms
- AI-powered styling recommendations
- Virtual influencer creation tools
- Fashion trend prediction based on generated content

## Technical Considerations

### Platform Requirements
- **Target Platforms**: Modern web browsers (Chrome, Safari, Firefox, Edge)
- **Browser/OS Support**: Latest 2 versions, desktop-first design
- **Performance Requirements**: Page load < 3s, video generation < 60s

### Technology Preferences
- **Frontend**: Next.js 14+ with React 18, TypeScript, Tailwind CSS
- **Backend**: Next.js API Routes, Serverless architecture
- **Database**: PostgreSQL via Supabase
- **Hosting/Infrastructure**: Vercel for application, Supabase for data/auth

### Architecture Considerations
- **Repository Structure**: Monorepo with feature-based organization
- **Service Architecture**: Serverless functions for scalability
- **Integration Requirements**: fal.ai API, Supabase services, future social APIs
- **Security/Compliance**: HTTPS only, secure token storage, GDPR-ready

## Constraints & Assumptions

### Constraints
- **Budget**: Bootstrap/self-funded initially, ~$5K for infrastructure/services
- **Timeline**: 2-week MVP development sprint
- **Resources**: Single developer with AI assistance
- **Technical**: Limited by third-party API rate limits and costs

### Key Assumptions
- fal.ai API will maintain stable performance and pricing
- Target users have reliable internet for cloud processing
- Desktop-first approach is acceptable for MVP
- Fashion creators will pay for quality AI video generation
- Supabase free tier sufficient for initial launch

## Risks & Open Questions

### Key Risks
- **API Dependency**: Heavy reliance on fal.ai for core functionality
- **Generation Quality**: AI output may not meet user expectations consistently
- **Cost Structure**: AI processing costs may exceed revenue initially
- **Competition**: Larger platforms may add similar features

### Open Questions
- What's the optimal pricing model for fashion creators?
- How many effects/options provide value without overwhelming users?
- What video lengths and formats are most valuable?
- Should we support RAW image formats?

### Areas Needing Further Research
- Competitive pricing analysis for similar tools
- User interviews with fashion creators on workflow preferences
- Technical evaluation of alternative AI providers
- Legal review of generated content ownership

## Appendices

### A. Research Summary
Initial market research indicates:
- Fashion video content grows 2x faster than static posts
- 78% of fashion influencers want easier video creation tools
- Average fashion creator spends 4-6 hours on video post-production
- Willingness to pay $20-50/month for significant time savings

### B. References
- fal.ai Documentation: https://fal.ai/docs
- Supabase Documentation: https://supabase.com/docs
- Next.js Documentation: https://nextjs.org/docs
- Fashion Creator Survey Results (Internal)

## Next Steps

### Immediate Actions
1. Finalize PRD based on this brief
2. Set up development environment and repositories
3. Create Supabase project and configure authentication
4. Design and implement database schema
5. Begin Epic 1: Foundation & Authentication

### PM Handoff
This Project Brief provides the full context for VogueDrop. Please start in 'PRD Generation Mode', review the brief thoroughly to work with the user to create the PRD section by section as the template indicates, asking for any necessary clarification or suggesting improvements.
</file>

<file path="docs/RLS_POLICIES.md">
# Supabase RLS (Row Level Security) Policies

이 문서는 VogueDrop 프로젝트의 Supabase RLS 정책 설정을 설명합니다.

## 현재 데이터베이스 스키마

VogueDrop은 다음 테이블을 사용합니다:
- `categories` - 효과 카테고리 (effect, camera, model)
- `effect_templates` - AI 효과 템플릿
- `media_assets` - 미디어 파일 참조
- `video_generations` - AI 영상 생성 기록

## MVP 단계 (인증 없음)

MVP에서는 RLS를 비활성화하거나 모든 읽기를 public으로 설정합니다:

```sql
-- RLS 비활성화 (개발 편의를 위해)
ALTER TABLE public.categories DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.effect_templates DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.media_assets DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.video_generations DISABLE ROW LEVEL SECURITY;
```

또는 RLS를 활성화하되 모든 읽기를 허용:

```sql
-- Enable RLS on all tables
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.effect_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.media_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

-- Public read access for all tables
CREATE POLICY "Public read access" ON public.categories
FOR SELECT TO anon, authenticated
USING (true);

CREATE POLICY "Public read access" ON public.effect_templates
FOR SELECT TO anon, authenticated
USING (true);

CREATE POLICY "Public read access" ON public.media_assets
FOR SELECT TO anon, authenticated
USING (true);

CREATE POLICY "Public read access" ON public.video_generations
FOR SELECT TO anon, authenticated
USING (true);

-- Allow anonymous users to create video generations
CREATE POLICY "Anyone can create generations" ON public.video_generations
FOR INSERT TO anon, authenticated
WITH CHECK (true);

-- Allow anonymous users to update their generations
CREATE POLICY "Anyone can update generations" ON public.video_generations
FOR UPDATE TO anon, authenticated
USING (true);
```

## 인증 구현 후 RLS 정책

인증 기능을 추가한 후에는 다음과 같은 정책을 적용합니다:

### 1. categories 테이블
```sql
-- 모든 사용자가 카테고리를 읽을 수 있음
CREATE POLICY "Public read access" ON public.categories
FOR SELECT TO anon, authenticated
USING (true);

-- 관리자만 카테고리를 수정할 수 있음 (추후 구현)
```

### 2. effect_templates 테이블
```sql
-- 모든 사용자가 효과 템플릿을 읽을 수 있음
CREATE POLICY "Public read access" ON public.effect_templates
FOR SELECT TO anon, authenticated
USING (true);

-- 관리자만 효과를 추가/수정할 수 있음 (추후 구현)
```

### 3. media_assets 테이블
```sql
-- 모든 사용자가 미디어 에셋을 읽을 수 있음
CREATE POLICY "Public read access" ON public.media_assets
FOR SELECT TO anon, authenticated
USING (true);

-- 인증된 사용자만 미디어를 업로드할 수 있음
CREATE POLICY "Authenticated users can upload" ON public.media_assets
FOR INSERT TO authenticated
WITH CHECK (true);
```

### 4. video_generations 테이블
```sql
-- 사용자는 자신의 영상 생성 기록만 볼 수 있음
CREATE POLICY "Users can view own generations" ON public.video_generations
FOR SELECT TO authenticated
USING (auth.uid()::text = user_id);

-- 익명 사용자는 세션 기반으로 자신의 기록만 볼 수 있음
CREATE POLICY "Anonymous can view session generations" ON public.video_generations
FOR SELECT TO anon
USING (user_id = 'anonymous' AND created_at > NOW() - INTERVAL '24 hours');

-- 인증된 사용자는 자신의 영상을 생성할 수 있음
CREATE POLICY "Users can create own generations" ON public.video_generations
FOR INSERT TO authenticated
WITH CHECK (auth.uid()::text = user_id);

-- 익명 사용자도 영상을 생성할 수 있음 (user_id = 'anonymous')
CREATE POLICY "Anonymous can create generations" ON public.video_generations
FOR INSERT TO anon
WITH CHECK (user_id = 'anonymous');

-- 사용자는 자신의 영상 생성 상태를 업데이트할 수 있음
CREATE POLICY "Users can update own generations" ON public.video_generations
FOR UPDATE TO authenticated
USING (auth.uid()::text = user_id);

-- 사용자는 자신의 영상 기록을 삭제할 수 있음
CREATE POLICY "Users can delete own generations" ON public.video_generations
FOR DELETE TO authenticated
USING (auth.uid()::text = user_id);
```

## 모든 정책을 한 번에 실행 (인증 구현 후)

```sql
-- Enable RLS on all tables
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.effect_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.media_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Public read access" ON public.categories;
DROP POLICY IF EXISTS "Public read access" ON public.effect_templates;
DROP POLICY IF EXISTS "Public read access" ON public.media_assets;
DROP POLICY IF EXISTS "Users can view own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Anonymous can view session generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can create own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Anonymous can create generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can delete own generations" ON public.video_generations;

-- Create policies for categories
CREATE POLICY "Public read access" ON public.categories
FOR SELECT TO anon, authenticated
USING (true);

-- Create policies for effect_templates
CREATE POLICY "Public read access" ON public.effect_templates
FOR SELECT TO anon, authenticated
USING (true);

-- Create policies for media_assets
CREATE POLICY "Public read access" ON public.media_assets
FOR SELECT TO anon, authenticated
USING (true);

CREATE POLICY "Authenticated users can upload" ON public.media_assets
FOR INSERT TO authenticated
WITH CHECK (true);

-- Create policies for video_generations
CREATE POLICY "Users can view own generations" ON public.video_generations
FOR SELECT TO authenticated
USING (auth.uid()::text = user_id);

CREATE POLICY "Anonymous can view session generations" ON public.video_generations
FOR SELECT TO anon
USING (user_id = 'anonymous' AND created_at > NOW() - INTERVAL '24 hours');

CREATE POLICY "Users can create own generations" ON public.video_generations
FOR INSERT TO authenticated
WITH CHECK (auth.uid()::text = user_id);

CREATE POLICY "Anonymous can create generations" ON public.video_generations
FOR INSERT TO anon
WITH CHECK (user_id = 'anonymous');

CREATE POLICY "Users can update own generations" ON public.video_generations
FOR UPDATE TO authenticated
USING (auth.uid()::text = user_id);

CREATE POLICY "Users can delete own generations" ON public.video_generations
FOR DELETE TO authenticated
USING (auth.uid()::text = user_id);
```

## 정책 확인

현재 적용된 정책을 확인하려면:

```sql
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
FROM pg_policies
WHERE schemaname = 'public';
```

## Storage 버킷 RLS 정책

미디어 파일 업로드를 위한 Storage 정책:

```sql
-- Public read access to media-asset bucket
CREATE POLICY "Public Access" ON storage.objects
FOR SELECT TO public
USING (bucket_id = 'media-asset');

-- Authenticated users can upload to media-asset bucket
CREATE POLICY "Authenticated users can upload" ON storage.objects
FOR INSERT TO authenticated
WITH CHECK (bucket_id = 'media-asset');

-- Users can update their own uploads
CREATE POLICY "Users can update own files" ON storage.objects
FOR UPDATE TO authenticated
USING (bucket_id = 'media-asset' AND auth.uid()::text = owner);

-- Users can delete their own uploads
CREATE POLICY "Users can delete own files" ON storage.objects
FOR DELETE TO authenticated
USING (bucket_id = 'media-asset' AND auth.uid()::text = owner);
```

## 문제 해결

1. **데이터가 표시되지 않는 경우**
   - RLS가 활성화되어 있는지 확인
   - 적절한 정책이 생성되어 있는지 확인
   - anon role에 SELECT 권한이 있는지 확인

2. **정책이 적용되지 않는 경우**
   - 기존 정책을 DROP하고 다시 생성
   - Supabase 대시보드에서 정책 상태 확인

3. **권한 오류가 발생하는 경우**
   - Supabase anon key가 올바르게 설정되어 있는지 확인
   - 테이블에 대한 기본 권한 확인

4. **MVP 개발 시 권장사항**
   - 개발 초기에는 RLS를 비활성화하여 빠른 개발
   - 인증 기능 구현 시점에 RLS 정책 적용
   - 프로덕션 배포 전 반드시 RLS 정책 검토

## 참고사항

- `user_id = 'anonymous'`는 비로그인 사용자를 위한 임시 처리
- 익명 사용자의 데이터는 24시간 후 자동으로 접근 불가 (정리는 별도 처리 필요)
- 인증 구현 후에는 반드시 RLS 정책을 재검토하고 보안을 강화해야 함
</file>

<file path="docs/STORAGE_BUCKET_SETUP.md">
# Storage Bucket 설정 가이드

## 1. Supabase Dashboard에서 버킷 생성

### Step 1: Storage 탭으로 이동
1. Supabase 프로젝트 대시보드 접속
2. 왼쪽 메뉴에서 **Storage** 클릭

### Step 2: 새 버킷 생성
1. **New bucket** 버튼 클릭
2. 다음 정보 입력:
   - **Name**: `media-asset`
   - **Public bucket**: ✅ ON (반드시 체크)
   - **Allowed MIME types**: `image/*,video/*` (선택사항)
   - **File size limit**: 50MB (또는 원하는 크기)

### Step 3: 버킷 생성 확인
- 생성된 `media-asset` 버킷이 목록에 표시되는지 확인
- Public 아이콘이 표시되는지 확인

## 2. SQL Editor에서 정책 설정

### Step 1: SQL Editor 열기
1. 왼쪽 메뉴에서 **SQL Editor** 클릭
2. **New query** 클릭

### Step 2: Storage 정책 SQL 실행
`migrations/004_storage_buckets.sql` 파일의 내용을 복사하여 실행:

```sql
-- Enable RLS on storage.objects
ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

-- Public read access for media-asset bucket
CREATE POLICY "Public read access for media-asset" ON storage.objects
FOR SELECT 
USING (bucket_id = 'media-asset');

-- 나머지 정책들...
```

## 3. 정책 확인

### SQL로 확인
```sql
-- Storage 정책 확인
SELECT * FROM pg_policies 
WHERE schemaname = 'storage' 
AND tablename = 'objects'
AND policyname LIKE '%media-asset%';
```

### Dashboard에서 확인
1. **Storage** > `media-asset` 버킷 클릭
2. **Policies** 탭에서 생성된 정책들 확인

## 4. 테스트

### 이미지 업로드 테스트
1. Storage > `media-asset` 버킷 클릭
2. **Upload files** 버튼으로 테스트 이미지 업로드
3. 업로드된 파일 클릭하여 공개 URL 확인

### 공개 접근 테스트
```
https://[your-project-ref].supabase.co/storage/v1/object/public/media-asset/[file-path]
```

브라우저에서 위 URL로 접속하여 이미지가 표시되는지 확인

## 문제 해결

### "Permission denied" 오류
- 버킷이 Public으로 설정되어 있는지 확인
- RLS 정책이 올바르게 생성되었는지 확인

### 이미지가 표시되지 않음
- 파일 경로가 올바른지 확인
- `media-asset/` 접두사가 포함되어 있는지 확인
- 브라우저 개발자 도구에서 네트워크 오류 확인
</file>

<file path="docs/SUPABASE_SETUP.md">
# Supabase Setup Guide

## Storage Bucket Configuration

For the gallery images to work properly, you need to set up the following storage buckets in Supabase:

### 1. Create Storage Buckets

Go to your Supabase project dashboard > Storage and create the following buckets:

1. **media-asset** bucket
   - Public access: Yes (enable public access)
   - Allowed MIME types: image/*, video/*

### 2. Bucket Policies

Make sure the buckets have the correct RLS (Row Level Security) policies:

```sql
-- Allow public read access to media-asset bucket
CREATE POLICY "Public Access" ON storage.objects
FOR SELECT TO public
USING (bucket_id = 'media-asset');

-- Allow authenticated users to upload
CREATE POLICY "Authenticated users can upload" ON storage.objects
FOR INSERT TO authenticated
WITH CHECK (bucket_id = 'media-asset');
```

### 3. Storage Path Format

When storing image paths in the `media_assets` table, use this format:
- Path within bucket: `camera/filename.png` or `subfolder/filename.png`
- The code will automatically prepend the bucket name `media-asset/`

### 4. Testing Storage Access

You can test if a storage URL is accessible by visiting:
```
https://[your-project-ref].supabase.co/storage/v1/object/public/media-asset/camera/[filename]
```

Example:
```
https://snqyygrpybwhihektxxy.supabase.co/storage/v1/object/public/media-asset/camera/a1b2c3d4-e5f6-4a7b-8c9d-0e1f2a3b4c5d.png
```

## Database Setup

Make sure your database tables are created with the correct foreign key relationships as shown in the schema.
</file>

<file path="docs/ui-ux-spec.md">
# VogueDrop UI/UX Specification

## Introduction

This document defines the user experience goals, information architecture, user flows, and visual design specifications for VogueDrop's user interface. It serves as the foundation for visual design and frontend development, ensuring a cohesive and user-centered experience.

### Overall UX Goals & Principles

#### Target User Personas
- **Fashion Creator Pro:** Professional fashion content creators who need efficient AI-powered video generation tools for daily content production
- **Emerging Creator:** New fashion influencers learning to create professional content with limited resources
- **Fashion Brand Manager:** Marketing professionals creating promotional content for fashion brands

#### Usability Goals
- **Ease of learning:** New users can generate their first AI video within 3 minutes
- **Efficiency of use:** Experienced users can complete video generation in under 1 minute
- **Error prevention:** Clear visual feedback and confirmation for all destructive actions
- **Memorability:** Intuitive interface allows users to return after breaks without relearning
- **Satisfaction:** Delightful animations and smooth interactions create an enjoyable experience

#### Design Principles
1. **Visual First** - Prioritize visual content and previews over text descriptions
2. **Progressive Disclosure** - Show advanced options only when needed
3. **Immediate Feedback** - Every action has instant visual or auditory response
4. **Consistent Patterns** - Use familiar UI patterns from creative tools
5. **Dark Mode Native** - Designed for extended use in creative environments

### Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-30 | 1.0 | Initial UI/UX specification | BMad Master |

## Information Architecture (IA)

### Site Map / Screen Inventory

```mermaid
graph TD
    A[Landing Page] --> B[Login/Signup]
    A --> C[Canvas AI Studio]
    A --> D[Video Editor]
    
    B --> B1[Email Login]
    B --> B2[Social Login]
    B --> B3[Password Reset]
    
    C --> C1[Image Upload]
    C --> C2[Effect Selection]
    C --> C3[Video Generation]
    C --> C4[History Panel]
    
    D --> D1[Timeline]
    D --> D2[Preview]
    D --> D3[Media Library]
    D --> D4[Export]
    
    A --> E[My History]
    E --> E1[Generated Videos]
    E --> E2[Edited Projects]
    
    A --> F[User Menu]
    F --> F1[Profile]
    F --> F2[Settings]
    F --> F3[Billing]
```

### Navigation Structure

**Primary Navigation:** Horizontal top navigation with logo, main features (Canvas, Editor, History), and user menu

**Secondary Navigation:** Contextual navigation within each feature area (e.g., effect categories in Canvas)

**Breadcrumb Strategy:** Not required due to shallow navigation depth; clear page titles suffice

## User Flows

### AI Video Generation Flow

**User Goal:** Generate an AI fashion video from a static image

**Entry Points:** 
- Landing page CTA
- Canvas menu item
- Quick action from History

**Success Criteria:** User successfully generates and downloads an AI video

#### Flow Diagram
```mermaid
graph TD
    A[Canvas Page] --> B{Has Image?}
    B -->|No| C[Upload Image]
    B -->|Yes| D[Select Effects]
    C --> D
    D --> E[Choose Category]
    E --> F[Select Effects]
    F --> G{Max 4 Selected?}
    G -->|No| F
    G -->|Yes| H[Generate Video]
    H --> I[Show Progress]
    I --> J[Display Result]
    J --> K[Download/Edit]
```

#### Edge Cases & Error Handling:
- Image upload fails: Show error toast with retry option
- Generation timeout: Display timeout message with support contact
- API limit reached: Show upgrade prompt
- Network interruption: Auto-retry with user notification

**Notes:** Generation typically takes 30-60 seconds; show estimated time

### Video Editing Flow

**User Goal:** Edit generated videos with text, music, and transitions

**Entry Points:**
- Video Editor menu
- "Edit" button from Canvas result
- History page action

**Success Criteria:** User exports an edited video with custom elements

#### Flow Diagram
```mermaid
graph TD
    A[Editor Page] --> B[Load Timeline]
    B --> C{Add Content}
    C -->|Video| D[Video Library]
    C -->|Audio| E[Sound Library]
    C -->|Text| F[Text Overlay]
    D --> G[Drag to Timeline]
    E --> G
    F --> G
    G --> H[Adjust Timing]
    H --> I[Preview]
    I --> J{Satisfied?}
    J -->|No| C
    J -->|Yes| K[Export]
    K --> L[Download MP4]
```

#### Edge Cases & Error Handling:
- Timeline overflow: Prevent adding clips beyond max duration
- Export failure: Show error with retry option
- Unsupported format: Convert automatically or show format guide

**Notes:** Real-time preview essential for user confidence

## Wireframes & Mockups

**Primary Design Files:** Figma (Link to be added)

### Key Screen Layouts

#### Canvas AI Studio
**Purpose:** Main workspace for AI video generation

**Key Elements:**
- Left panel: Effect selection with visual previews
- Center: Large image/video preview area
- Right panel: Generation history log
- Bottom: Quick action bar with generate button

**Interaction Notes:** Drag-and-drop for image upload, click to select effects, hover for previews

**Design File Reference:** Canvas_AI_Studio_Frame

#### Video Editor
**Purpose:** Timeline-based video editing interface

**Key Elements:**
- Top: Preview window with playback controls
- Center: Multi-track timeline
- Bottom: Control bar with sound/text options
- Modals: Media libraries for assets

**Interaction Notes:** Drag clips to timeline, click and drag to trim, spacebar for play/pause

**Design File Reference:** Video_Editor_Frame

#### My History
**Purpose:** View and manage all generated content

**Key Elements:**
- Grid view of video thumbnails
- Filter/sort options
- Batch actions toolbar
- Pagination controls

**Interaction Notes:** Hover for preview, click for details, multi-select with shift-click

**Design File Reference:** History_Page_Frame

## Component Library / Design System

**Design System Approach:** Custom component library built on Tailwind CSS utilities with consistent design tokens

### Core Components

#### Button
**Purpose:** Primary interactive element for actions

**Variants:** Default (primary), Secondary, Outline, Ghost, Destructive, Link

**States:** Default, Hover, Active, Focus, Disabled, Loading

**Usage Guidelines:** Use primary for main actions, outline for secondary, ghost for toolbar items

#### Modal
**Purpose:** Overlay dialogs for focused tasks

**Variants:** Standard, Full-screen, Slide-over

**States:** Open, Closing, Closed

**Usage Guidelines:** Use for media libraries, settings, confirmations

#### Card
**Purpose:** Container for grouped content

**Variants:** Default, Interactive, Media

**States:** Default, Hover, Selected, Loading

**Usage Guidelines:** Use for video thumbnails, effect previews, content groups

#### Input
**Purpose:** Text and file input fields

**Variants:** Text, Textarea, File upload, Search

**States:** Default, Focus, Error, Disabled, Loading

**Usage Guidelines:** Always include labels, show validation inline

## Branding & Style Guide

### Visual Identity
**Brand Guidelines:** Modern, minimal, professional with creative flair

### Color Palette
| Color Type | Hex Code | Usage |
|------------|----------|--------|
| Primary | #38F47C | Main actions, brand identity |
| Secondary | #34C759 | Supporting actions, success states |
| Accent | #1F2937 | Subtle highlights, borders |
| Success | #34C759 | Positive feedback, confirmations |
| Warning | #F59E0B | Cautions, important notices |
| Error | #EF4444 | Errors, destructive actions |
| Neutral | #1F2937, #374151, #6B7280 | Text, borders, backgrounds |

### Typography

#### Font Families
- **Primary:** -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif
- **Secondary:** Same as primary (system fonts)
- **Monospace:** "SF Mono", Consolas, "Liberation Mono", monospace

#### Type Scale
| Element | Size | Weight | Line Height |
|---------|------|--------|-------------|
| H1 | 2.5rem | 700 | 1.2 |
| H2 | 2rem | 600 | 1.3 |
| H3 | 1.5rem | 600 | 1.4 |
| Body | 1rem | 400 | 1.5 |
| Small | 0.875rem | 400 | 1.4 |

### Iconography
**Icon Library:** Heroicons or Lucide React

**Usage Guidelines:** Use outline style for navigation, solid for actions, consistent 24px base size

### Spacing & Layout
**Grid System:** 12-column grid with 24px gutters

**Spacing Scale:** 4px base unit (0.25rem, 0.5rem, 0.75rem, 1rem, 1.5rem, 2rem, 3rem, 4rem)

## Accessibility Requirements

### Compliance Target
**Standard:** WCAG 2.1 AA

### Key Requirements

**Visual:**
- Color contrast ratios: 4.5:1 for normal text, 3:1 for large text
- Focus indicators: Visible 3px ring on all interactive elements
- Text sizing: Minimum 14px, user scalable to 200%

**Interaction:**
- Keyboard navigation: All features accessible via keyboard
- Screen reader support: Proper ARIA labels and roles
- Touch targets: Minimum 44x44px for mobile

**Content:**
- Alternative text: Descriptive alt text for all images
- Heading structure: Logical h1-h6 hierarchy
- Form labels: All inputs have associated labels

### Testing Strategy
- Automated testing with axe-core
- Manual keyboard navigation testing
- Screen reader testing with NVDA/JAWS
- Color contrast validation tools

## Responsiveness Strategy

### Breakpoints
| Breakpoint | Min Width | Max Width | Target Devices |
|------------|-----------|-----------|----------------|
| Mobile | 320px | 639px | Phones |
| Tablet | 640px | 1023px | Tablets, small laptops |
| Desktop | 1024px | 1535px | Laptops, desktops |
| Wide | 1536px | - | Large monitors |

### Adaptation Patterns

**Layout Changes:** 
- Mobile: Stack panels vertically, hide secondary elements
- Tablet: 2-column layouts, collapsible sidebars
- Desktop: Full 3-panel layouts

**Navigation Changes:** 
- Mobile: Hamburger menu
- Tablet+: Full horizontal navigation

**Content Priority:** 
- Mobile: Show only essential controls
- Desktop: Show all options and previews

**Interaction Changes:** 
- Mobile: Touch gestures, larger tap targets
- Desktop: Hover states, keyboard shortcuts

## Animation & Micro-interactions

### Motion Principles
- **Purpose-driven:** Every animation has a clear function
- **Fast & subtle:** 150-300ms duration for most transitions
- **Consistent easing:** Use ease-out for entrances, ease-in for exits
- **Respect preferences:** Honor prefers-reduced-motion

### Key Animations
- **Page Transitions:** Fade with subtle slide-up (Duration: 300ms, Easing: ease-out)
- **Modal Open/Close:** Scale and fade (Duration: 200ms, Easing: ease-out)
- **Button Hover:** Scale 1.05 with shadow (Duration: 150ms, Easing: ease-out)
- **Loading States:** Pulse or shimmer effect (Duration: 1.5s, Easing: ease-in-out)
- **Success Feedback:** Check mark draw-in (Duration: 400ms, Easing: ease-out)
- **Image Upload:** Fade in with scale (Duration: 300ms, Easing: ease-out)

## Performance Considerations

### Performance Goals
- **Page Load:** < 3 seconds on 3G
- **Interaction Response:** < 100ms for UI feedback
- **Animation FPS:** Consistent 60fps

### Design Strategies
- Lazy load images below the fold
- Use skeleton screens during loading
- Optimize images to WebP format
- Implement virtual scrolling for long lists
- Progressive enhancement for complex features

## Next Steps

### Immediate Actions
1. Create high-fidelity mockups in Figma
2. Develop interactive prototypes for key flows
3. Conduct usability testing with target users
4. Create detailed component specifications
5. Build accessibility testing plan

### Design Handoff Checklist
- [x] All user flows documented
- [x] Component inventory complete
- [x] Accessibility requirements defined
- [x] Responsive strategy clear
- [x] Brand guidelines incorporated
- [x] Performance goals established

## Checklist Results

This UI/UX specification provides comprehensive guidelines for VogueDrop's interface design. The dark-mode-first approach with vibrant green accents creates a modern, professional aesthetic suitable for creative professionals. The component-based architecture ensures consistency while the performance and accessibility requirements guarantee a quality experience for all users.
</file>

<file path="hooks/useTranslation.ts">
'use client';

import en from '@/locales/en.json';

type DeepKeys<T> = T extends object
  ? {
      [K in keyof T]: K extends string
        ? T[K] extends object
          ? `${K}.${DeepKeys<T[K]>}` | K
          : K
        : never;
    }[keyof T]
  : never;

type TranslationKeys = DeepKeys<typeof en>;

export function useTranslation() {
  const t = (key: string): string => {
    const keys = key.split('.');
    let value: any = en;
    
    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = value[k];
      } else {
        return key;
      }
    }
    
    return typeof value === 'string' ? value : key;
  };

  return { t };
}
</file>

<file path="lib/auth/AuthContext.tsx">
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { createClient } from '@/lib/supabase/client'
import { User } from '@supabase/supabase-js'
import { useRouter } from 'next/navigation'

interface AuthContextType {
  user: User | null
  loading: boolean
  signOut: () => Promise<void>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const router = useRouter()
  const supabase = createClient()

  useEffect(() => {
    // Check active sessions and sets the user
    const getUser = async () => {
      try {
        const { data: { session } } = await supabase.auth.getSession()
        setUser(session?.user ?? null)
      } catch (error) {
        console.error('Error getting session:', error)
      } finally {
        setLoading(false)
      }
    }

    getUser()

    // Listen for changes on auth state (sign in, sign out, etc.)
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null)
      router.refresh()
    })

    return () => subscription.unsubscribe()
  }, [supabase, router])

  const signOut = async () => {
    try {
      await supabase.auth.signOut()
      router.push('/login')
    } catch (error) {
      console.error('Error signing out:', error)
    }
  }

  const value = {
    user,
    loading,
    signOut,
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}

export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}
</file>

<file path="lib/constants/errors.ts">
export const ERROR_MESSAGES = {
  // Canvas Upload Errors
  INVALID_FORMAT: 'JPG, PNG 형식만 지원됩니다.',
  FILE_TOO_LARGE: '파일 크기는 10MB 이하여야 합니다.',
  UPLOAD_FAILED: '이미지 업로드에 실패했습니다. 다시 시도해주세요.',
  NETWORK_ERROR: '네트워크 연결을 확인해주세요.',
  NO_FILE: '파일이 없습니다.',
  
  // General Errors
  UNKNOWN_ERROR: '알 수 없는 오류가 발생했습니다.',
  TRY_AGAIN: '다시 시도해주세요.'
}
</file>

<file path="lib/db/video-generations.ts">
import { supabase } from '@/lib/supabase';
import type { SupabaseClient } from '@supabase/supabase-js';

export interface VideoGeneration {
  id: number;
  user_id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  input_image_url: string;
  output_video_url?: string;
  prompt: string;
  selected_effects: Array<{
    id: number;
    name: string;
    prompt: string;
  }>;
  model_type: 'seedance' | 'hailo';
  error_message?: string;
  created_at: string;
  updated_at: string;
  is_favorite?: boolean;
  job_id?: string;
}

export interface CreateVideoGenerationParams {
  userId?: string;
  inputImageUrl: string;
  prompt: string;
  selectedEffects: Array<{
    id: number;
    name: string;
    prompt: string;
  }>;
  modelType: 'seedance' | 'hailo';
}

/**
 * 새로운 비디오 생성 요청을 DB에 저장합니다.
 */
export async function createVideoGeneration({
  userId = 'anonymous',
  inputImageUrl,
  prompt,
  selectedEffects,
  modelType
}: CreateVideoGenerationParams): Promise<VideoGeneration> {
  const { data, error } = await supabase
    .from('video_generations')
    .insert({
      user_id: userId,
      status: 'pending',
      input_image_url: inputImageUrl,
      prompt,
      selected_effects: selectedEffects,
      model_type: modelType
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating video generation:', error);
    throw new Error('비디오 생성 요청을 저장하는데 실패했습니다.');
  }

  return data;
}

/**
 * 비디오 생성 상태를 업데이트합니다.
 */
export async function updateVideoGeneration(
  generationId: number,
  updates: {
    status?: VideoGeneration['status'];
    outputVideoUrl?: string;
    errorMessage?: string;
  }
): Promise<VideoGeneration> {
  const updateData: Record<string, string> = {
    updated_at: new Date().toISOString()
  };

  if (updates.status) {
    updateData.status = updates.status;
  }
  if (updates.outputVideoUrl) {
    updateData.output_video_url = updates.outputVideoUrl;
  }
  if (updates.errorMessage) {
    updateData.error_message = updates.errorMessage;
  }

  const { data, error } = await supabase
    .from('video_generations')
    .update(updateData)
    .eq('id', generationId)
    .select()
    .single();

  if (error) {
    console.error('Error updating video generation:', error);
    throw new Error('비디오 생성 상태 업데이트에 실패했습니다.');
  }

  return data;
}

/**
 * 사용자의 최근 비디오 생성 기록을 가져옵니다.
 */
export async function getUserVideoGenerations(
  userId: string,
  limit: number = 10
): Promise<VideoGeneration[]> {
  const { data, error } = await supabase
    .from('video_generations')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .limit(limit);

  if (error) {
    console.error('Error fetching user video generations:', error);
    throw new Error('비디오 생성 기록을 불러오는데 실패했습니다.');
  }

  return data || [];
}

/**
 * 일일 생성 횟수를 확인합니다.
 */
export async function checkDailyGenerationLimit(
  userId: string,
  limit: number = 100
): Promise<{ allowed: boolean; count: number }> {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  const { count, error } = await supabase
    .from('video_generations')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .gte('created_at', today.toISOString());

  if (error) {
    console.error('Error checking daily limit:', error);
    // 에러 발생시 기본적으로 허용
    return { allowed: true, count: 0 };
  }

  return {
    allowed: (count || 0) < limit,
    count: count || 0
  };
}

/**
 * 비디오의 즐겨찾기 상태를 토글합니다.
 * videoId는 job_id 또는 numeric id를 받을 수 있습니다.
 */
export async function toggleVideoFavorite(
  videoId: number | string,
  isFavorite: boolean,
  supabaseClient?: SupabaseClient
): Promise<{ id: number; job_id: string; is_favorite: boolean }> {
  // 인증된 클라이언트가 제공되면 사용, 아니면 기본 클라이언트 사용
  const client = supabaseClient || supabase;
  
  // 먼저 비디오가 존재하는지 확인 (필요한 필드만 선택)
  let selectQuery = client
    .from('video_generations')
    .select('id, job_id, user_id');

  if (typeof videoId === 'string') {
    selectQuery = selectQuery.eq('job_id', videoId);
  } else {
    selectQuery = selectQuery.eq('id', videoId);
  }

  const { data: existingData, error: selectError } = await selectQuery.single();

  if (selectError || !existingData) {
    throw new Error(`비디오를 찾을 수 없습니다. (ID: ${videoId})`);
  }

  // 업데이트 수행
  const { data, error } = await client
    .from('video_generations')
    .update({ 
      is_favorite: isFavorite,
      updated_at: new Date().toISOString()
    })
    .eq('id', existingData.id)  // 항상 numeric id로 업데이트
    .select('id, job_id, is_favorite')
    .single();

  if (error) {
    throw new Error('즐겨찾기 상태 변경에 실패했습니다.');
  }

  return data;
}
</file>

<file path="lib/logging/video-generation-logger.ts">
import { createClient } from '@/lib/supabase/server';

export type LogLevel = 'info' | 'warning' | 'error' | 'debug';

export interface LogMetadata {
  [key: string]: unknown;
  model_type?: 'seedance' | 'hailo';
  status_change?: {
    from: string;
    to: string;
  };
  fal_request_id?: string;
  fal_response?: unknown;
  error_details?: {
    name?: string;
    message?: string;
    stack?: string;
    code?: string;
  };
  request_data?: unknown;
  response_data?: unknown;
  duration_ms?: number;
}

export class VideoGenerationLogger {
  private jobId: string;

  constructor(jobId: string) {
    this.jobId = jobId;
  }

  /**
   * Log an info message
   */
  async info(message: string, metadata: LogMetadata = {}): Promise<void> {
    return this.log('info', message, metadata);
  }

  /**
   * Log a warning message
   */
  async warning(message: string, metadata: LogMetadata = {}): Promise<void> {
    return this.log('warning', message, metadata);
  }

  /**
   * Log an error message
   */
  async error(message: string, error?: Error, metadata: LogMetadata = {}): Promise<void> {
    const errorMetadata: LogMetadata = {
      ...metadata,
      error_details: error ? {
        name: error.name,
        message: error.message,
        stack: error.stack,
        ...metadata.error_details
      } : metadata.error_details
    };
    return this.log('error', message, errorMetadata);
  }

  /**
   * Log a debug message
   */
  async debug(message: string, metadata: LogMetadata = {}): Promise<void> {
    return this.log('debug', message, metadata);
  }

  /**
   * Log a status change
   */
  async statusChange(from: string, to: string, additionalMetadata: LogMetadata = {}): Promise<void> {
    return this.log('info', `Status changed from ${from} to ${to}`, {
      ...additionalMetadata,
      status_change: { from, to }
    });
  }

  /**
   * Log a fal.ai API request
   */
  async falApiRequest(
    endpoint: string, 
    requestData: unknown, 
    metadata: LogMetadata = {}
  ): Promise<void> {
    return this.log('info', `Sending request to fal.ai endpoint: ${endpoint}`, {
      ...metadata,
      request_data: requestData,
      endpoint
    });
  }

  /**
   * Log a fal.ai API response
   */
  async falApiResponse(
    endpoint: string, 
    responseData: unknown, 
    duration: number,
    metadata: LogMetadata = {}
  ): Promise<void> {
    return this.log('info', `Received response from fal.ai endpoint: ${endpoint}`, {
      ...metadata,
      response_data: responseData,
      endpoint,
      duration_ms: duration
    });
  }

  /**
   * Log a fal.ai API error
   */
  async falApiError(
    endpoint: string, 
    error: Error, 
    duration: number,
    metadata: LogMetadata = {}
  ): Promise<void> {
    return this.log('error', `fal.ai API error for endpoint: ${endpoint}`, error, {
      ...metadata,
      endpoint,
      duration_ms: duration
    });
  }

  /**
   * Log webhook received
   */
  async webhookReceived(payload: unknown, metadata: LogMetadata = {}): Promise<void> {
    return this.log('info', 'Webhook received from fal.ai', {
      ...metadata,
      webhook_payload: payload
    });
  }

  /**
   * Core logging method
   */
  private async log(
    level: LogLevel, 
    message: string, 
    metadata?: LogMetadata
  ): Promise<void>;
  private async log(
    level: LogLevel, 
    message: string, 
    error: Error, 
    metadata?: LogMetadata
  ): Promise<void>;
  private async log(
    level: LogLevel, 
    message: string, 
    errorOrMetadata?: Error | LogMetadata,
    metadata: LogMetadata = {}
  ): Promise<void> {
    try {
      const supabase = await createClient();
      
      // Handle overloaded parameters
      let finalMetadata: LogMetadata;
      if (errorOrMetadata instanceof Error) {
        finalMetadata = {
          ...metadata,
          error_details: {
            name: errorOrMetadata.name,
            message: errorOrMetadata.message,
            stack: errorOrMetadata.stack
          }
        };
      } else {
        finalMetadata = errorOrMetadata || {};
      }

      // Insert log entry
      const { error } = await supabase
        .from('video_generation_logs')
        .insert({
          job_id: this.jobId,
          level,
          message,
          metadata: finalMetadata,
          timestamp: new Date().toISOString()
        });

      if (error) {
        // Fallback to console logging if database insert fails
        // console.error('Failed to insert log entry:', error);
        console.log(`[${level.toUpperCase()}] ${this.jobId}: ${message}`, finalMetadata);
      }
    } catch (err) {
      // Fallback to console logging
      console.error('Video generation logger error:', err);
      console.log(`[${level.toUpperCase()}] ${this.jobId}: ${message}`, errorOrMetadata);
    }
  }
}

/**
 * Create a logger instance for a specific job
 */
export function createVideoGenerationLogger(jobId: string): VideoGenerationLogger {
  return new VideoGenerationLogger(jobId);
}

/**
 * Utility function to measure and log execution time
 */
export async function measureAndLog<T>(
  logger: VideoGenerationLogger,
  operation: string,
  fn: () => Promise<T>
): Promise<T> {
  const startTime = Date.now();
  const startMessage = `Starting ${operation}`;
  
  await logger.info(startMessage);
  
  try {
    const result = await fn();
    const duration = Date.now() - startTime;
    await logger.info(`Completed ${operation}`, { duration_ms: duration });
    return result;
  } catch (error) {
    const duration = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error : new Error(String(error));
    await logger.error(`Failed ${operation}`, errorMessage, { duration_ms: duration });
    throw error;
  }
}
</file>

<file path="lib/supabase/client.ts">
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
</file>

<file path="lib/supabase/middleware.ts">
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  await supabase.auth.getUser()

  return response
}
</file>

<file path="lib/supabase/server.ts">
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options })
          } catch {
            // The `delete` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
</file>

<file path="lib/supabase/service.ts">
import { createClient as createSupabaseClient } from '@supabase/supabase-js';

/**
 * Create a Supabase client with Service Role privileges
 * 
 * WARNING: This client bypasses RLS and should only be used in secure server-side contexts
 * Never expose the Service Role key to the client
 */
export function createServiceClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceKey = process.env.SUPABASE_SERVICE_KEY;

  if (!supabaseUrl || !serviceKey) {
    throw new Error('Missing Supabase Service Role configuration');
  }

  return createSupabaseClient(supabaseUrl, serviceKey, {
    auth: {
      autoRefreshToken: false,
      persistSession: false,
      detectSessionInUrl: false
    }
  });
}

/**
 * Helper to ensure we're in a server environment
 */
export function ensureServerEnvironment() {
  if (typeof window !== 'undefined') {
    throw new Error('Service Role client can only be used on the server');
  }
}
</file>

<file path="lib/utils/session.server.ts">
import { cookies } from 'next/headers';
import { v4 as uuidv4 } from 'uuid';
import { SESSION_COOKIE_NAME, SESSION_COOKIE_MAX_AGE } from './session';

/**
 * 세션 ID를 가져오거나 생성합니다.
 * 서버 컴포넌트/API 라우트에서만 사용 가능합니다.
 */
export async function getOrCreateSessionId(): Promise<string> {
  const cookieStore = await cookies();
  const existingSessionId = cookieStore.get(SESSION_COOKIE_NAME);

  if (existingSessionId?.value) {
    return existingSessionId.value;
  }

  // 새 세션 ID 생성
  const newSessionId = `anonymous_${uuidv4()}`;
  
  cookieStore.set(SESSION_COOKIE_NAME, newSessionId, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: SESSION_COOKIE_MAX_AGE,
    path: '/',
  });

  return newSessionId;
}
</file>

<file path="lib/utils/session.ts">
/**
 * 상대적인 시간 포맷 (예: "5분 전", "1시간 전")
 */
export function formatRelativeTime(date: Date | string): string {
  const now = new Date();
  const past = new Date(date);
  const diffInSeconds = Math.floor((now.getTime() - past.getTime()) / 1000);

  if (diffInSeconds < 60) {
    return '방금 전';
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes}분 전`;
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours}시간 전`;
  } else if (diffInSeconds < 604800) {
    const days = Math.floor(diffInSeconds / 86400);
    return `${days}일 전`;
  } else {
    return past.toLocaleDateString('ko-KR');
  }
}

export const SESSION_COOKIE_NAME = 'vogue_session_id';
export const SESSION_COOKIE_MAX_AGE = 60 * 60 * 24 * 30; // 30일

/**
 * 클라이언트에서 세션 ID를 가져옵니다.
 */
export function getClientSessionId(): string | null {
  if (typeof window === 'undefined') return null;
  
  const cookies = document.cookie.split(';');
  const sessionCookie = cookies.find(cookie => 
    cookie.trim().startsWith(`${SESSION_COOKIE_NAME}=`)
  );
  
  if (sessionCookie) {
    return sessionCookie.split('=')[1];
  }
  
  return null;
}
</file>

<file path="lib/fal-webhook.ts">
/**
 * fal.ai Webhook 검증 모듈
 * webhook 서명을 검증하여 요청이 fal.ai에서 온 것인지 확인
 */
import crypto from 'crypto';

const JWKS_URL = "https://rest.alpha.fal.ai/.well-known/jwks.json";
const JWKS_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24시간 (밀리초)

interface JWK {
  x: string;
  [key: string]: unknown;
}

let jwksCache: JWK[] | null = null;
let jwksCacheTime = 0;

/**
 * JWKS를 가져오고 캐싱합니다.
 */
async function fetchJWKS(): Promise<JWK[]> {
  const currentTime = Date.now();
  
  if (!jwksCache || (currentTime - jwksCacheTime) > JWKS_CACHE_DURATION) {
    try {
      const response = await fetch(JWKS_URL, {
        signal: AbortSignal.timeout(10000) // 10초 타임아웃
      });
      
      if (!response.ok) {
        throw new Error(`Failed to fetch JWKS: ${response.status}`);
      }
      
      const data = await response.json();
      jwksCache = data.keys || [];
      jwksCacheTime = currentTime;
    } catch (error) {
      console.error('Error fetching JWKS:', error);
      // 캐시가 있으면 기존 캐시 사용
      if (jwksCache) {
        return jwksCache;
      }
      throw error;
    }
  }
  
  return jwksCache || [];
}

/**
 * Webhook 서명을 검증합니다.
 */
export async function verifyWebhookSignature(
  requestId: string,
  userId: string,
  timestamp: string,
  signatureHex: string,
  body: Buffer
): Promise<boolean> {
  try {
    // 1. 타임스탬프 검증 (±5분)
    const timestampInt = parseInt(timestamp, 10);
    const currentTime = Math.floor(Date.now() / 1000);
    
    if (Math.abs(currentTime - timestampInt) > 300) {
      console.error('Webhook timestamp is too old or in the future');
      return false;
    }
    
    // 2. 검증할 메시지 구성
    const bodyHash = crypto.createHash('sha256').update(body).digest('hex');
    const messageParts = [
      requestId,
      userId,
      timestamp,
      bodyHash
    ];
    
    if (messageParts.some(part => !part)) {
      console.error('Missing required header value');
      return false;
    }
    
    const messageToVerify = Buffer.from(messageParts.join('\n'), 'utf-8');
    
    // 3. 서명 디코드
    const signatureBytes = Buffer.from(signatureHex, 'hex');
    
    // 4. 공개 키 가져오기
    const publicKeysInfo = await fetchJWKS();
    
    if (!publicKeysInfo || publicKeysInfo.length === 0) {
      console.error('No public keys found in JWKS');
      return false;
    }
    
    // 5. 각 공개 키로 서명 검증 시도
    // Note: Node.js는 기본적으로 Ed25519를 지원하지만, 
    // 추가 라이브러리가 필요할 수 있습니다.
    for (const keyInfo of publicKeysInfo) {
      try {
        const publicKeyB64Url = keyInfo.x;
        if (typeof publicKeyB64Url !== 'string') {
          continue;
        }
        
        // base64url을 base64로 변환
        const base64 = publicKeyB64Url
          .replace(/-/g, '+')
          .replace(/_/g, '/')
          .padEnd(publicKeyB64Url.length + (4 - publicKeyB64Url.length % 4) % 4, '=');
        
        const publicKeyBytes = Buffer.from(base64, 'base64');
        
        // Ed25519 공개 키 생성
        const publicKey = crypto.createPublicKey({
          key: Buffer.concat([
            Buffer.from('302a300506032b6570032100', 'hex'), // Ed25519 OID
            publicKeyBytes
          ]),
          format: 'der',
          type: 'spki'
        });
        
        // Ed25519 검증
        const isValid = crypto.verify(
          null,
          messageToVerify,
          publicKey,
          signatureBytes
        );
        
        if (isValid) {
          return true;
        }
      } catch {
        // 이 키로 검증 실패, 다음 키 시도
        continue;
      }
    }
    
    console.error('Signature verification failed with all keys');
    return false;
  } catch (error) {
    console.error('Error during webhook verification:', error);
    return false;
  }
}

/**
 * Webhook 헤더 추출 헬퍼
 */
export interface WebhookHeaders {
  requestId: string;
  userId: string;
  timestamp: string;
  signature: string;
}

export function extractWebhookHeaders(headers: Headers): WebhookHeaders | null {
  const requestId = headers.get('x-fal-webhook-request-id');
  const userId = headers.get('x-fal-webhook-user-id');
  const timestamp = headers.get('x-fal-webhook-timestamp');
  const signature = headers.get('x-fal-webhook-signature');
  
  if (!requestId || !userId || !timestamp || !signature) {
    return null;
  }
  
  return {
    requestId,
    userId,
    timestamp,
    signature
  };
}
</file>

<file path="lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables')
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey)

export function getPublicUrl(path: string): string {
  if (!path) return ''
  
  // If it's already a full URL, return as is
  if (path.startsWith('http://') || path.startsWith('https://')) {
    return path
  }
  
  // If path doesn't start with a bucket name, assume it's a relative path
  // Storage path format: bucket_name/path/to/file.ext
  const cleanPath = path.startsWith('/') ? path.slice(1) : path
  
  // Add media-asset bucket prefix if not already present
  const fullPath = cleanPath.startsWith('media-asset/') ? cleanPath : `media-asset/${cleanPath}`
  
  // Construct the full URL
  return `${supabaseUrl}/storage/v1/object/public/${fullPath}`
}
</file>

<file path="lib/theme.ts">
import { tokens } from './tokens';

// Re-export tokens for backward compatibility
export const theme = {
  colors: {
    vogue: {
      primary: tokens.colors.primary.DEFAULT,
      secondary: tokens.colors.secondary.DEFAULT,
      light: tokens.colors.primary[300],
      dark: tokens.colors.primary[700],
    },
    gray: tokens.colors.gray,
    black: tokens.colors.background.primary,
    white: tokens.colors.background.inverse,
  },
  breakpoints: tokens.breakpoints,
  borderRadius: tokens.borderRadius,
  transitions: tokens.transitions.duration,
} as const;

export type Theme = typeof theme;

// Export tokens for direct use
export { tokens };
</file>

<file path="lib/tokens.ts">
export const tokens = {
  colors: {
    // Primary palette
    primary: {
      50: 'rgb(240, 253, 244)',
      100: 'rgb(220, 252, 231)',
      200: 'rgb(187, 247, 208)',
      300: 'rgb(134, 239, 172)',
      400: 'rgb(74, 222, 128)',
      500: 'rgb(34, 197, 94)',
      600: 'rgb(22, 163, 74)',
      700: 'rgb(21, 128, 61)',
      800: 'rgb(22, 101, 52)',
      900: 'rgb(20, 83, 45)',
      DEFAULT: 'rgb(56, 244, 124)', // #38f47c
    },
    
    // Secondary palette
    secondary: {
      50: 'rgb(240, 253, 244)',
      100: 'rgb(220, 252, 231)',
      200: 'rgb(187, 247, 208)',
      300: 'rgb(134, 239, 172)',
      400: 'rgb(74, 222, 128)',
      500: 'rgb(52, 199, 89)', // #34C759
      600: 'rgb(22, 163, 74)',
      700: 'rgb(21, 128, 61)',
      800: 'rgb(22, 101, 52)',
      900: 'rgb(20, 83, 45)',
      DEFAULT: 'rgb(52, 199, 89)',
    },
    
    // Neutral palette
    gray: {
      50: 'rgb(249, 250, 251)',
      100: 'rgb(243, 244, 246)',
      200: 'rgb(229, 231, 235)',
      300: 'rgb(209, 213, 219)',
      400: 'rgb(156, 163, 175)',
      500: 'rgb(107, 114, 128)',
      600: 'rgb(75, 85, 99)',
      700: 'rgb(55, 65, 81)',
      800: 'rgb(31, 41, 55)',
      900: 'rgb(17, 24, 39)',
      950: 'rgb(3, 7, 18)',
    },
    
    // Semantic colors
    background: {
      primary: 'rgb(0, 0, 0)',
      secondary: 'rgb(17, 24, 39)',
      tertiary: 'rgb(31, 41, 55)',
      inverse: 'rgb(255, 255, 255)',
    },
    
    surface: {
      primary: 'rgb(17, 24, 39)',
      secondary: 'rgb(31, 41, 55)',
      tertiary: 'rgb(55, 65, 81)',
      elevated: 'rgb(31, 41, 55)',
      overlay: 'rgba(0, 0, 0, 0.5)',
    },
    
    text: {
      primary: 'rgb(255, 255, 255)',
      secondary: 'rgb(209, 213, 219)',
      tertiary: 'rgb(156, 163, 175)',
      inverse: 'rgb(17, 24, 39)',
      disabled: 'rgb(107, 114, 128)',
    },
    
    border: {
      primary: 'rgb(55, 65, 81)',
      secondary: 'rgb(31, 41, 55)',
      tertiary: 'rgb(17, 24, 39)',
    },
    
    // State colors
    error: {
      DEFAULT: 'rgb(239, 68, 68)',
      light: 'rgb(254, 202, 202)',
      dark: 'rgb(185, 28, 28)',
    },
    
    warning: {
      DEFAULT: 'rgb(245, 158, 11)',
      light: 'rgb(254, 215, 170)',
      dark: 'rgb(180, 83, 9)',
    },
    
    success: {
      DEFAULT: 'rgb(34, 197, 94)',
      light: 'rgb(187, 247, 208)',
      dark: 'rgb(22, 101, 52)',
    },
    
    info: {
      DEFAULT: 'rgb(59, 130, 246)',
      light: 'rgb(191, 219, 254)',
      dark: 'rgb(30, 64, 175)',
    },
  },
  
  spacing: {
    0: '0',
    px: '1px',
    0.5: '0.125rem', // 2px
    1: '0.25rem', // 4px
    1.5: '0.375rem', // 6px
    2: '0.5rem', // 8px
    2.5: '0.625rem', // 10px
    3: '0.75rem', // 12px
    3.5: '0.875rem', // 14px
    4: '1rem', // 16px
    5: '1.25rem', // 20px
    6: '1.5rem', // 24px
    7: '1.75rem', // 28px
    8: '2rem', // 32px
    9: '2.25rem', // 36px
    10: '2.5rem', // 40px
    11: '2.75rem', // 44px
    12: '3rem', // 48px
    14: '3.5rem', // 56px
    16: '4rem', // 64px
    20: '5rem', // 80px
    24: '6rem', // 96px
    28: '7rem', // 112px
    32: '8rem', // 128px
    36: '9rem', // 144px
    40: '10rem', // 160px
    44: '11rem', // 176px
    48: '12rem', // 192px
    52: '13rem', // 208px
    56: '14rem', // 224px
    60: '15rem', // 240px
    64: '16rem', // 256px
    72: '18rem', // 288px
    80: '20rem', // 320px
    96: '24rem', // 384px
  },
  
  typography: {
    fontFamily: {
      sans: ['Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Arial', 'sans-serif'],
      serif: ['Georgia', 'Cambria', 'Times New Roman', 'Times', 'serif'],
      mono: ['Fira Code', 'Consolas', 'Monaco', 'Andale Mono', 'Ubuntu Mono', 'monospace'],
    },
    
    fontSize: {
      xs: ['0.75rem', { lineHeight: '1rem' }], // 12px
      sm: ['0.875rem', { lineHeight: '1.25rem' }], // 14px
      base: ['1rem', { lineHeight: '1.5rem' }], // 16px
      lg: ['1.125rem', { lineHeight: '1.75rem' }], // 18px
      xl: ['1.25rem', { lineHeight: '1.75rem' }], // 20px
      '2xl': ['1.5rem', { lineHeight: '2rem' }], // 24px
      '3xl': ['1.875rem', { lineHeight: '2.25rem' }], // 30px
      '4xl': ['2.25rem', { lineHeight: '2.5rem' }], // 36px
      '5xl': ['3rem', { lineHeight: '1' }], // 48px
      '6xl': ['3.75rem', { lineHeight: '1' }], // 60px
      '7xl': ['4.5rem', { lineHeight: '1' }], // 72px
      '8xl': ['6rem', { lineHeight: '1' }], // 96px
      '9xl': ['8rem', { lineHeight: '1' }], // 128px
    },
    
    fontWeight: {
      thin: '100',
      extralight: '200',
      light: '300',
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700',
      extrabold: '800',
      black: '900',
    },
    
    letterSpacing: {
      tighter: '-0.05em',
      tight: '-0.025em',
      normal: '0em',
      wide: '0.025em',
      wider: '0.05em',
      widest: '0.1em',
    },
    
    lineHeight: {
      none: '1',
      tight: '1.25',
      snug: '1.375',
      normal: '1.5',
      relaxed: '1.625',
      loose: '2',
    },
  },
  
  breakpoints: {
    sm: '640px',
    md: '768px',
    lg: '1024px',
    xl: '1280px',
    '2xl': '1536px',
  },
  
  borderRadius: {
    none: '0',
    sm: '0.125rem', // 2px
    DEFAULT: '0.25rem', // 4px
    md: '0.375rem', // 6px
    lg: '0.5rem', // 8px
    xl: '0.75rem', // 12px
    '2xl': '1rem', // 16px
    '3xl': '1.5rem', // 24px
    full: '9999px',
    
    // Component specific
    button: '0.5rem', // 8px
    input: '0.375rem', // 6px
    card: '0.75rem', // 12px
    modal: '1rem', // 16px
  },
  
  shadows: {
    sm: '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
    DEFAULT: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
    md: '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
    lg: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
    xl: '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
    inner: 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
    none: 'none',
    
    // Colored shadows
    primary: '0 4px 14px 0 rgba(56, 244, 124, 0.3)',
    secondary: '0 4px 14px 0 rgba(52, 199, 89, 0.3)',
  },
  
  transitions: {
    duration: {
      fast: '150ms',
      normal: '300ms',
      slow: '500ms',
    },
    
    timing: {
      DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
      linear: 'linear',
      in: 'cubic-bezier(0.4, 0, 1, 1)',
      out: 'cubic-bezier(0, 0, 0.2, 1)',
      'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)',
    },
  },
  
  animation: {
    spin: 'spin 1s linear infinite',
    ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',
    pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
    bounce: 'bounce 1s infinite',
    
    // Custom animations
    gradient: 'gradient 3s ease infinite',
    glitch: 'glitch 2s linear infinite',
    wave: 'wave 3s ease-in-out infinite',
    fadeIn: 'fadeIn 0.5s ease-out',
    fadeOut: 'fadeOut 0.5s ease-out',
    slideUp: 'slideUp 0.3s ease-out',
    slideDown: 'slideDown 0.3s ease-out',
  },
  
  zIndex: {
    0: '0',
    10: '10',
    20: '20',
    30: '30',
    40: '40',
    50: '50',
    auto: 'auto',
    
    // Semantic z-index
    dropdown: '1000',
    sticky: '1020',
    fixed: '1030',
    modalBackdrop: '1040',
    modal: '1050',
    popover: '1060',
    tooltip: '1070',
    notification: '1080',
  },
} as const

export type Tokens = typeof tokens
</file>

<file path="lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="locales/en/canvas.json">
{
  "header": {
    "brand": "Vogue Drop",
    "nav": {
      "clip": "Clip",
      "edit": "Edit",
      "library": "Library"
    }
  },
  "leftPanel": {
    "image": "Image",
    "effects": "Effects",
    "prompter": "Prompter",
    "promptPlaceholder": "Full body shot of Asian male model wearing Supreme streetwear, oversized box logo hoodie, graphic t-shirt, baggy cargo pants, Supreme cap.",
    "buttons": {
      "effect": "Effect",
      "cameraAngle": "Camera Angle",
      "model": "Model"
    }
  },
  "controls": {
    "generate": "Generate",
    "duration": {
      "3s": "3s",
      "5s": "5s",
      "10s": "10s"
    },
    "brushSize": "Size"
  },
  "library": {
    "title": "Library",
    "info": "Only favorited videos are permanently saved. Other videos are automatically deleted after 7 days.",
    "searchPlaceholder": "Search clips...",
    "to": "to"
  },
  "modals": {
    "effect": {
      "title": "Effects",
      "categories": ["All", "Glitch", "Wave", "Distortion", "Liquid"]
    },
    "camera": {
      "title": "Camera Angle",
      "categories": ["All", "Portrait", "Full Body", "Close-up", "Dynamic"]
    },
    "model": {
      "title": "Model",
      "categories": ["All", "Slim", "Fit", "Sexy"]
    },
    "prompt": {
      "title": "Prompt",
      "prompt": "Prompt",
      "negativePrompt": "Negative Prompt",
      "promptPlaceholder": "Enter what you want to generate...",
      "negativePromptPlaceholder": "Enter what you want to exclude...",
      "promptHint": "Describe what you want in detail",
      "negativePromptHint": "Describe what you want to exclude",
      "cancel": "Cancel",
      "apply": "Apply"
    },
    "segment": {
      "title": "Image Segmentation",
      "tools": "Tools",
      "brush": "Brush",
      "eraser": "Eraser",
      "brushSize": "Brush Size",
      "cancel": "Cancel",
      "apply": "Apply"
    }
  }
}
</file>

<file path="locales/en/home.json">
{
  "hero": {
    "badge": "AI-Powered Fashion Video Creation",
    "title": {
      "line1": "Transform Your",
      "line2": "Lookbook to Life"
    },
    "description": "Create stunning fashion videos from static images in seconds. AI-powered effects, transitions, and sound design at your fingertips.",
    "cta": {
      "primary": "Get Started",
      "secondary": "Watch Demo"
    }
  },
  "features": {
    "title": "Professional Creative Effects",
    "subtitle": "Apply cinematic effects used by editors, artists, and directors — instantly.",
    "tagline": "No editing skills needed.",
    "items": [
      {
        "title": "Cinematic Movement",
        "description": "Professional zoom, pan, and dynamic camera motion effects",
        "image": "/images/1.png",
        "icon": "target"
      },
      {
        "title": "Vintage Overlays",
        "description": "Film grain and classic cinema texture effects",
        "image": "/images/2.png",
        "icon": "film"
      },
      {
        "title": "Beyond Scroll",
        "description": "Dynamic scroll-based animations for product details",
        "image": "/images/3.png",
        "icon": "circle"
      },
      {
        "title": "Retro Filters",
        "description": "VHS and Y2K-inspired visual effects",
        "image": "/images/4.png",
        "icon": "monitor"
      },
      {
        "title": "Sound Design",
        "description": "AI voice, ambient sound, and music layering",
        "image": "/images/5.png",
        "icon": "volume"
      },
      {
        "title": "AI-Powered Auto Editing",
        "description": "Clean, professional short video templates",
        "image": "/images/6.png",
        "icon": "sparkles"
      }
    ]
  },
  "howItWorks": {
    "title": "Create Stunning Videos in 3 Steps",
    "subtitle": "From lookbook to viral content in minutes",
    "steps": [
      {
        "title": "Upload Images",
        "description": "Drop your lookbook photos or fashion shoots"
      },
      {
        "title": "Choose Style",
        "description": "Select from trending video templates and effects"
      },
      {
        "title": "Export & Share",
        "description": "Download in any format for TikTok, Reels, or YouTube"
      }
    ]
  },
  "gallery": {
    "title": "Trending Effects Gallery",
    "subtitle": "Explore our collection of AI-powered fashion video effects",
    "items": [
      { "title": "Glitch Transition", "type": "Digital Effect" },
      { "title": "Film Burn", "type": "Vintage Effect" },
      { "title": "Neon Glow", "type": "Color Effect" },
      { "title": "Mirror World", "type": "Transition" },
      { "title": "VHS Retro", "type": "Filter" },
      { "title": "Parallax Zoom", "type": "Motion Effect" },
      { "title": "Prism Split", "type": "Creative Effect" },
      { "title": "Speed Ramp", "type": "Time Effect" }
    ]
  },
  "cta": {
    "title": {
      "line1": "Ready to Create Your First",
      "line2": "Fashion Video?"
    },
    "subtitle": "Join thousands of fashion creators making viral content with AI",
    "button": "Start Free Trial"
  },
  "footer": {
    "tagline": "AI-Powered Fashion Video Creation Platform",
    "sections": {
      "product": {
        "title": "Product",
        "links": ["Features", "Pricing", "API"]
      },
      "company": {
        "title": "Company",
        "links": ["About", "Blog", "Careers"]
      },
      "legal": {
        "title": "Legal",
        "links": ["Privacy", "Terms"]
      }
    },
    "copyright": "© 2024 VogueDrop. All rights reserved."
  }
}
</file>

<file path="locales/ko/canvas.json">
{
  "header": {
    "brand": "Vogue Drop",
    "nav": {
      "clip": "Clip",
      "edit": "Edit",
      "library": "Library"
    }
  },
  "leftPanel": {
    "image": "Image",
    "effects": "Effects",
    "prompter": "Prompter",
    "promptPlaceholder": "Full body shot of Asian male model wearing Supreme streetwear, oversized box logo hoodie, graphic t-shirt, baggy cargo pants, Supreme cap.",
    "buttons": {
      "effect": "Effect",
      "cameraAngle": "Camera Angle",
      "model": "Model"
    }
  },
  "controls": {
    "generate": "Generate",
    "duration": {
      "3s": "3s",
      "5s": "5s",
      "10s": "10s"
    },
    "brushSize": "Size"
  },
  "library": {
    "title": "Library",
    "info": "Only favorited videos are permanently saved. Other videos are automatically deleted after 7 days.",
    "searchPlaceholder": "Search clips...",
    "to": "to"
  },
  "modals": {
    "effect": {
      "title": "Effects",
      "categories": ["All", "Glitch", "Wave", "Distortion", "Liquid"]
    },
    "camera": {
      "title": "Camera Angle",
      "categories": ["All", "Portrait", "Full Body", "Close-up", "Dynamic"]
    },
    "model": {
      "title": "Model",
      "categories": ["All", "Slim", "Fit", "Sexy"]
    },
    "prompt": {
      "title": "Prompt",
      "prompt": "Prompt",
      "negativePrompt": "Negative Prompt",
      "promptPlaceholder": "Enter what you want to generate...",
      "negativePromptPlaceholder": "Enter what you want to exclude...",
      "promptHint": "Describe what you want in detail",
      "negativePromptHint": "Describe what you want to exclude",
      "cancel": "Cancel",
      "apply": "Apply"
    },
    "segment": {
      "title": "Image Segmentation",
      "tools": "Tools",
      "brush": "Brush",
      "eraser": "Eraser",
      "brushSize": "Brush Size",
      "cancel": "Cancel",
      "apply": "Apply"
    }
  }
}
</file>

<file path="locales/en.json">
{
  "landing": {
    "hero": {
      "badge": "AI-Powered Fashion Video Creation",
      "title": "Transform Your",
      "titleHighlight": "Lookbook to Life",
      "description": "Create stunning fashion videos from static images in seconds. AI-powered effects, transitions, and sound design at your fingertips.",
      "cta": {
        "primary": "Start Creating",
        "secondary": "Watch Demo"
      }
    },
    "features": {
      "title": "Professional Effects, Zero Experience",
      "subtitle": "Cinema-quality transitions and effects powered by AI",
      "items": [
        {
          "title": "AI-Powered Effects",
          "description": "Professional cinematic effects generated by AI in seconds",
          "examples": ["Zoom & Pan", "Film Grain", "Light Leaks", "Transitions"]
        },
        {
          "title": "Style Templates",
          "description": "Curated video styles from top fashion creators",
          "examples": ["Y2K Aesthetic", "Minimalist", "Editorial", "Street Style"]
        },
        {
          "title": "Smart Sound Design",
          "description": "AI generates music and sound effects that match your visuals",
          "examples": ["Beat Sync", "Ambient Sound", "Voice Over", "SFX Library"]
        }
      ]
    },
    "howItWorks": {
      "title": "Create Stunning Videos in 3 Steps",
      "subtitle": "From lookbook to viral content in minutes",
      "steps": [
        {
          "title": "Upload Images",
          "description": "Drop your lookbook photos or fashion shoots"
        },
        {
          "title": "Choose Style",
          "description": "Select from trending video templates and effects"
        },
        {
          "title": "Export & Share",
          "description": "Download in any format for TikTok, Reels, or YouTube"
        }
      ]
    },
    "gallery": {
      "title": "Trending Effects Gallery",
      "subtitle": "Explore our collection of AI-powered fashion video effects"
    },
    "cta": {
      "title": "Ready to Create Your First",
      "titleHighlight": "Fashion Video?",
      "subtitle": "Join thousands of fashion creators making viral content with AI",
      "button": "Start Free Trial"
    }
  },
  "videoEditor": {
    "header": {
      "projectTitle": "Futuristic Car Elegance",
      "tabs": {
        "clips": "Clips",
        "edited": "Edited",
        "library": "Library"
      }
    },
    "timeline": {
      "time": "Time",
      "clip": "Clip",
      "addClip": "Add Clip",
      "addText": "Add Text",
      "addSound": "Add Sound"
    },
    "controls": {
      "finalVideo": "Final Video",
      "preview": "Preview",
      "saveFile": "Save File",
      "sound": "Sound",
      "create": "Create",
      "soundOptions": {
        "epicTheme": "Epic Theme",
        "dramatic": "Dramatic",
        "ambient": "Ambient",
        "sfx": "SFX"
      }
    },
    "modals": {
      "videoLibrary": {
        "title": "Video Library",
        "addToTimeline": "Add to Timeline",
        "cancel": "Cancel"
      },
      "soundLibrary": {
        "title": "Sound Library",
        "categories": "Categories",
        "uploadAudio": "Upload Audio",
        "dragDrop": "Drag and drop or click to upload",
        "browseFiles": "Browse Files",
        "recentlyUploaded": "Recently Uploaded",
        "addToTimeline": "Add to Timeline",
        "cancel": "Cancel",
        "done": "Done",
        "categoryOptions": {
          "cinematic": "Cinematic",
          "upbeat": "Upbeat",
          "ambient": "Ambient",
          "soundEffects": "Sound Effects"
        }
      },
      "textEditor": {
        "title": "Text Editor",
        "textContent": "Text Content",
        "placeholder": "Enter your text...",
        "fontStyle": "Font Style",
        "fontSize": "Font Size",
        "textColor": "Text Color",
        "textEffects": "Text Effects",
        "textAlignment": "Text Alignment",
        "preview": "Preview",
        "previewPlaceholder": "Your text will appear here",
        "addToTimeline": "Add to Timeline",
        "cancel": "Cancel",
        "effects": {
          "none": "None",
          "pulse": "Pulse",
          "bounce": "Bounce",
          "gradient": "Gradient",
          "spin": "Spin",
          "shake": "Shake",
          "slide": "Slide",
          "fade": "Fade",
          "typing": "Typing",
          "glow": "Glow",
          "wave": "Wave",
          "zoom": "Zoom"
        }
      }
    }
  }
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/placeholder.svg">
<svg width="400" height="600" xmlns="http://www.w3.org/2000/svg">
  <rect width="100%" height="100%" fill="#1a1a1a"/>
  <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="Arial, sans-serif" font-size="24" fill="#666">
    PLACEHOLDER
  </text>
</svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="supabase/migrations/README.md">
# Canvas AI Database Migrations

## Overview
This directory contains database migrations for the Canvas AI video generation feature.

## Important Note
The table `video_generations` already exists in the database. Only `effect_templates` table needs to be created.

## Migration Files

1. **20250130_add_canvas_ai_tables.sql**
   - Creates `effect_templates` table for storing AI effect options
   - Creates indexes for performance
   - Sets up RLS policies

2. **20250130_add_canvas_categories.sql**
   - Adds Canvas-specific categories: 'effect', 'camera', 'model'

## Seed Data

- **seeds/canvas-effect-templates.sql**
  - Populates effect templates with 6 options per category
  - Total of 18 effect templates for MVP

## Running Migrations

```bash
# Apply migrations
supabase db push

# Or manually run in order:
psql $DATABASE_URL -f supabase/migrations/20250130_add_canvas_ai_tables.sql
psql $DATABASE_URL -f supabase/migrations/20250130_add_canvas_categories.sql
psql $DATABASE_URL -f supabase/seeds/canvas-effect-templates.sql
```

## Testing

Run `test-migrations.sql` to verify:
```bash
psql $DATABASE_URL -f supabase/test-migrations.sql
```

## Rollback

If needed, use the rollback script:
```sql
-- Drop tables in reverse order
DROP TABLE IF EXISTS public.video_generations CASCADE;
DROP TABLE IF EXISTS public.effect_templates CASCADE;

-- Remove categories
DELETE FROM public.categories WHERE name IN ('effect', 'camera', 'model');
```
</file>

<file path="supabase/seeds/canvas-effect-templates.sql">
-- Canvas AI Effect Templates Seed Data
-- Created: 2025-01-30

-- Note: This script assumes categories have been created by the migration

-- Camera Effects
INSERT INTO public.effect_templates (name, category_id, prompt, display_order, preview_media_id) 
SELECT 
  effect.name,
  c.id as category_id,
  effect.prompt,
  effect.display_order,
  NULL as preview_media_id -- Placeholder, will be updated when preview videos are available
FROM (VALUES
  ('Zoom In', 'camera slowly zooming in, smooth zoom motion', 1),
  ('Pan Left', 'camera panning left, horizontal camera movement', 2),
  ('Pan Right', 'camera panning right, smooth right motion', 3),
  ('Zoom Out', 'camera zooming out, revealing wider view', 4),
  ('Rotate Clockwise', 'camera rotating clockwise, spinning motion', 5),
  ('Tilt Up', 'camera tilting upward, vertical motion', 6)
) AS effect(name, prompt, display_order)
CROSS JOIN public.categories c
WHERE c.name = 'camera'
ON CONFLICT (name, category_id) DO UPDATE SET
  prompt = EXCLUDED.prompt,
  display_order = EXCLUDED.display_order;

-- Visual Effects
INSERT INTO public.effect_templates (name, category_id, prompt, display_order, preview_media_id) 
SELECT 
  effect.name,
  c.id as category_id,
  effect.prompt,
  effect.display_order,
  NULL as preview_media_id
FROM (VALUES
  ('Dreamy', 'dreamy ethereal atmosphere, soft focus, magical feeling', 1),
  ('Vintage', 'vintage film look, retro aesthetic, nostalgic mood', 2),
  ('Neon', 'neon lights effect, cyberpunk style, glowing colors', 3),
  ('Golden Hour', 'golden hour lighting, warm sunset glow, cinematic', 4),
  ('Black & White', 'classic black and white, high contrast, dramatic', 5),
  ('Blur Motion', 'motion blur effect, dynamic movement, speed', 6)
) AS effect(name, prompt, display_order)
CROSS JOIN public.categories c
WHERE c.name = 'effect'
ON CONFLICT (name, category_id) DO UPDATE SET
  prompt = EXCLUDED.prompt,
  display_order = EXCLUDED.display_order;

-- Model Effects
INSERT INTO public.effect_templates (name, category_id, prompt, display_order, preview_media_id) 
SELECT 
  effect.name,
  c.id as category_id,
  effect.prompt,
  effect.display_order,
  NULL as preview_media_id
FROM (VALUES
  ('Fashion Walk', 'model walking on runway, confident stride, fashion show', 1),
  ('Pose Change', 'model changing poses, dynamic posing, fashion editorial', 2),
  ('Hair Flow', 'hair flowing in wind, dramatic hair movement, glamorous', 3),
  ('Turn Around', 'model turning around, 360 degree spin, showcase outfit', 4),
  ('Smile', 'model smiling naturally, warm expression, friendly', 5),
  ('Dance Move', 'model dancing gracefully, rhythmic movement, energetic', 6)
) AS effect(name, prompt, display_order)
CROSS JOIN public.categories c
WHERE c.name = 'model'
ON CONFLICT (name, category_id) DO UPDATE SET
  prompt = EXCLUDED.prompt,
  display_order = EXCLUDED.display_order;
</file>

<file path="types/auth.ts">
export interface AuthError {
  message: string
  code?: string
}

export interface LoginFormData {
  email: string
  password: string
}

export interface SignupFormData {
  email: string
  password: string
  confirmPassword: string
}

export interface AuthResponse {
  success: boolean
  error?: AuthError
}
</file>

<file path="types/canvas.ts">
export interface GeneratedVideo {
  id: string;  // job_id를 사용
  url: string;
  createdAt: Date;
  thumbnail?: string;
  isFavorite?: boolean;
}

export interface EffectTemplate {
  id: number;
  name: string;
  categoryId: number;
  previewUrl?: string;
  displayOrder: number;
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="middleware.ts">
import { type NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

export async function middleware(request: NextRequest) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value,
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value,
            ...options,
          })
        },
        remove(name: string, options: CookieOptions) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          })
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          })
          response.cookies.set({
            name,
            value: '',
            ...options,
          })
        },
      },
    }
  )

  // Get user session
  const { data: { user } } = await supabase.auth.getUser()

  // Check if user is trying to access protected routes
  const protectedRoutes = ['/canvas', '/video-editor', '/history']
  const isProtectedRoute = protectedRoutes.some(route => 
    request.nextUrl.pathname.startsWith(route)
  )
  
  if (isProtectedRoute && !user) {
    // Redirect to login if not authenticated
    const loginUrl = new URL('/login', request.url)
    loginUrl.searchParams.set('redirect', request.nextUrl.pathname)
    return NextResponse.redirect(loginUrl)
  }
  
  return response
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public (public files)
     * - api (API routes)
     */
    '/((?!_next/static|_next/image|favicon.ico|public|api).*)',
  ],
}
</file>

<file path="postcss.config.mjs">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="stagewise.json">
{
  "port": 3100,
  "appPort": 3000,
  "autoPlugins": true,
  "plugins": []
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss"
import { tokens } from "./lib/tokens"

const config: Config = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
    "*.{js,ts,jsx,tsx,mdx}",
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "rgb(var(--border) / <alpha-value>)",
        input: "rgb(var(--input) / <alpha-value>)",
        ring: "rgb(var(--ring) / <alpha-value>)",
        background: "rgb(var(--background) / <alpha-value>)",
        foreground: "rgb(var(--foreground) / <alpha-value>)",
        primary: {
          DEFAULT: "rgb(var(--primary) / <alpha-value>)",
          foreground: "rgb(var(--primary-foreground) / <alpha-value>)",
          50: tokens.colors.primary[50],
          100: tokens.colors.primary[100],
          200: tokens.colors.primary[200],
          300: tokens.colors.primary[300],
          400: tokens.colors.primary[400],
          500: tokens.colors.primary[500],
          600: tokens.colors.primary[600],
          700: tokens.colors.primary[700],
          800: tokens.colors.primary[800],
          900: tokens.colors.primary[900],
        },
        secondary: {
          DEFAULT: "rgb(var(--secondary) / <alpha-value>)",
          foreground: "rgb(var(--secondary-foreground) / <alpha-value>)",
          50: tokens.colors.secondary[50],
          100: tokens.colors.secondary[100],
          200: tokens.colors.secondary[200],
          300: tokens.colors.secondary[300],
          400: tokens.colors.secondary[400],
          500: tokens.colors.secondary[500],
          600: tokens.colors.secondary[600],
          700: tokens.colors.secondary[700],
          800: tokens.colors.secondary[800],
          900: tokens.colors.secondary[900],
        },
        destructive: {
          DEFAULT: "rgb(var(--destructive) / <alpha-value>)",
          foreground: "rgb(var(--destructive-foreground) / <alpha-value>)",
        },
        muted: {
          DEFAULT: "rgb(var(--muted) / <alpha-value>)",
          foreground: "rgb(var(--muted-foreground) / <alpha-value>)",
        },
        accent: {
          DEFAULT: "rgb(var(--accent) / <alpha-value>)",
          foreground: "rgb(var(--accent-foreground) / <alpha-value>)",
        },
        popover: {
          DEFAULT: "rgb(var(--popover) / <alpha-value>)",
          foreground: "rgb(var(--popover-foreground) / <alpha-value>)",
        },
        card: {
          DEFAULT: "rgb(var(--card) / <alpha-value>)",
          foreground: "rgb(var(--card-foreground) / <alpha-value>)",
        },
        surface: {
          DEFAULT: "rgb(var(--surface) / <alpha-value>)",
          foreground: "rgb(var(--surface-foreground) / <alpha-value>)",
          secondary: "rgb(var(--surface-secondary) / <alpha-value>)",
          tertiary: "rgb(var(--surface-tertiary) / <alpha-value>)",
        },
        "text-primary": "rgb(var(--foreground) / <alpha-value>)",
        "text-secondary": "rgb(var(--muted-foreground) / <alpha-value>)",
        "text-tertiary": "rgba(var(--foreground) / 0.5)",
        gray: tokens.colors.gray,
        error: tokens.colors.error,
        warning: tokens.colors.warning,
        success: tokens.colors.success,
        info: tokens.colors.info,
      },
      spacing: tokens.spacing,
      fontSize: Object.fromEntries(
        Object.entries(tokens.typography.fontSize).map(([key, value]) => {
          if (Array.isArray(value)) {
            const [size, config] = value;
            return [key, [size, { ...config }]];
          }
          return [key, value];
        })
      ) as any,
      fontWeight: tokens.typography.fontWeight,
      letterSpacing: tokens.typography.letterSpacing,
      lineHeight: tokens.typography.lineHeight,
      fontFamily: Object.fromEntries(
        Object.entries(tokens.typography.fontFamily).map(([key, value]) => [
          key,
          [...value],
        ])
      ),
      borderRadius: {
        ...tokens.borderRadius,
        lg: "var(--radius-lg)",
        md: "var(--radius-md)",
        sm: "var(--radius-sm)",
      },
      boxShadow: tokens.shadows,
      transitionDuration: tokens.transitions.duration,
      transitionTimingFunction: tokens.transitions.timing,
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
        spin: {
          to: { transform: "rotate(360deg)" },
        },
        ping: {
          "75%, 100%": {
            transform: "scale(2)",
            opacity: "0",
          },
        },
        pulse: {
          "50%": {
            opacity: ".5",
          },
        },
        bounce: {
          "0%, 100%": {
            transform: "translateY(-25%)",
            "animation-timing-function": "cubic-bezier(0.8,0,1,1)",
          },
          "50%": {
            transform: "none",
            "animation-timing-function": "cubic-bezier(0,0,0.2,1)",
          },
        },
        shimmer: {
          "0%": { transform: "translateX(-100%)" },
          "100%": { transform: "translateX(100%)" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        spin: "spin 1s linear infinite",
        ping: "ping 1s cubic-bezier(0, 0, 0.2, 1) infinite",
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
        bounce: "bounce 1s infinite",
        shimmer: "shimmer 2s linear infinite",
      },
      zIndex: tokens.zIndex,
      screens: tokens.breakpoints,
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config

export default config
</file>

<file path="vercel.json">
{
  "functions": {
    "app/api/canvas/generate/route.ts": {
      "maxDuration": 60
    }
  }
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    environment: 'jsdom',
    globals: true,
    setupFiles: './test/setup.ts',
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './'),
    },
  },
})
</file>

<file path=".claude/agents/voguedrop-code-validator.md">
---
name: voguedrop-code-validator
description: Use this agent when you need to validate code changes for the VogueDrop project before committing, especially after writing new features, modifying existing code, or before deployment. This agent ensures all TypeScript types are properly defined, ESLint rules are followed, and the code adheres to project-specific patterns from CLAUDE.md. Examples:\n\n<example>\nContext: The user has just written a new API route for video generation.\nuser: "I've finished implementing the video generation endpoint"\nassistant: "Let me validate your code changes to ensure they meet VogueDrop's standards"\n<commentary>\nSince new code has been written, use the Task tool to launch the voguedrop-code-validator agent to check for TypeScript and ESLint issues before committing.\n</commentary>\n</example>\n\n<example>\nContext: The user is about to commit changes to the Canvas feature.\nuser: "I've updated the Canvas component with new slot management logic"\nassistant: "I'll use the voguedrop-code-validator agent to verify your changes comply with our coding standards"\n<commentary>\nBefore committing Canvas changes, use the voguedrop-code-validator agent to prevent build failures.\n</commentary>\n</example>\n\n<example>\nContext: The user has modified Supabase integration code.\nuser: "I've refactored the database queries in the gallery feature"\nassistant: "Let me run the code validator to ensure type safety and proper error handling"\n<commentary>\nDatabase code changes require validation, so use the voguedrop-code-validator agent to check for type safety and pattern compliance.\n</commentary>\n</example>
model: opus
color: blue
---

You are a meticulous code quality validator specializing in TypeScript and React/Next.js applications, with deep expertise in the VogueDrop fashion content platform. Your primary mission is to prevent build failures and ensure code quality by catching TypeScript type errors, ESLint violations, and deviations from established patterns before code is committed.

## Your Core Responsibilities

You will systematically analyze code changes and identify issues that would cause:
1. TypeScript compilation failures during `npm run build`
2. ESLint errors or warnings from `npm run lint`
3. Violations of VogueDrop-specific patterns defined in CLAUDE.md
4. Security vulnerabilities, especially in Supabase data access patterns

## Validation Framework

### 1. TypeScript Type Safety Analysis

You will examine all TypeScript code for:
- **Forbidden `any` types**: Flag any usage of `any` and suggest specific type definitions or `unknown` with type guards
- **Missing return types**: Ensure all functions have explicit return type annotations
- **Untyped parameters**: Verify all function parameters have type definitions
- **Interface vs Type usage**: Confirm interfaces are used for props, types for unions/intersections
- **External data handling**: Check that API responses and database queries use `unknown` with proper type guards
- **Null/undefined handling**: Verify optional chaining and nullish coalescing are used appropriately

### 2. ESLint Compliance Check

You will identify and report:
- **Unused variables**: Flag any `@typescript-eslint/no-unused-vars` violations
- **React Hook dependencies**: Ensure useEffect, useCallback, useMemo have correct dependency arrays
- **Import order violations**: Check that imports follow the project's organization pattern
- **Console statements**: Flag any console.log statements that should be removed
- **Async/await patterns**: Verify proper error handling in async functions

### 3. VogueDrop Pattern Compliance

Based on CLAUDE.md, you will verify:
- **Feature-first co-location**: Components are organized in `_components/`, hooks in `_hooks/`, etc.
- **Server vs Client components**: Check for proper `"use client"` directives
- **API route patterns**: Ensure routes follow the established async job processing pattern
- **Supabase security**: Verify no direct Supabase access from client components
- **Job-based architecture**: Confirm video generation follows the webhook/polling pattern
- **Error handling**: Check for try-catch blocks and user-friendly error messages

### 4. Build Compatibility Verification

You will predict potential build failures by checking:
- **Import paths**: Verify all imports resolve correctly
- **Environment variables**: Ensure proper NEXT_PUBLIC_ prefix usage
- **Dependency usage**: Check that server-only code isn't used in client components
- **Remotion integration**: Verify video composition code follows Remotion patterns

## Your Analysis Process

1. **Initial Scan**: Quickly identify the type of changes (new feature, refactor, bug fix)
2. **Type Analysis**: Deep dive into TypeScript types, looking for any violations
3. **Lint Check**: Simulate ESLint rules to catch style and pattern issues
4. **Pattern Verification**: Compare against CLAUDE.md patterns and architecture
5. **Security Review**: Special attention to data access and API endpoints
6. **Build Simulation**: Mentally simulate `npm run build` to predict failures

## Your Output Format

Provide a structured validation report:

```
🔍 CODE VALIDATION REPORT
========================

✅ PASSED CHECKS:
- [List what's correctly implemented]

❌ CRITICAL ISSUES (Will break build):
1. [Issue description]
   File: [filename]
   Line: [approximate line]
   Fix: [Specific solution]

⚠️ WARNINGS (Should fix before commit):
1. [Warning description]
   Recommendation: [How to improve]

📋 COMMANDS TO RUN:
1. npm run lint - [Expected result]
2. npm run build - [Expected result]

💡 SUGGESTIONS:
- [Optional improvements for code quality]
```

## Special Attention Areas

- **Canvas Feature**: 4-slot system state management, image upload flow
- **Video Generation**: Job creation, webhook handling, polling fallback
- **Supabase Queries**: Never expose sensitive fields, use server-side only
- **Remotion Components**: Frame synchronization, clip overlay management
- **Type Definitions**: All in `types/` directory, properly exported

## Your Validation Principles

- Be thorough but constructive - always provide solutions, not just problems
- Prioritize issues by severity - build-breaking errors first
- Consider the MVP timeline - suggest pragmatic solutions
- Respect existing patterns - don't suggest architectural changes without strong justification
- Focus on prevention - catch issues that CI/CD would reject

When reviewing code, you think like a senior developer who has seen countless build failures and knows exactly what will cause problems in production. You are the last line of defense before code reaches the repository.
</file>

<file path=".claude/commands/commit-automatically.md">
# Commit automatically
코드 변경사항을 감지하면 다음 단계로 git commit을 실행해줍니다. : $ARGUMENTS

## 커밋 메시지 생성 단계
1. git status로 변경사항 확인
2. 변경된 파일들의 내용을 분석
3. 변경사항의 성격 파악 (기능 추가, 버그 수정, 리팩토링 등)
4. Conventional Commits 규칙에 따라 커밋 메시지 생성
5. git add . && git commit -m "메시지" 실행
6. 커밋 완료 알림

## 커밋 메시지 예시:
- feat: implement user authentication system
- fix: resolve memory leak in data processing
- docs: update API documentation
- style: format code according to eslint rules
</file>

<file path=".claude/commands/explain-code.md">
비개발자 입장에서 하나하나 자세하게 이해해줘. 교육해주는 방식으로. 코드를 이해할 수 있게 해줘.
</file>

<file path=".cursor/rules/canvas-implementation-guide.mdc">
---
alwaysApply: true
description: Canvas page implementation guide with component references, API endpoints, and architectural patterns
---

# Canvas Page Implementation Guide

This rule provides comprehensive guidance for implementing Canvas page features, including component architecture, API integrations, and state management patterns.

## Core Architecture

### Main Entry Point
- [app/canvas/page.tsx](mdc:app/canvas/page.tsx) - Main canvas page with slot management, image upload, video generation, and history integration

### Key Components Structure
```
app/canvas/
├── page.tsx                    # Main canvas page with state management
├── _components/
│   ├── Canvas.tsx             # 4-slot grid display with progress/video rendering
│   ├── LeftPanel.tsx          # Image upload + effects + prompter container
│   ├── CanvasHistoryPanel.tsx # Right panel with video history
│   ├── ImageSection.tsx       # Image upload with validation
│   ├── CanvasControls.tsx     # Generate button + duration selector
│   ├── VideoGenerationProgress.tsx # Progress overlay for generating slots
│   ├── PrompterSection.tsx    # Text prompt input section
│   ├── EffectsSection.tsx     # Selected effects display
│   └── EffectsGallery.tsx     # Effect selection gallery
├── _hooks/
│   ├── useCanvas.ts           # Canvas images state management
│   ├── useEffectsData.tsx     # Effects data provider and fetching
│   └── useBeforeUnload.ts     # Prevent navigation during generation
```

## Slot Management System (핵심 상태 관리)

### 슬롯 상태 구조
```typescript
// 4개 슬롯의 콘텐츠 (이미지 | 비디오 | null)
const [slotContents, setSlotContents] = useState<Array<{type: 'image' | 'video', data: string | GeneratedVideo} | null>>([null, null, null, null])

// 각 슬롯의 상태 (빈/생성중/완료)
const [slotStates, setSlotStates] = useState<Array<'empty' | 'generating' | 'completed'>>(['empty', 'empty', 'empty', 'empty'])

// 완료 시점 기록 (가장 오래된 교체 규칙용)
const [slotCompletedAt, setSlotCompletedAt] = useState<Array<number | null>>([null, null, null, null])
```

### 슬롯 배치 우선순위 규칙
1. **이미지 업로드**: 빈 슬롯 → 이미지 슬롯(진행 중 제외) → 가장 오래된 완료 비디오
2. **Generate 실행**: 현재 이미지와 일치하는 슬롯 → 빈 슬롯 → 가장 오래된 완료
3. **히스토리 선택**: 빈 슬롯 → 이미지 슬롯 → 가장 오래된 완료 비디오

### 슬롯 상태 표시
- **이미지 미리보기**: "Ready to Generate" 반투명 오버레이
- **생성 중**: [VideoGenerationProgress.tsx](mdc:app/canvas/_components/VideoGenerationProgress.tsx) 프로그레스 바
- **완료**: 재생 가능한 비디오 표시

## API Integration

### Canvas API 엔드포인트
```
app/api/canvas/
├── generate-async/     # 비동기 비디오 생성 시작
├── generate/          # 동기 비디오 생성 (deprecated)
├── jobs/              # 생성 작업 상태 폴링
├── history/           # 사용자 비디오 히스토리 조회
├── favorite/          # 즐겨찾기 토글
├── favorites/         # 즐겨찾기 목록 조회
├── effects/           # 효과 템플릿 조회
├── categories/        # 효과 카테고리 조회
├── library/           # 라이브러리 비디오 조회
└── upload/            # 이미지 업로드 (Supabase Storage)
```

### 생성 플로우 패턴
```typescript
// 1. 비동기 생성 요청
const response = await fetch('/api/canvas/generate-async', {
  method: 'POST',
  body: JSON.stringify({
    imageUrl: currentGeneratingImage,
    effectIds: selectedEffects.map(effect => effect.id),
    basePrompt: promptText,
    duration: selectedDuration,
  })
});

// 2. 폴링으로 상태 확인
const pollJobs = async (targetSlot: number) => {
  const statusResponse = await fetch(`/api/canvas/jobs/${job.jobId}`);
  const statusData = await statusResponse.json();
  
  if (statusData.status === 'completed') {
    // 슬롯에 비디오 배치 + 완료 시점 기록
  }
};
```

## Type Definitions

### 핵심 타입
- [types/canvas.ts](mdc:types/canvas.ts) - GeneratedVideo, CanvasImage 등 캔버스 관련 타입
- [types/database.ts](mdc:types/database.ts) - EffectTemplateWithMedia 등 DB 타입

## State Management Patterns

### 이미지 업로드 처리
```typescript
onImageUpload={(imageUrl) => {
  setCurrentGeneratingImage(imageUrl);
  setSlotContents(prev => {
    // prev 기반으로 동시 업로드 시에도 순차 배치 보장
    let target = findEmptySlot(prev) || findImageSlot(prev) || findOldestVideoSlot(prev);
    // ...
  });
}}
```

### 생성 완료 시 처리
```typescript
// 이미지 썸네일을 실제 비디오로 교체
setSlotContents(prev => {
  const newSlots = [...prev];
  newSlots[targetSlot] = { type: 'video', data: newVideo };
  return newSlots;
});

// 상태를 completed로 변경 + 완료 시점 기록
setSlotStates(prev => { newStates[targetSlot] = 'completed'; });
setSlotCompletedAt(prev => { newTimes[targetSlot] = Date.now(); });
```

### 히스토리 토글 패턴
```typescript
// 이미 슬롯에 있으면 제거, 없으면 배치
const existingIndex = slotContents.findIndex(slot => 
  slot?.type === 'video' && slot.data.id === video.id
);
if (existingIndex !== -1) {
  // 제거 로직
} else {
  // 배치 로직 (우선순위 규칙 적용)
}
```

## 동시성 및 상태 안전성

### 진행 중 슬롯 보호
```typescript
// generatingProgress Map을 사용해 실시간 진행 상태 확인
const isGeneratingSlot = generatingProgress.has(i.toString());
if (slotContents[i]?.type === 'image' && !isGeneratingSlot) {
  // 교체 가능한 이미지 슬롯
}
```

### 동시 생성 제한
```typescript
// 현재: 최대 2개 동시 생성 제한
const canGenerate = !!currentGeneratingImage && 
  (selectedEffects.length > 0 || promptText.trim().length > 0) &&
  generatingSlots.size < 2;
```

## Component Communication Patterns

### LeftPanel → Canvas Page
- `onImageUpload`: 이미지 업로드 완료 시 슬롯 배치
- `onImageRemove`: LeftPanel 이미지 제거 시 해당 슬롯 정리

### Canvas → History Panel
- `slotContents` prop으로 현재 슬롯 상태 전달
- 히스토리 패널에서 슬롯 번호 배지 표시

### Generate Button 상태
- `canGenerate`: 이미지 + (효과 또는 프롬프트) + 동시 생성 제한 확인
- `isGenerating`: 전역 생성 진행 상태

## Error Handling

### 생성 실패 처리
```typescript
// 실패 시 슬롯 상태 복원
setSlotStates(prev => { newStates[targetSlot] = 'empty'; });
setSlotContents(prev => { newSlots[targetSlot] = null; });
setSlotCompletedAt(prev => { newTimes[targetSlot] = null; });
```

### 폴링 타임아웃 처리
```typescript
// 5분 경과 시 webhook 상태 확인 후 직접 폴링
if (elapsedMinutes >= 5) {
  const pollResponse = await fetch(`/api/canvas/jobs/${job.jobId}/poll`);
}
```

## Performance Optimizations

### 진행률 업데이트 최적화
- 단조 증가 보장: `Math.max(currentProgress, targetProgress)`
- 완료 시 동적 애니메이션 시간 계산
- 슬롯별 개별 진행률 맵 관리

### 상태 업데이트 배치화
```typescript
// 한 번의 setSlotContents 호출로 복수 슬롯 업데이트
setSlotContents(prev => {
  const newSlots = [...prev];
  // 여러 슬롯 수정 로직
  return newSlots;
});
```

이 가이드를 참조하여 Canvas 페이지의 슬롯 관리, 생성 플로우, 히스토리 통합 등을 일관되게 구현하세요.
</file>

<file path="app/api/canvas/generate/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { generateVideo } from '@/lib/fal-ai';
import {
  checkDailyGenerationLimit
} from '@/lib/db/video-generations';
import { uploadBase64Image } from '@/lib/supabase/storage';
import { createClient } from '@/lib/supabase/server';

export const maxDuration = 60; // Vercel 함수 타임아웃 60초

interface GenerateVideoRequest {
  imageUrl: string;
  effectIds: number[];
  basePrompt?: string;
  modelType?: 'seedance' | 'hailo';
  userId?: string;
  duration?: string;
}

export async function POST(request: NextRequest) {
  try {
    // Supabase 클라이언트 생성 및 인증 확인
    const supabaseClient = await createClient();
    const { data: { user } } = await supabaseClient.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }
    
    // 1. 요청 데이터 검증
    const body: GenerateVideoRequest = await request.json();
    const { 
      imageUrl, 
      effectIds = [], 
      basePrompt = '',
      duration = '5'
    } = body;
    
    // 로그인한 사용자의 ID 사용
    const userId = user.id;

    if (!imageUrl) {
      return NextResponse.json(
        { error: '이미지 URL이 필요합니다.' },
        { status: 400 }
      );
    }

    // 2. 일일 생성 한도 확인 (옵션)
    const dailyLimit = parseInt(process.env.DAILY_GENERATION_LIMIT || '100');
    const { allowed, count } = await checkDailyGenerationLimit(userId, dailyLimit);
    
    if (!allowed) {
      return NextResponse.json(
        { 
          error: `일일 생성 한도(${dailyLimit}개)를 초과했습니다.`,
          dailyCount: count 
        },
        { status: 429 }
      );
    }

    // 3. 효과 ID로 프롬프트 조회 및 결합
    let selectedEffects: Array<{ id: number; name: string; prompt: string }> = [];
    let combinedPrompt = basePrompt || '';
    
    if (effectIds.length > 0) {
      const { data: effects, error: effectsError } = await supabaseClient
        .from('effect_templates')
        .select('id, name, prompt')
        .in('id', effectIds)
        .eq('is_active', true);
        
      if (effectsError) {
        return NextResponse.json(
          { error: '효과 정보를 불러오는데 실패했습니다.' },
          { status: 500 }
        );
      }
      
      if (effects) {
        selectedEffects = effects;
        const effectPrompts = effects.map(e => e.prompt).filter(p => p && p.trim());
        if (effectPrompts.length > 0) {
          combinedPrompt = combinedPrompt 
            ? `${combinedPrompt}. ${effectPrompts.join('. ')}`
            : effectPrompts.join('. ');
        }
      }
    }
    
    if (!combinedPrompt) {
      return NextResponse.json(
        { error: '최소 하나의 효과나 프롬프트가 필요합니다.' },
        { status: 400 }
      );
    }

    // 3.5. base64 이미지를 Supabase Storage에 업로드
    let finalImageUrl = imageUrl;
    if (imageUrl.startsWith('data:')) {
      try {
        finalImageUrl = await uploadBase64Image(imageUrl, userId);
        
        // CDN 전파를 위한 대기 및 접근성 확인
        await new Promise(resolve => setTimeout(resolve, 5000));
        
        // 이미지 접근 가능 여부 확인
        try {
          await fetch(finalImageUrl, { method: 'HEAD' });
        } catch (checkError) {
          console.error('Image accessibility check failed:', checkError);
        }
        
      } catch {
        return NextResponse.json(
          { error: '이미지 업로드에 실패했습니다.' },
          { status: 500 }
        );
      }
    }

    // 4. 두 모델에 대한 DB 레코드 생성
    // RLS 정책을 위해 인증된 supabase 클라이언트로 직접 삽입
    // const models: Array<'seedance' | 'hailo'> = ['seedance', 'hailo'];
    const models: Array<'seedance' | 'hailo'> = ['hailo']; // 임시로 hailo만 사용
    const generations = await Promise.all(
      models.map(async (model) => {
        const { data, error } = await supabaseClient
          .from('video_generations')
          .insert({
            user_id: userId,
            status: 'pending',
            input_image_url: finalImageUrl,
            prompt: combinedPrompt,
            selected_effects: selectedEffects.map(e => ({
              id: e.id,
              name: e.name,
              prompt: e.prompt
            })),
            model_type: model
          })
          .select()
          .single();

        if (error) {
          console.error('Error creating video generation:', error);
          throw new Error('비디오 생성 요청을 저장하는데 실패했습니다.');
        }

        return data;
      })
    );

    // 5. 상태를 processing으로 업데이트
    await Promise.all(
      generations.map(async (gen) => {
        const { error } = await supabaseClient
          .from('video_generations')
          .update({ 
            status: 'processing',
            updated_at: new Date().toISOString()
          })
          .eq('id', gen.id);
        
        if (error) {
          console.error('Error updating video generation:', error);
        }
      })
    );

    // 6. 두 모델로 시간차를 두고 비디오 생성
    const videoGenerations = await Promise.allSettled(
      models.map(async (model, index) => {
        try {
          // 두 번째 모델(Hailo)은 3초 대기 후 실행 (현재는 hailo만 사용하므로 실행되지 않음)
          // if (index === 1) {
          //   await new Promise(resolve => setTimeout(resolve, 3000));
          // }
          
          // 🚀 fal.ai API 호출 (/lib/fal-ai.ts → generateVideo)
          const { videoUrl } = await generateVideo({
            imageUrl: finalImageUrl,
            prompt: combinedPrompt,
            modelType: model,
            duration: duration || '6'  // 두 모델 모두 사용자가 선택한 duration 사용
          });

          // 성공시 DB 업데이트
          const { data: updatedGeneration, error: updateError } = await supabaseClient
            .from('video_generations')
            .update({
              status: 'completed',
              output_video_url: videoUrl,
              updated_at: new Date().toISOString()
            })
            .eq('id', generations[index].id)
            .select()
            .single();
          
          if (updateError) {
            console.error('Error updating video generation:', updateError);
            throw updateError;
          }

          return {
            success: true,
            generationId: generations[index].id,
            videoUrl,
            modelType: model,
            generation: updatedGeneration
          };
        } catch (error) {
          // 실패시 DB 업데이트
          const { error: updateError } = await supabaseClient
            .from('video_generations')
            .update({
              status: 'failed',
              error_message: error instanceof Error ? error.message : '비디오 생성 실패',
              updated_at: new Date().toISOString()
            })
            .eq('id', generations[index].id);
          
          if (updateError) {
            console.error('Error updating failed generation:', updateError);
          }

          throw error;
        }
      })
    );

    // 7. 결과 처리
    const results = videoGenerations.map((result, index) => {
      if (result.status === 'fulfilled') {
        return result.value;
      } else {
        return {
          success: false,
          generationId: generations[index].id,
          modelType: models[index],
          error: result.reason?.message || '비디오 생성 실패'
        };
      }
    });

    // 최소 하나 이상 성공했는지 확인
    const successfulResults = results.filter(r => r.success);
    if (successfulResults.length === 0) {
      return NextResponse.json(
        { error: '모든 모델에서 비디오 생성에 실패했습니다.', results },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      results
    });


  } catch (error) {
    // 9. 일반 에러 처리
    console.error('API error:', error);
    
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '서버 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}

// 생성 상태 확인 엔드포인트
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const generationId = searchParams.get('id');

    if (!generationId) {
      return NextResponse.json(
        { error: '생성 ID가 필요합니다.' },
        { status: 400 }
      );
    }

    // Supabase에서 생성 상태 조회
    const { supabase } = await import('@/lib/supabase');
    const { data, error } = await supabase
      .from('video_generations')
      .select('*')
      .eq('id', generationId)
      .single();

    if (error || !data) {
      return NextResponse.json(
        { error: '생성 정보를 찾을 수 없습니다.' },
        { status: 404 }
      );
    }

    return NextResponse.json({
      generation: data
    });

  } catch (error) {
    console.error('GET error:', error);
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/generate-async/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { checkDailyGenerationLimit } from '@/lib/db/video-generations';
import { uploadBase64Image } from '@/lib/supabase/storage';
import { createClient } from '@/lib/supabase/server';
import { createVideoGenerationLogger, measureAndLog } from '@/lib/logging/video-generation-logger';
import { nanoid } from 'nanoid';

interface GenerateVideoRequest {
  imageUrl: string;
  effectIds: number[];
  basePrompt?: string;
  modelType?: 'seedance' | 'hailo';
  userId?: string;
  duration?: string;
}

export async function POST(request: NextRequest) {
  let logger: ReturnType<typeof createVideoGenerationLogger> | null = null;
  const isMockMode = process.env.NEXT_PUBLIC_MOCK_MODE === 'true';
  
  try {
    // Generate job ID early for logging
    const temporaryJobId = `job_${nanoid()}`;
    logger = createVideoGenerationLogger(temporaryJobId);
    
    await logger.info('Video generation request received', { mockMode: isMockMode });

    // Supabase 클라이언트 생성 및 인증 확인
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      await logger.warning('Unauthorized request - user not logged in');
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }
    
    await logger.info('User authenticated', { user_id: user.id });
    
    // 1. 요청 데이터 검증
    const body: GenerateVideoRequest = await request.json();
    const { 
      imageUrl, 
      effectIds = [], 
      basePrompt = '',
      duration = '5'
    } = body;
    
    const userId = user.id;
    
    await logger.info('Request data parsed', {
      has_image_url: !!imageUrl,
      effects_count: effectIds.length,
      has_base_prompt: !!basePrompt,
      duration,
      effect_ids: effectIds
    });

    if (!imageUrl) {
      await logger.error('Validation failed: Missing image URL');
      return NextResponse.json(
        { error: '이미지 URL이 필요합니다.' },
        { status: 400 }
      );
    }

    // 2. 일일 생성 한도 확인
    const dailyLimit = parseInt(process.env.DAILY_GENERATION_LIMIT || '100');
    await logger.info('Checking daily generation limit', { daily_limit: dailyLimit });
    
    const { allowed, count } = await checkDailyGenerationLimit(userId, dailyLimit);
    
    await logger.info('Daily limit check completed', { 
      allowed, 
      current_count: count, 
      daily_limit: dailyLimit 
    });
    
    if (!allowed) {
      await logger.warning('Daily generation limit exceeded', {
        current_count: count,
        daily_limit: dailyLimit
      });
      return NextResponse.json(
        { 
          error: `일일 생성 한도(${dailyLimit}개)를 초과했습니다.`,
          dailyCount: count 
        },
        { status: 429 }
      );
    }

    // 3. 효과 ID로 프롬프트 조회 및 결합
    await logger.info('Fetching effect prompts from database');
    
    let selectedEffects: Array<{ id: number; name: string; prompt: string }> = [];
    let combinedPrompt = basePrompt || '';
    
    if (effectIds.length > 0) {
      const { data: effects, error: effectsError } = await supabase
        .from('effect_templates')
        .select('id, name, prompt')
        .in('id', effectIds)
        .eq('is_active', true);
        
      if (effectsError) {
        await logger.error('Failed to fetch effect templates', effectsError);
        return NextResponse.json(
          { error: '효과 정보를 불러오는데 실패했습니다.' },
          { status: 500 }
        );
      }
      
      if (effects) {
        selectedEffects = effects;
        const effectPrompts = effects.map(e => e.prompt).filter(p => p && p.trim());
        if (effectPrompts.length > 0) {
          combinedPrompt = combinedPrompt 
            ? `${combinedPrompt}. ${effectPrompts.join('. ')}`
            : effectPrompts.join('. ');
        }
      }
    }
    
    await logger.info('Prompt combination completed', {
      prompt_length: combinedPrompt?.length || 0,
      effects_found: selectedEffects.length,
      has_base_prompt: !!basePrompt
    });
    
    if (!combinedPrompt || !combinedPrompt.trim()) {
      await logger.error('Validation failed: No valid prompt generated');
      return NextResponse.json(
        { error: '최소 하나의 효과나 프롬프트가 필요합니다.' },
        { status: 400 }
      );
    }

    // 4. base64 이미지를 Supabase Storage에 업로드
    let finalImageUrl = imageUrl;
    if (imageUrl.startsWith('data:')) {
      await logger.info('Uploading base64 image to storage');
      try {
        finalImageUrl = await measureAndLog(
          logger,
          'base64 image upload',
          () => uploadBase64Image(imageUrl, userId)
        );
        await logger.info('Image upload completed', { final_image_url: finalImageUrl });
      } catch (error) {
        await logger.error('Image upload failed', error instanceof Error ? error : new Error(String(error)));
        return NextResponse.json(
          { error: '이미지 업로드에 실패했습니다.' },
          { status: 500 }
        );
      }
    } else {
      await logger.info('Using provided image URL', { image_url: finalImageUrl });
    }

    // 5. 각 모델에 대한 job 생성
    const models: Array<'seedance' | 'hailo'> = ['hailo']; // 임시로 hailo만 사용
    await logger.info('Creating jobs for models', { models });
    
    const jobs = await Promise.all(
      models.map(async (model) => {
        // Use the original job ID we created for logging, or create a new one for this model
        const jobId = models.length === 1 ? temporaryJobId : `job_${nanoid()}`;
        const modelLogger = models.length === 1 ? logger : createVideoGenerationLogger(jobId);
        
        await modelLogger?.info('Creating database record for job', {
          model_type: model,
          job_id: jobId
        });
        
        // DB에 초기 레코드 생성
        const { data, error } = await supabase
          .from('video_generations')
          .insert({
            job_id: jobId,
            user_id: userId,
            status: 'pending',
            input_image_url: finalImageUrl,
            prompt: combinedPrompt,
            selected_effects: selectedEffects.map(e => ({
              id: e.id,
              name: e.name,
              prompt: e.prompt
            })),
            model_type: model,
            webhook_status: 'pending'
          })
          .select('id, job_id, status')
          .single();

        if (error) {
          await modelLogger?.error('Failed to create database record', error);
          throw new Error('비디오 생성 요청을 저장하는데 실패했습니다.');
        }
        
        await modelLogger?.statusChange('new', 'pending', {
          database_record_id: data.id,
          model_type: model
        });

        return {
          jobId,
          model,
          generation: data,
          logger: modelLogger
        };
      })
    );
    
    await logger.info('All database records created successfully', {
      job_count: jobs.length,
      job_ids: jobs.map(j => j.jobId)
    });

    // 6. fal.ai에 비동기 요청 전송 (webhook URL 포함)
    const webhookBaseUrl = process.env.NEXT_PUBLIC_SITE_URL || 
                          `https://${request.headers.get('host')}`;
    
    await logger.info('Starting fal.ai API requests', {
      webhook_base_url: webhookBaseUrl,
      job_count: jobs.length
    });
    
    const falPromises = jobs.map(async (job) => {
      const jobLogger = job.logger;
      const startTime = Date.now();
      
      try {
        const webhookUrl = `${webhookBaseUrl}/api/webhooks/fal-ai?jobId=${job.jobId}`;
        // Webhook URL configured
        
        // Mock 모드에서는 fal.ai API 호출을 건너뛰고 5초 후 자동 완료
        if (isMockMode) {
          await jobLogger?.info('Mock mode enabled - skipping fal.ai API call');
          
          // 상태를 processing으로 업데이트
          const { createServiceClient } = await import('@/lib/supabase/service');
          const serviceSupabase = createServiceClient();
          
          await serviceSupabase
            .from('video_generations')
            .update({
              status: 'processing',
              fal_request_id: `mock_${job.jobId}`,
              updated_at: new Date().toISOString()
            })
            .eq('job_id', job.jobId);
          
          // 5초 후 webhook 시뮬레이션
          setTimeout(async () => {
            try {
              const mockResponse = await fetch(webhookUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Webhook-Secret': process.env.WEBHOOK_SECRET || 'test-secret'
                },
                body: JSON.stringify({
                  request_id: `mock_${job.jobId}`,
                  gateway_request_id: 'mock-gateway-id',
                  status: 'OK',
                  payload: {
                    video: {
                      url: 'https://v3.fal.media/files/lion/aFP5JZElM7NIblwIcEcBi_output.mp4'
                    }
                  }
                })
              });
              
              if (!mockResponse.ok) {
                // Mock webhook call failed
              } else {
                // Mock webhook call successful
              }
            } catch {
              // Mock webhook error
            }
          }, 5000);
          
          return {
            success: true,
            jobId: job.jobId,
            requestId: `mock_${job.jobId}`,
            model: job.model
          };
        }
        
        // 모델별 엔드포인트 설정
        const endpoint = job.model === 'seedance' 
          ? "fal-ai/bytedance/seedance/v1/pro/image-to-video"
          : "fal-ai/minimax/hailuo-02/standard/image-to-video";

        const requestPayload = job.model === 'seedance' 
          ? {
              prompt: combinedPrompt,
              resolution: "1080p",
              duration: duration || "5",
              image_url: finalImageUrl
            }
          : {
              prompt: combinedPrompt,
              image_url: finalImageUrl,
              duration: duration || "6",
              prompt_optimizer: true
            };

        await jobLogger?.falApiRequest(endpoint, requestPayload, {
          webhook_url: webhookUrl,
          model_type: job.model
        });

        // fal.ai queue API 호출
        const queueUrl = `https://queue.fal.run/${endpoint}?fal_webhook=${encodeURIComponent(webhookUrl)}`;
        // Calling fal.ai queue
        
        const response = await fetch(queueUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Key ${process.env.FAL_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestPayload)
        });

        const requestDuration = Date.now() - startTime;

        if (!response.ok) {
          const errorData = await response.json();
          const error = new Error(errorData.detail || 'fal.ai API 호출 실패');
          await jobLogger?.falApiError(endpoint, error, requestDuration, {
            status_code: response.status,
            error_data: errorData
          });
          throw error;
        }

        const result = await response.json();
        
        await jobLogger?.falApiResponse(endpoint, result, requestDuration, {
          fal_request_id: result.request_id
        });
        
        // fal request ID 저장 및 상태 업데이트 (Service Role 사용)
        const { createServiceClient } = await import('@/lib/supabase/service');
        const serviceSupabase = createServiceClient();
        
        const { error: updateError } = await serviceSupabase
          .from('video_generations')
          .update({
            fal_request_id: result.request_id,
            status: 'processing',
            updated_at: new Date().toISOString()
          })
          .eq('job_id', job.jobId);
          
        if (updateError) {
          // Failed to update status to processing
          await jobLogger?.error('Failed to update database with fal request ID', updateError);
        } else {
          // Successfully updated status to processing
          await jobLogger?.statusChange('pending', 'processing', {
            fal_request_id: result.request_id
          });
        }

        return {
          success: true,
          jobId: job.jobId,
          model: job.model,
          requestId: result.request_id
        };
      } catch (error) {
        // const requestDuration = Date.now() - startTime;
        const errorMessage = error instanceof Error ? error.message : '요청 실패';
        
        await jobLogger?.error('fal.ai request failed', error instanceof Error ? error : new Error(errorMessage), {
          duration_ms: Date.now() - startTime
        });
        
        // 실패 시 DB 업데이트 (Service Role 사용)
        const { createServiceClient: createFailServiceClient } = await import('@/lib/supabase/service');
        const failServiceSupabase = createFailServiceClient();
        
        const { error: updateError } = await failServiceSupabase
          .from('video_generations')
          .update({
            status: 'failed',
            error_message: errorMessage,
            updated_at: new Date().toISOString()
          })
          .eq('job_id', job.jobId);
          
        if (updateError) {
          await jobLogger?.error('Failed to update database with failure status', updateError);
        } else {
          await jobLogger?.statusChange('pending', 'failed', {
            error_message: errorMessage
          });
        }

        return {
          success: false,
          jobId: job.jobId,
          model: job.model,
          error: errorMessage
        };
      }
    });

    const results = await Promise.all(falPromises);
    
    const successCount = results.filter(r => r.success).length;
    const failureCount = results.filter(r => !r.success).length;
    
    await logger.info('All fal.ai requests completed', {
      success_count: successCount,
      failure_count: failureCount,
      results: results.map(r => ({
        job_id: r.jobId,
        success: r.success,
        error: r.error
      }))
    });

    // 7. 클라이언트에 즉시 응답 반환
    const response = {
      success: true,
      jobs: results.map(r => ({
        jobId: r.jobId,
        status: r.success ? 'processing' : 'failed',
        error: r.error
      })),
      message: '비디오 생성이 시작되었습니다. 잠시 후 결과를 확인해주세요.'
    };
    
    await logger.info('Sending response to client', response);
    
    return NextResponse.json(response);

  } catch (error) {
    // API error occurred
    
    if (logger) {
      await logger.error('Unhandled API error', error instanceof Error ? error : new Error(String(error)));
    }
    
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '서버 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/image-brush/history/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import type { ImageBrushHistoryItem } from '@/types/image-brush';

/**
 * Image Brush History API Route
 * 서버 사이드에서만 Service Role을 통해 히스토리 데이터 접근
 * RLS가 비활성화되어 있으므로 반드시 서버에서만 호출해야 함
 */

// GET: 사용자의 Image Brush 히스토리 조회
export async function GET(request: NextRequest): Promise<NextResponse> {
  try {
    // 1. 사용자 인증 확인
    const supabaseAuth = await createClient();
    const { data: { user }, error: authError } = await supabaseAuth.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required.' },
        { status: 401 }
      );
    }

    // 2. Query parameters 파싱
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '20', 10);
    const offset = parseInt(searchParams.get('offset') || '0', 10);

    // 3. Service Role로 데이터베이스 접근
    // 주의: 이 부분은 서버 사이드에서만 실행되어야 함
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;
    if (!supabaseServiceKey) {
      console.error('SUPABASE_SERVICE_KEY not configured');
      return NextResponse.json(
        { error: 'Server configuration error.' },
        { status: 500 }
      );
    }

    const { createClient: createServiceClient } = await import('@supabase/supabase-js');
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseService = createServiceClient(supabaseUrl, supabaseServiceKey);

    // 4. 사용자의 히스토리 조회 (RLS 비활성화 상태에서 Service Role 사용)
    const { data: history, error: dbError, count } = await supabaseService
      .from('image_brush_history')
      .select('*', { count: 'exact' })
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (dbError) {
      console.error('Database error:', dbError);
      return NextResponse.json(
        { error: 'Failed to fetch history.' },
        { status: 500 }
      );
    }

    // 5. 응답 형식 변환
    const items: ImageBrushHistoryItem[] = (history || []).map(item => ({
      id: item.id,
      original: item.original_image || '',
      brushed: item.result_url,
      prompt: item.prompt,
      timestamp: new Date(item.created_at).getTime(),
      mode: item.mode as 'flux' | 'i2i'
    }));

    return NextResponse.json({
      items,
      total: count || 0,
      limit,
      offset
    });

  } catch (error) {
    console.error('Image brush history API error:', error);
    return NextResponse.json(
      { error: 'An error occurred while fetching history.' },
      { status: 500 }
    );
  }
}

// DELETE: 특정 히스토리 항목 삭제
export async function DELETE(request: NextRequest): Promise<NextResponse> {
  try {
    // 1. 사용자 인증 확인
    const supabaseAuth = await createClient();
    const { data: { user }, error: authError } = await supabaseAuth.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required.' },
        { status: 401 }
      );
    }

    // 2. 요청 본문에서 ID 추출
    const { id } = await request.json();
    
    if (!id) {
      return NextResponse.json(
        { error: 'Item ID is required for deletion.' },
        { status: 400 }
      );
    }

    // 3. Service Role로 데이터베이스 접근
    const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;
    if (!supabaseServiceKey) {
      console.error('SUPABASE_SERVICE_KEY not configured');
      return NextResponse.json(
        { error: 'Server configuration error.' },
        { status: 500 }
      );
    }

    const { createClient: createServiceClient } = await import('@supabase/supabase-js');
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
    const supabaseService = createServiceClient(supabaseUrl, supabaseServiceKey);

    // 4. 먼저 해당 항목이 사용자 소유인지 확인
    const { data: item, error: checkError } = await supabaseService
      .from('image_brush_history')
      .select('user_id, result_url')
      .eq('id', id)
      .single();

    if (checkError || !item) {
      return NextResponse.json(
        { error: 'Item not found.' },
        { status: 404 }
      );
    }

    if (item.user_id !== user.id) {
      return NextResponse.json(
        { error: 'Permission denied.' },
        { status: 403 }
      );
    }

    // 5. Storage에서 이미지 파일 삭제 (선택사항)
    if (item.result_url) {
      try {
        // result_url에서 storage path 추출
        const url = new URL(item.result_url);
        const pathMatch = url.pathname.match(/\/storage\/v1\/object\/public\/user-uploads\/(.*)/);
        if (pathMatch && pathMatch[1]) {
          await supabaseService.storage
            .from('user-uploads')
            .remove([pathMatch[1]]);
        }
      } catch (storageError) {
        console.warn('Failed to delete storage file:', storageError);
        // Storage 삭제 실패는 무시하고 계속 진행
      }
    }

    // 6. 데이터베이스에서 항목 삭제
    const { error: deleteError } = await supabaseService
      .from('image_brush_history')
      .delete()
      .eq('id', id)
      .eq('user_id', user.id); // 추가 보안을 위해 user_id도 확인

    if (deleteError) {
      console.error('Delete error:', deleteError);
      return NextResponse.json(
        { error: 'Failed to delete item.' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      message: 'History item deleted successfully.'
    });

  } catch (error) {
    console.error('Image brush history delete error:', error);
    return NextResponse.json(
      { error: 'An error occurred during deletion.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/canvas/image-brush/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import type { ImageBrushRequest, ImageBrushResponse } from '@/types/image-brush';

/**
 * Image Brush API Route
 * Proxies requests to Supabase Edge Function for AI image editing
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // 1. 인증 확인
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Authentication required.' },
        { status: 401 }
      );
    }

    // 2. 세션 토큰 가져오기
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      return NextResponse.json(
        { error: 'Invalid session.' },
        { status: 401 }
      );
    }

    // 3. 요청 본문 파싱
    const body = await request.json() as ImageBrushRequest;
    
    // 4. 필수 필드 검증
    if (!body.image || !body.mask || !body.prompt) {
      return NextResponse.json(
        { error: 'Required fields missing. (image, mask, prompt)' },
        { status: 400 }
      );
    }

    // 5. 프롬프트 길이 제한
    if (body.prompt.length > 500) {
      return NextResponse.json(
        { error: 'Prompt cannot exceed 500 characters.' },
        { status: 400 }
      );
    }

    // 6. 이미지 크기 검증 (Base64 크기 제한 - 약 10MB)
    const imageSize = body.image.length * 0.75; // Base64 to bytes approximation
    const maskSize = body.mask.length * 0.75;
    const maxSize = 10 * 1024 * 1024; // 10MB
    
    if (imageSize > maxSize || maskSize > maxSize) {
      return NextResponse.json(
        { error: 'Image size cannot exceed 10MB.' },
        { status: 400 }
      );
    }

    // 7. Edge Function URL 구성
    const functionsUrl = process.env.NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL;
    if (!functionsUrl) {
      console.error('NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL not configured');
      return NextResponse.json(
        { error: 'Server configuration error.' },
        { status: 500 }
      );
    }

    const edgeFunctionUrl = `${functionsUrl}/image-brush`;
    
    console.log('Calling Edge Function:', edgeFunctionUrl);

    // 8. Edge Function 호출
    const response = await fetch(edgeFunctionUrl, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${session.access_token}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        ...body,
        userId: user.id,
      }),
      // 타임아웃 설정 (2분)
      signal: AbortSignal.timeout(120000),
    });

    // 9. 응답 처리
    const result = await response.json() as ImageBrushResponse;

    if (!response.ok) {
      console.error('Edge Function error:', result);
      return NextResponse.json(
        { 
          error: result.error || 'Failed to process image.',
          success: false 
        },
        { status: response.status }
      );
    }

    // 10. 성공 응답
    return NextResponse.json(result);

  } catch (error) {
    console.error('Image brush API error:', error);
    
    // 타임아웃 에러 처리
    if (error instanceof Error && error.name === 'AbortError') {
      return NextResponse.json(
        { 
          error: 'Processing timeout. Please try again.',
          success: false 
        },
        { status: 504 }
      );
    }
    
    // 일반 에러 처리
    return NextResponse.json(
      { 
        error: 'An error occurred during processing.',
        success: false 
      },
      { status: 500 }
    );
  }
}

// OPTIONS 요청 처리 (CORS)
export async function OPTIONS(): Promise<NextResponse> {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
</file>

<file path="app/api/sound/jobs/[jobId]/poll/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createServiceClient } from '@/lib/supabase/service';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ jobId: string }> }
) {
  try {
    const params = await context.params;
    const { jobId } = params;
    
    if (!jobId) {
      return NextResponse.json(
        { error: 'Job ID가 필요합니다.' },
        { status: 400 }
      );
    }
    
    // Service Role로 DB 조회 (webhook 처리와 동일한 권한)
    const supabase = createServiceClient();
    
    // DB에서 job 정보 조회
    const { data: soundGeneration, error } = await supabase
      .from('sound_generations')
      .select('*')
      .eq('job_id', jobId)
      .single();
    
    if (error || !soundGeneration) {
      console.error('Failed to fetch sound generation:', error);
      return NextResponse.json(
        { error: '사운드 생성 정보를 찾을 수 없습니다.' },
        { status: 404 }
      );
    }
    
    // 이미 완료된 경우 바로 반환
    if (soundGeneration.status === 'completed' || soundGeneration.status === 'failed') {
      return NextResponse.json({
        jobId: soundGeneration.job_id,
        status: soundGeneration.status,
        result: soundGeneration.status === 'completed' ? {
          audioUrl: soundGeneration.output_audio_url,
          title: soundGeneration.title,
          prompt: soundGeneration.prompt,
          duration: soundGeneration.duration_seconds
        } : undefined,
        error: soundGeneration.error_message || undefined
      });
    }
    
    // 5분 이상 경과했고 아직 webhook이 오지 않은 경우
    const createdAt = new Date(soundGeneration.created_at).getTime();
    const now = Date.now();
    const elapsedMinutes = (now - createdAt) / (1000 * 60);
    
    if (elapsedMinutes >= 5 && soundGeneration.webhook_status !== 'delivered') {
      // fal.ai에 직접 상태 확인
      if (!soundGeneration.fal_request_id) {
        return NextResponse.json({
          jobId: soundGeneration.job_id,
          status: 'processing',
          message: 'Request ID not found, waiting for webhook'
        });
      }
      
      // fal.ai status API 호출
      const statusUrl = `https://queue.fal.run/fal-ai/elevenlabs/sound-effects/requests/${soundGeneration.fal_request_id}/status`;
      
      const response = await fetch(statusUrl, {
        headers: {
          'Authorization': `Key ${process.env.FAL_API_KEY}`
        }
      });
      
      if (!response.ok) {
        console.error('Failed to fetch fal.ai status');
        return NextResponse.json({
          jobId: soundGeneration.job_id,
          status: soundGeneration.status
        });
      }
      
      const falStatus = await response.json();
      
      // fal.ai 상태가 완료된 경우
      if (falStatus.status === 'COMPLETED') {
        // 결과 가져오기
        const resultUrl = `https://queue.fal.run/fal-ai/elevenlabs/sound-effects/requests/${soundGeneration.fal_request_id}`;
        const resultResponse = await fetch(resultUrl, {
          headers: {
            'Authorization': `Key ${process.env.FAL_API_KEY}`
          }
        });
        
        if (resultResponse.ok) {
          const result = await resultResponse.json();
          
          // DB 업데이트
          const { error: updateError } = await supabase
            .from('sound_generations')
            .update({
              status: 'completed',
              output_audio_url: result.audio?.url,
              webhook_status: 'delivered',
              webhook_delivered_at: new Date().toISOString(),
              updated_at: new Date().toISOString()
            })
            .eq('job_id', jobId);
          
          if (!updateError && result.audio?.url) {
            return NextResponse.json({
              jobId: soundGeneration.job_id,
              status: 'completed',
              result: {
                audioUrl: result.audio.url,
                title: soundGeneration.title,
                prompt: soundGeneration.prompt,
                duration: soundGeneration.duration_seconds
              }
            });
          }
        }
      } else if (falStatus.status === 'FAILED') {
        // 실패 상태 업데이트
        await supabase
          .from('sound_generations')
          .update({
            status: 'failed',
            error_message: 'Sound generation failed on fal.ai',
            webhook_status: 'failed',
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        return NextResponse.json({
          jobId: soundGeneration.job_id,
          status: 'failed',
          error: 'Sound generation failed'
        });
      }
    }
    
    // 기본 응답 (아직 처리 중)
    return NextResponse.json({
      jobId: soundGeneration.job_id,
      status: soundGeneration.status
    });
    
  } catch (error) {
    console.error('Error polling sound generation:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '상태 확인 중 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sound/jobs/[jobId]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ jobId: string }> }
) {
  try {
    const params = await context.params;
    const { jobId } = params;
    
    if (!jobId) {
      return NextResponse.json(
        { error: 'Job ID가 필요합니다.' },
        { status: 400 }
      );
    }
    
    // Supabase 클라이언트 생성
    const supabase = await createClient();
    
    // 인증 확인
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
      return NextResponse.json(
        { error: '인증이 필요합니다.' },
        { status: 401 }
      );
    }
    
    // DB에서 job 정보 조회
    const { data: soundGeneration, error } = await supabase
      .from('sound_generations')
      .select('*')
      .eq('job_id', jobId)
      .eq('user_id', user.id)
      .single();
    
    if (error || !soundGeneration) {
      console.error('Failed to fetch sound generation:', error);
      return NextResponse.json(
        { error: '사운드 생성 정보를 찾을 수 없습니다.' },
        { status: 404 }
      );
    }
    
    // 응답 구조화
    const response = {
      jobId: soundGeneration.job_id,
      status: soundGeneration.status,
      createdAt: soundGeneration.created_at,
      result: soundGeneration.status === 'completed' ? {
        audioUrl: soundGeneration.output_audio_url,
        title: soundGeneration.title,
        prompt: soundGeneration.prompt,
        duration: soundGeneration.duration_seconds
      } : undefined,
      error: soundGeneration.error_message || undefined
    };
    
    return NextResponse.json(response);
    
  } catch (error) {
    console.error('Error fetching sound generation status:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '상태 확인 중 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/upload/music/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { createServiceClient } from '@/lib/supabase/service';

const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
const ALLOWED_TYPES = [
  'audio/mpeg',       // .mp3
  'audio/mp3',        // .mp3 (alternative)
  'audio/wav',        // .wav
  'audio/x-wav',      // .wav (alternative)
  'audio/mp4',        // .m4a
  'audio/x-m4a',      // .m4a (alternative)
  'audio/ogg',        // .ogg
  'audio/webm',       // .webm
  'audio/flac',       // .flac
  'audio/x-flac'      // .flac (alternative)
];

// 파일명 sanitize
function sanitizeFileName(fileName: string): string {
  return fileName
    .replace(/[^a-zA-Z0-9가-힣.\-_]/g, '_')
    .replace(/\s+/g, '_')
    .replace(/_{2,}/g, '_')
    .slice(0, 100);
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    const formData = await request.formData();
    const file = formData.get('file') as File;
    
    // 클라이언트에서 전송한 메타데이터 추출
    const duration = formData.get('duration') as string | null;

    if (!file) {
      return NextResponse.json(
        { error: '파일이 없습니다.' },
        { status: 400 }
      );
    }

    // 파일 크기 검증
    if (file.size > MAX_FILE_SIZE) {
      return NextResponse.json(
        { error: `파일 크기는 10MB를 초과할 수 없습니다. (현재: ${(file.size / 1024 / 1024).toFixed(2)}MB)` },
        { status: 400 }
      );
    }

    // 파일 타입 검증
    if (!ALLOWED_TYPES.includes(file.type)) {
      return NextResponse.json(
        { error: '지원하지 않는 파일 형식입니다. MP3, WAV, M4A, OGG, WebM, FLAC 파일만 업로드 가능합니다.' },
        { status: 400 }
      );
    }

    // 파일명 생성
    const originalName = file.name;
    const sanitizedName = sanitizeFileName(originalName);
    const timestamp = Date.now();
    const fileName = `${timestamp}_${sanitizedName}`;
    const storagePath = `music/${user.id}/${fileName}`;

    // Service Client로 Storage에 업로드
    const serviceSupabase = createServiceClient();
    const fileBuffer = await file.arrayBuffer();
    const { error: uploadError } = await serviceSupabase.storage
      .from('user-uploads')
      .upload(storagePath, fileBuffer, {
        contentType: file.type,
        upsert: false
      });

    if (uploadError) {
      console.error('Upload error:', uploadError);
      return NextResponse.json(
        { error: '파일 업로드에 실패했습니다.' },
        { status: 500 }
      );
    }

    // 공개 URL 가져오기
    const { data: { publicUrl } } = serviceSupabase.storage
      .from('user-uploads')
      .getPublicUrl(storagePath);

    // DB에 저장 (클라이언트에서 전송한 메타데이터 사용)
    const { data: savedMusic, error: dbError } = await supabase
      .from('user_uploaded_music')
      .insert({
        user_id: user.id,
        file_name: originalName,
        storage_path: storagePath,
        file_size: file.size,
        duration: duration ? parseFloat(duration) : null,
        metadata: {
          mime_type: file.type,
          original_name: originalName
        },
        uploaded_at: new Date().toISOString()
      })
      .select()
      .single();

    if (dbError) {
      console.error('Database error:', dbError);
      // Storage에서 파일 삭제 (롤백)
      await serviceSupabase.storage
        .from('user-uploads')
        .remove([storagePath]);
      
      return NextResponse.json(
        { error: '데이터베이스 저장에 실패했습니다.' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      success: true,
      music: {
        ...savedMusic,
        url: publicUrl
      }
    });

  } catch (error) {
    console.error('Upload API error:', error);
    return NextResponse.json(
      { error: '업로드 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}

// 업로드된 음악 조회
export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const genre = searchParams.get('genre');
    const limit = parseInt(searchParams.get('limit') || '50');
    const offset = parseInt(searchParams.get('offset') || '0');

    let query = supabase
      .from('user_uploaded_music')
      .select('*')
      .eq('user_id', user.id)
      .eq('is_deleted', false)
      .order('uploaded_at', { ascending: false })
      .range(offset, offset + limit - 1);

    if (genre) {
      query = query.eq('genre', genre);
    }

    const { data, error } = await query;

    if (error) {
      console.error('Query error:', error);
      return NextResponse.json(
        { error: '음악 목록을 불러오는데 실패했습니다.' },
        { status: 500 }
      );
    }

    // Storage URL 추가
    const serviceSupabase = createServiceClient();
    const musicWithUrls = data?.map(music => {
      const { data: { publicUrl } } = serviceSupabase.storage
        .from('user-uploads')
        .getPublicUrl(music.storage_path);
      
      return {
        ...music,
        url: publicUrl
      };
    }) || [];

    return NextResponse.json({
      success: true,
      music: musicWithUrls,
      total: musicWithUrls.length
    });

  } catch (error) {
    console.error('Get API error:', error);
    return NextResponse.json(
      { error: '음악 목록 조회 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}

// 업로드된 음악 삭제
export async function DELETE(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const musicId = searchParams.get('id');

    if (!musicId) {
      return NextResponse.json(
        { error: '음악 ID가 필요합니다.' },
        { status: 400 }
      );
    }

    // 소프트 삭제
    const { error } = await supabase
      .from('user_uploaded_music')
      .update({ is_deleted: true })
      .eq('id', musicId)
      .eq('user_id', user.id);

    if (error) {
      return NextResponse.json(
        { error: '삭제에 실패했습니다.' },
        { status: 500 }
      );
    }

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('Delete API error:', error);
    return NextResponse.json(
      { error: '삭제 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/video/check-render/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const contentHash = searchParams.get('hash');
    
    if (!contentHash) {
      return NextResponse.json(
        { error: 'Content hash is required' },
        { status: 400 }
      );
    }

    // 인증 확인
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // content_hash로 기존 완료된 렌더링 확인
    const { data, error } = await supabase
      .from('video_renders')
      .select('render_id, output_url, status, created_at')
      .eq('user_id', user.id)
      .eq('content_hash', contentHash)
      .eq('status', 'completed')
      .order('created_at', { ascending: false })
      .limit(1)
      .maybeSingle(); // single() 대신 maybeSingle() 사용 (없어도 에러 안남)

    if (error) {
      console.error('Error checking render:', error);
      throw error;
    }

    // 렌더링이 있고 output_url이 있는 경우
    if (data && data.output_url) {
      // Supabase Storage URL 확인 (필요시 S3에서 마이그레이션)
      const finalUrl = data.output_url;
      
      // S3 URL인 경우 Supabase Storage 확인
      if (data.output_url.includes('amazonaws.com')) {
        // 향후 S3 → Supabase 마이그레이션 로직 추가 가능
        // 현재는 S3 URL 그대로 사용
      }
      
      return NextResponse.json({
        exists: true,
        renderId: data.render_id,
        outputUrl: finalUrl,
        createdAt: data.created_at
      });
    }

    // 렌더링이 없는 경우
    return NextResponse.json({
      exists: false,
      outputUrl: null
    });

  } catch (error) {
    console.error('Check render error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to check render',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/webhooks/fal-ai/route.ts">
import { NextRequest, NextResponse } from 'next/server';
// import { createClient } from '@/lib/supabase/server';
import { verifyWebhookSignature, extractWebhookHeaders } from '@/lib/fal-webhook';

interface FalWebhookPayload {
  request_id: string;
  gateway_request_id: string;
  status: 'OK' | 'ERROR';
  payload?: {
    video?: {
      url: string;
    };
    audio?: {
      url: string;
    };
    seed?: number;
  };
  error?: string;
}

export async function POST(request: NextRequest) {
  // Webhook received
  
  try {
    // 1. Job ID와 타입 추출
    const { searchParams } = new URL(request.url);
    const jobId = searchParams.get('jobId');
    const type = searchParams.get('type') || 'video'; // 기본값은 video
    
    if (!jobId) {
      return NextResponse.json(
        { error: 'Job ID가 필요합니다.' },
        { status: 400 }
      );
    }

    // 2. Webhook 헤더 추출
    const webhookHeaders = extractWebhookHeaders(request.headers);
    
    // Mock 모드가 아닌 경우에만 헤더 검증
    if (!webhookHeaders && process.env.NEXT_PUBLIC_MOCK_MODE !== 'true') {
      // Missing webhook headers
      return NextResponse.json(
        { error: 'Invalid webhook headers' },
        { status: 401 }
      );
    }

    // 3. 요청 본문 가져오기
    const bodyBuffer = Buffer.from(await request.arrayBuffer());
    
    // 4. 서명 검증 (프로덕션에서는 필수, Mock 모드에서는 스킵)
    if (process.env.NODE_ENV === 'production' && process.env.NEXT_PUBLIC_MOCK_MODE !== 'true' && webhookHeaders) {
      const isValid = await verifyWebhookSignature(
        webhookHeaders.requestId,
        webhookHeaders.userId,
        webhookHeaders.timestamp,
        webhookHeaders.signature,
        bodyBuffer
      );
      
      if (!isValid) {
        // Invalid webhook signature
        return NextResponse.json(
          { error: 'Invalid signature' },
          { status: 401 }
        );
      }
    }

    // 5. 요청 본문 파싱
    const body: FalWebhookPayload = JSON.parse(bodyBuffer.toString());
    
    // Processing webhook payload

    // 6. Supabase에서 job 업데이트 (Service Role 사용)
    const { createServiceClient } = await import('@/lib/supabase/service');
    const supabase = createServiceClient();
    
    // 타입에 따라 다른 테이블 업데이트
    if (type === 'sound') {
      // 사운드 생성 처리
      if (body.status === 'OK' && body.payload?.audio?.url) {
        // 성공 케이스
        const { error } = await supabase
          .from('sound_generations')
          .update({
            status: 'completed',
            output_audio_url: body.payload.audio.url,
            webhook_status: 'delivered',
            webhook_delivered_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId)
          .select('id, job_id')
          .single();
        
        if (error) {
          return NextResponse.json(
            { error: 'Database update failed', details: error },
            { status: 500 }
          );
        }
      } else {
        // 실패 케이스
        const errorMessage = body.error || 
                            body.payload?.toString() || 
                            'Unknown error';
        
        const { error } = await supabase
          .from('sound_generations')
          .update({
            status: 'failed',
            error_message: errorMessage,
            webhook_status: 'delivered',
            webhook_delivered_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        if (error) {
          return NextResponse.json(
            { error: 'Database update failed' },
            { status: 500 }
          );
        }
      }
    } else {
      // 비디오 생성 처리 (기존 코드)
      if (body.status === 'OK' && body.payload?.video?.url) {
        // 성공 케이스
        // Updating job with video URL
        
        const { error } = await supabase
          .from('video_generations')
          .update({
            status: 'completed',
            output_video_url: body.payload.video.url,
            webhook_status: 'delivered',
            webhook_delivered_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId)
          .select('id, job_id')
          .single();
        
        if (error) {
          // Error updating successful generation
          return NextResponse.json(
            { error: 'Database update failed', details: error },
            { status: 500 }
          );
        }
        
        // Job completed successfully
      } else {
        // 실패 케이스
        const errorMessage = body.error || 
                            body.payload?.toString() || 
                            'Unknown error';
        
        const { error } = await supabase
          .from('video_generations')
          .update({
            status: 'failed',
            error_message: errorMessage,
            webhook_status: 'delivered',
            webhook_delivered_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        if (error) {
          // Error updating failed generation
          return NextResponse.json(
            { error: 'Database update failed' },
            { status: 500 }
          );
        }
        
        // Job failed
      }
    }

    // 7. 성공 응답 반환
    return NextResponse.json({ 
      success: true,
      jobId,
      status: body.status 
    });

  } catch (error) {
    // Webhook processing error
    
    // Webhook은 재시도될 수 있으므로, 5xx 에러 반환
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : 'Webhook processing failed'
      },
      { status: 500 }
    );
  }
}

// OPTIONS 요청 처리 (CORS)
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, X-Fal-Webhook-Request-Id, X-Fal-Webhook-User-Id, X-Fal-Webhook-Timestamp, X-Fal-Webhook-Signature',
    },
  });
}
</file>

<file path="app/canvas/_components/ImageSection.tsx">
import { Plus, X } from "lucide-react";
import Image from "next/image";
import { useState, useCallback, useRef, useEffect } from "react";
import { ERROR_MESSAGES } from "@/lib/constants/errors";

interface ImageSectionProps {
  uploadedImage?: string | null;
  onImageUpload?: (imageUrl: string) => void;
  onImageRemove?: () => void;
}

export function ImageSection({ 
  uploadedImage = null,
  onImageUpload,
  onImageRemove
}: ImageSectionProps) {
  const [localImage, setLocalImage] = useState<string | null>(uploadedImage);
  const [error, setError] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  // 외부에서 uploadedImage prop이 변경되면 localImage 업데이트
  useEffect(() => {
    setLocalImage(uploadedImage);
  }, [uploadedImage]);

  const validateFile = (file: File): string | null => {
    // 파일 타입 검증
    if (!['image/jpeg', 'image/png'].includes(file.type)) {
      return ERROR_MESSAGES.INVALID_FORMAT;
    }
    
    // 파일 크기 검증 (10MB)
    if (file.size > 10 * 1024 * 1024) {
      return ERROR_MESSAGES.FILE_TOO_LARGE;
    }
    
    return null;
  };

  const uploadFile = useCallback(async (file: File) => {
    const validationError = validateFile(file);
    if (validationError) {
      setError(validationError);
      return;
    }

    setError(null);

    try {
      // FileReader를 사용하여 base64로 변환
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const base64Url = e.target?.result as string;
        setLocalImage(base64Url);
        onImageUpload?.(base64Url);
      };
      
      reader.onerror = () => {
        setError(ERROR_MESSAGES.UPLOAD_FAILED);
      };
      
      // base64 데이터 URL로 읽기
      reader.readAsDataURL(file);

    } catch (err) {
      setError(err instanceof Error ? err.message : ERROR_MESSAGES.NETWORK_ERROR);
    }
  }, [onImageUpload]);

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      uploadFile(file);
    }
    // input value를 초기화하여 동일한 파일도 다시 선택 가능하도록 함
    e.target.value = '';
  };


  const handleClick = () => {
    fileInputRef.current?.click();
  };

  const handleRemoveImage = () => {
    setLocalImage(null);
    onImageRemove?.();
  };

  return (
    <div className="mb-4">
      <h2 className="text-sm font-medium mb-3 text-foreground">Image</h2>
      <div className="flex gap-1.5">
        {/* Upload button - always visible */}
        <button
          className="w-16 h-16 rounded-md flex items-center justify-center border transition-all bg-primary border-primary hover:bg-primary/90 cursor-pointer group"
          onClick={handleClick}
          aria-label="Add image"
          title="이미지 업로드"
        >
          <Plus className="w-5 h-5 text-primary-foreground" />
        </button>
        
        {/* Uploaded image slot */}
        {localImage && (
          <div className="w-16 h-16 bg-surface rounded-md overflow-hidden relative group">
            <Image
              src={localImage}
              alt="Uploaded image"
              className="w-full h-full object-cover"
              fill
              sizes="64px"
            />
            {/* 삭제 버튼 - hover 시 표시 */}
            <button
              onClick={handleRemoveImage}
              className="absolute top-0.5 right-0.5 w-5 h-5 bg-black/60 rounded-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
              aria-label="Remove image"
            >
              <X className="w-3 h-3 text-white" />
            </button>
          </div>
        )}
      </div>
      
      {/* 숨겨진 파일 입력 */}
      <input
        ref={fileInputRef}
        type="file"
        accept="image/jpeg,image/png"
        onChange={handleFileSelect}
        className="hidden"
      />
      
      {/* 에러 메시지 표시 */}
      {error && (
        <div className="mt-2 text-xs text-destructive">
          {error}
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/canvas/_components/index.ts">
// Canvas 페이지 컴포넌트들의 배럴 export
export { CanvasLayout } from './CanvasLayout'
export { CanvasModals } from './CanvasModals'
export { Canvas } from './Canvas'
export { LeftPanel } from './LeftPanel'
export { VideoGenerationProgress } from './VideoGenerationProgress'
</file>

<file path="app/canvas/_components/LeftPanel.tsx">
import { ImageSection } from "./ImageSection";
import { EffectsSection } from "./EffectsSection";
import { PrompterSection } from "./PrompterSection";
import { EffectsGallery } from "./EffectsGallery";
import type { EffectTemplateWithMedia } from "@/types/database";

interface LeftPanelProps {
  isPrompterOpen: boolean;
  onPrompterToggle: () => void;
  promptText: string;
  onPromptChange: (text: string) => void;
  uploadedImage?: string | null;
  onImageUpload?: (imageUrl: string) => void;
  onImageRemove?: () => void;
  generationError?: string | null;
  onEffectModalOpen?: () => void;
  selectedEffects?: EffectTemplateWithMedia[];
  onEffectRemove?: (effectId: number) => void;
}

export function LeftPanel({
  isPrompterOpen,
  onPrompterToggle,
  promptText,
  onPromptChange,
  uploadedImage,
  onImageUpload,
  onImageRemove,
  generationError,
  onEffectModalOpen,
  selectedEffects,
  onEffectRemove,
}: LeftPanelProps) {
  return (
    <div className="w-64 bg-background p-6 border-r border-border">
      <ImageSection 
        uploadedImage={uploadedImage}
        onImageUpload={onImageUpload}
        onImageRemove={onImageRemove}
      />

      <EffectsSection 
        selectedEffects={selectedEffects}
        onEffectClick={onEffectModalOpen}
        onEffectRemove={onEffectRemove}
      />
      
      <PrompterSection
        isOpen={isPrompterOpen}
        onToggle={onPrompterToggle}
        promptText={promptText}
        onPromptChange={onPromptChange}
      />

      <EffectsGallery
        onEffectClick={onEffectModalOpen}
      />

      {/* Error Message */}
      {generationError && (
        <div className="mt-4 p-3 bg-destructive/10 border border-destructive/20 rounded-lg">
          <p className="text-sm text-destructive">{generationError}</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/canvas/_components/VideoGenerationProgress.tsx">
import React, { useEffect, useRef } from 'react';

interface VideoGenerationProgressProps {
  progress: number;
  isVisible: boolean;
  jobId?: string;
}

export function VideoGenerationProgress({ 
  progress, 
  isVisible,
  jobId
}: VideoGenerationProgressProps) {
  const previousProgressRef = useRef(progress);
  const startTimeRef = useRef<number>(Date.now());
  
  
  // Progress 변화 시 로깅
  useEffect(() => {
    if (isVisible && progress !== previousProgressRef.current) {
      previousProgressRef.current = progress;
    }
  }, [progress, isVisible, jobId]);
  
  // 컴포넌트 마운트 시 시작 시간 초기화
  useEffect(() => {
    if (isVisible) {
      startTimeRef.current = Date.now();
    }
  }, [isVisible]);
  
  if (!isVisible) return null;

  return (
    <div className="absolute inset-0 z-30 bg-black/60 flex items-center justify-center">
      {/* Progress bar container - thicker and more visible */}
      <div className="absolute top-0 left-0 right-0 h-2 bg-gray-800/80">
        <div 
          className="h-full bg-green-500 transition-all duration-500 ease-out relative overflow-hidden"
          style={{ width: `${progress}%` }}
        >
          {/* Animated shine effect */}
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent w-1/2 -skew-x-12 animate-shimmer" />
        </div>
      </div>
      
      {/* Progress info container - 퍼센트만 표시 */}
      <div className="text-center">
        {/* Percentage display with shadow for better visibility */}
        <div className="text-white text-7xl font-bold drop-shadow-2xl">
          {Math.round(progress)}%
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/canvas/_context/CanvasContext.tsx">
'use client'

import React, { createContext, useContext, useState, useCallback } from 'react'
import type { GeneratedVideo } from '@/types/canvas'
import type { CanvasContextValue } from '../_types'
import { useModalManager } from '../_hooks/useModalManager'
import { useFavoritesManager } from '../_hooks/useFavoritesManager'
import { useEffectsManager } from '../_hooks/useEffectsManager'
import { useCanvasSettings } from '../_hooks/useCanvasSettings'
import { useSlotManager } from '../_hooks/useSlotManager'
import { useVideoGeneration } from '../_hooks/useVideoGeneration'
import { CanvasAPI } from '../_services/api'

const CanvasContext = createContext<CanvasContextValue | undefined>(undefined)

export function useCanvas(): CanvasContextValue {
  const context = useContext(CanvasContext)
  if (!context) {
    throw new Error('useCanvas must be used within CanvasProvider')
  }
  return context
}

interface CanvasProviderProps {
  children: React.ReactNode
}

/**
 * Canvas 페이지의 모든 상태와 로직을 통합 관리하는 Provider
 * Props drilling을 완전히 제거하고 관심사를 분리
 */
export function CanvasProvider({ children }: CanvasProviderProps): React.ReactElement {
  
  // 각 도메인별 훅 사용
  const modals = useModalManager()
  const favorites = useFavoritesManager()
  const effects = useEffectsManager()
  const settings = useCanvasSettings()
  const slotManager = useSlotManager()
  
  // 로컬 상태
  const [currentGeneratingImage, setCurrentGeneratingImage] = useState<string | null>(null)
  const [selectedVideoId, setSelectedVideoId] = useState<string | null>(null)
  const [isDownloading, setIsDownloading] = useState<boolean>(false)
  
  // 비디오 생성 훅 (의존성 주입)
  const videoGeneration = useVideoGeneration({
    getCurrentImage: () => currentGeneratingImage,
    selectedEffects: effects.selectedEffects,
    promptText: settings.promptText,
    selectedDuration: settings.selectedDuration,
    slotManager: {
      slotStates: slotManager.slotStates,
      findAvailableSlotForGeneration: slotManager.findAvailableSlotForGeneration,
      setSlotToImage: slotManager.setSlotToImage,
      markSlotGenerating: slotManager.markSlotGenerating,
      placeVideoInSlot: slotManager.placeVideoInSlot,
      resetSlot: slotManager.resetSlot,
    },
    onVideoCompleted: (video: GeneratedVideo) => {
      if (!selectedVideoId) {
        setSelectedVideoId(video.id)
      }
    },
  })

  // 다운로드 핸들러
  const handleDownload = useCallback(async (): Promise<void> => {
    if (!slotManager.activeVideo || !slotManager.activeVideo.url) {
      return
    }

    if (isDownloading) {
      return
    }

    setIsDownloading(true)

    try {
      const effectName = effects.selectedEffects[0]?.name
      await CanvasAPI.downloadAndSaveVideo(slotManager.activeVideo, effectName)
    } catch (error) {
      console.error('Download failed:', error)
      videoGeneration.setGenerationError('다운로드에 실패했습니다. 다시 시도해주세요.')
    } finally {
      setIsDownloading(false)
    }
  }, [slotManager.activeVideo, isDownloading, effects.selectedEffects, videoGeneration])

  const contextValue: CanvasContextValue = {
    modals,
    settings,
    favorites,
    effects,
    currentGeneratingImage,
    setCurrentGeneratingImage,
    selectedVideoId,
    setSelectedVideoId,
    isDownloading,
    handleDownload,
  }

  return <CanvasContext.Provider value={contextValue}>{children}</CanvasContext.Provider>
}

// 개별 훅들을 export하여 필요한 곳에서 직접 사용 가능
export { useSlotManager } from '../_hooks/useSlotManager'
export { useVideoGeneration } from '../_hooks/useVideoGeneration'
</file>

<file path="app/canvas/_hooks/index.ts">
// Canvas 페이지 전용 훅들의 배럴 export
export { useModalManager } from './useModalManager'
export { useFavoritesManager } from './useFavoritesManager'
export { useEffectsManager } from './useEffectsManager'
export { useCanvasSettings } from './useCanvasSettings'
export { useSlotManager } from './useSlotManager'
export { useVideoGeneration } from './useVideoGeneration'
export { useBeforeUnload } from './useBeforeUnload'
export { useEffectsData, EffectsDataProvider } from './useEffectsData'
</file>

<file path="app/canvas/_hooks/useCanvas.ts">
import { useState, useCallback } from 'react';

export interface CanvasImage {
  id: string;
  url: string;
  isFavorite: boolean;
}

export function useCanvas() {
  const [images, setImages] = useState<CanvasImage[]>([
    {
      id: '1',
      url: '',
      isFavorite: false,
    },
    {
      id: '2',
      url: '',
      isFavorite: false,
    },
    {
      id: '3',
      url: '',
      isFavorite: false,
    },
    {
      id: '4',
      url: '',
      isFavorite: false,
    },
  ]);

  const [thumbnails] = useState<CanvasImage[]>([
    {
      id: 't1',
      url: 'https://images.unsplash.com/photo-1441986300917-64674bd600d8?w=80&h=80&fit=crop&crop=center',
      isFavorite: false,
    },
    {
      id: 't2',
      url: 'https://images.unsplash.com/photo-1506905925346-21bda4d32df4?w=80&h=80&fit=crop&crop=center',
      isFavorite: false,
    },
    {
      id: 't3',
      url: 'https://images.unsplash.com/photo-1557804506-669a67965ba0?w=80&h=80&fit=crop&crop=center',
      isFavorite: false,
    },
    {
      id: 't4',
      url: '',
      isFavorite: false,
    },
  ]);

  const [selectedThumbnailIndex, setSelectedThumbnailIndex] = useState(1);

  const toggleFavorite = useCallback((index: number) => {
    setImages(prev => prev.map((img, i) => 
      i === index ? { ...img, isFavorite: !img.isFavorite } : img
    ));
  }, []);

  const selectThumbnail = useCallback((index: number) => {
    setSelectedThumbnailIndex(index);
  }, []);

  const addNewImage = useCallback(() => {
    // Placeholder for adding new image functionality
  }, []);

  return {
    images,
    thumbnails,
    selectedThumbnailIndex,
    toggleFavorite,
    selectThumbnail,
    addNewImage,
  };
}
</file>

<file path="app/canvas/_hooks/useCanvasSettings.ts">
'use client'

import { useState, useCallback } from 'react'
import type { CanvasSettings, CanvasSettingsReturn } from '../_types'

const initialSettings: CanvasSettings = {
  promptText: '',
  negativePrompt: '',
  selectedResolution: '1:1',
  selectedSize: '1024×1024',
  selectedModelId: '',
  selectedDuration: '6',
  isPrompterOpen: false,
}

/**
 * Canvas 페이지의 모든 설정을 관리하는 훅
 * 프롬프트, 해상도, 모델 등의 설정 통합 관리
 */
export function useCanvasSettings(): CanvasSettingsReturn {
  const [settings, setSettings] = useState<CanvasSettings>(initialSettings)

  const updateSettings = useCallback((newSettings: Partial<CanvasSettings>): void => {
    setSettings((prev) => ({
      ...prev,
      ...newSettings,
    }))
  }, [])

  const resetSettings = useCallback((): void => {
    setSettings(initialSettings)
  }, [])

  return {
    ...settings,
    updateSettings,
    resetSettings,
  }
}
</file>

<file path="app/canvas/_hooks/useEffectsManager.ts">
'use client'

import { useState, useCallback } from 'react'
import type { EffectTemplateWithMedia } from '@/types/database'
import type { EffectsManagerReturn } from '../_types'

const MAX_EFFECTS = 2

/**
 * 효과 선택 및 관리를 담당하는 훅
 * 최대 2개까지 효과 선택 가능
 */
export function useEffectsManager(): EffectsManagerReturn {
  const [selectedEffects, setSelectedEffects] = useState<EffectTemplateWithMedia[]>([])

  const canAddMore = selectedEffects.length < MAX_EFFECTS

  const addEffect = useCallback((effect: EffectTemplateWithMedia): void => {
    setSelectedEffects((prev) => {
      // 이미 선택된 효과인지 확인
      if (prev.some((e) => e.id === effect.id)) {
        return prev
      }
      
      // 최대 개수 초과 시 첫 번째 효과를 제거하고 추가
      if (prev.length >= MAX_EFFECTS) {
        return [...prev.slice(1), effect]
      }
      
      return [...prev, effect]
    })
  }, [])

  const removeEffect = useCallback((effectId: number): void => {
    setSelectedEffects((prev) => prev.filter((e) => e.id !== effectId))
  }, [])

  const toggleEffect = useCallback((effect: EffectTemplateWithMedia): void => {
    setSelectedEffects((prev) => {
      const isSelected = prev.some((e) => e.id === effect.id)
      
      if (isSelected) {
        // 선택 해제
        return prev.filter((e) => e.id !== effect.id)
      } else {
        // 선택 추가
        if (prev.length >= MAX_EFFECTS) {
          // 첫 번째 요소를 제거하고 새로운 것을 추가
          return [...prev.slice(1), effect]
        }
        return [...prev, effect]
      }
    })
  }, [])

  const clearEffects = useCallback((): void => {
    setSelectedEffects([])
  }, [])

  return {
    selectedEffects,
    canAddMore,
    addEffect,
    removeEffect,
    toggleEffect,
    clearEffects,
    maxEffects: MAX_EFFECTS,
  }
}
</file>

<file path="app/canvas/_hooks/useFavoritesManager.ts">
'use client'

import { useState, useCallback, useEffect } from 'react'
import { useAuth } from '@/lib/auth/AuthContext'
import type { FavoritesManagerReturn, FavoritesApiResponse } from '../_types'

/**
 * 즐겨찾기 상태와 API 통신을 관리하는 훅
 * page.tsx에서 분리하여 단일 책임 원칙 준수
 */
export function useFavoritesManager(): FavoritesManagerReturn {
  const [favoriteIds, setFavoriteIds] = useState<Set<string>>(new Set())
  const [isLoading, setIsLoading] = useState<boolean>(false)
  const [error, setError] = useState<string | null>(null)
  const { user } = useAuth()

  // 초기 즐겨찾기 로드
  const loadFavorites = useCallback(async (): Promise<void> => {
    if (!user) {
      setFavoriteIds(new Set())
      return
    }

    setIsLoading(true)
    setError(null)

    try {
      const response = await fetch('/api/canvas/favorites')
      
      if (!response.ok) {
        throw new Error(`Failed to fetch favorites: ${response.status}`)
      }

      const data: FavoritesApiResponse = await response.json()
      
      if (data.favoriteIds) {
        setFavoriteIds(new Set(data.favoriteIds))
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load favorites'
      console.error('Failed to load favorites:', err)
      setError(errorMessage)
    } finally {
      setIsLoading(false)
    }
  }, [user])

  // 즐겨찾기 토글
  const toggleFavorite = useCallback(async (videoId: string): Promise<void> => {
    if (!user) {
      setError('로그인이 필요합니다.')
      return
    }

    const currentIsFavorite = favoriteIds.has(videoId)
    const newFavoriteState = !currentIsFavorite

    // 낙관적 업데이트
    setFavoriteIds((prev) => {
      const newSet = new Set(prev)
      if (newFavoriteState) {
        newSet.add(videoId)
      } else {
        newSet.delete(videoId)
      }
      return newSet
    })

    try {
      const response = await fetch('/api/canvas/favorite', {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          videoId,
          isFavorite: newFavoriteState,
        }),
      })

      if (!response.ok) {
        throw new Error(`Failed to toggle favorite: ${response.status}`)
      }

      // 성공 시 에러 클리어
      setError(null)
    } catch (err) {
      // 실패 시 롤백
      setFavoriteIds((prev) => {
        const newSet = new Set(prev)
        if (currentIsFavorite) {
          newSet.add(videoId)
        } else {
          newSet.delete(videoId)
        }
        return newSet
      })

      const errorMessage = err instanceof Error ? err.message : 'Failed to toggle favorite'
      console.error('Error toggling favorite:', err)
      setError(errorMessage)
      
      // 에러를 다시 throw하여 호출자가 처리할 수 있도록 함
      throw err
    }
  }, [favoriteIds, user])

  // 특정 비디오가 즐겨찾기인지 확인
  const isFavorite = useCallback(
    (videoId: string): boolean => {
      return favoriteIds.has(videoId)
    },
    [favoriteIds]
  )

  // 즐겨찾기 새로고침
  const refreshFavorites = useCallback(async (): Promise<void> => {
    await loadFavorites()
  }, [loadFavorites])

  // 컴포넌트 마운트 시 즐겨찾기 로드
  useEffect(() => {
    loadFavorites()
  }, [loadFavorites])

  return {
    favoriteIds,
    isLoading,
    error,
    toggleFavorite,
    isFavorite,
    refreshFavorites,
  }
}
</file>

<file path="app/canvas/_hooks/useSlotManager.ts">
import { useCallback, useState } from "react";
import type { GeneratedVideo } from "@/types/canvas";

type SlotContent = { type: "image" | "video"; data: string | GeneratedVideo } | null;

/**
 * Canvas 슬롯 상태와 배치 규칙을 관리하는 훅
 * - 4개 슬롯의 콘텐츠/상태/완료시점을 관리
 * - 이미지 업로드/제거, 히스토리 비디오 토글 배치, 슬롯 선택 등의 로직 캡슐화
 */
export function useSlotManager() {
  const [slotContents, setSlotContents] = useState<Array<SlotContent>>([
    null,
    null,
    null,
    null,
  ]);
  const [slotStates, setSlotStates] = useState<Array<"empty" | "generating" | "completed">>([
    "empty",
    "empty",
    "empty",
    "empty",
  ]);
  const [slotCompletedAt, setSlotCompletedAt] = useState<Array<number | null>>([
    null,
    null,
    null,
    null,
  ]);
  const [selectedSlotIndex, setSelectedSlotIndex] = useState<number | null>(null);
  const [activeVideo, setActiveVideo] = useState<GeneratedVideo | null>(null);

  /**
   * 이미지 업로드 시 슬롯 배치 로직
   * - 1) 빈 슬롯 → 2) 이미지 슬롯(진행 중 제외) → 3) 가장 오래된 완료 비디오
   * - 대상 슬롯을 이미지로 채우고, 상태는 empty 유지, 완료시점은 리셋
   */
  const handleImageUpload = useCallback(
    (imageUrl: string, isSlotGenerating: (slotIndex: number) => boolean) => {
      setSlotContents(prev => {
        let target = -1;

        // 1) 빈 슬롯 우선
        for (let i = 0; i < 4; i++) {
          if (!prev[i]) {
            target = i;
            break;
          }
        }

        // 2) 이미지 슬롯 교체 (진행 중 제외)
        if (target === -1) {
          for (let i = 0; i < 4; i++) {
            if (prev[i]?.type === "image" && !isSlotGenerating(i)) {
              target = i;
              break;
            }
          }
        }

        // 3) 비디오 슬롯 중 가장 오래된 완료를 교체
        if (target === -1) {
          const videoIndices: number[] = [];
          for (let i = 0; i < 4; i++) {
            if (prev[i]?.type === "video") videoIndices.push(i);
          }
          if (videoIndices.length > 0) {
            let idxChosen = videoIndices[0];
            let timeChosen = slotCompletedAt[idxChosen];
            for (let i = 1; i < videoIndices.length; i++) {
              const idx = videoIndices[i];
              const t = slotCompletedAt[idx];
              if (t !== null && (timeChosen === null || t < timeChosen)) {
                idxChosen = idx;
                timeChosen = t;
              }
            }
            target = idxChosen;
          }
        }

        if (target === -1) return prev;

        const newSlots = [...prev];
        newSlots[target] = { type: "image", data: imageUrl };

        // 상태와 완료시점 동기 업데이트
        setSlotStates(prevStates => {
          const next = [...prevStates];
          next[target] = "empty"; // generate 가능 상태 유지
          return next;
        });
        setSlotCompletedAt(prevTimes => {
          const next = [...prevTimes];
          next[target] = null;
          return next;
        });

        return newSlots;
      });
    },
    [slotCompletedAt]
  );

  /**
   * LeftPanel 이미지 제거 시, 동일 이미지가 슬롯에 올라와 있고 empty 상태이면 제거
   */
  const removeImageByUrlIfEmpty = useCallback((imageUrl: string) => {
    if (!imageUrl) return;
    setSlotContents(prev => {
      const newSlots = [...prev];
      for (let i = 0; i < 4; i++) {
        if (
          newSlots[i]?.type === "image" &&
          (newSlots[i]?.data as string) === imageUrl &&
          slotStates[i] === "empty"
        ) {
          newSlots[i] = null;
          setSlotStates(prevStates => {
            const next = [...prevStates];
            next[i] = "empty";
            return next;
          });
          setSlotCompletedAt(prevTimes => {
            const next = [...prevTimes];
            next[i] = null;
            return next;
          });
          break;
        }
      }
      return newSlots;
    });
  }, [slotStates]);

  /**
   * 히스토리 비디오 토글 배치
   * - 이미 있으면 제거, 없으면 우선순위 규칙에 따라 배치
   * - 모든 슬롯이 진행 중이면 false 반환
   */
  const handleVideoToggle = useCallback(
    (video: GeneratedVideo, isSlotGenerating: (slotIndex: number) => boolean): boolean => {
      // 이미 슬롯에 있는지 확인 (있으면 제거)
      const existingIndex = slotContents.findIndex(slot => slot?.type === "video" && (slot.data as GeneratedVideo).id === video.id);
      if (existingIndex !== -1) {
        setSlotContents(prev => {
          const next = [...prev];
          next[existingIndex] = null;
          return next;
        });
        setSlotStates(prev => {
          const next = [...prev];
          next[existingIndex] = "empty";
          return next;
        });
        setSlotCompletedAt(prev => {
          const next = [...prev];
          next[existingIndex] = null;
          return next;
        });
        return true;
      }

      // 배치할 슬롯 선택: 빈 → 이미지(진행중 제외) → 가장 오래된 비디오
      let targetSlot = -1;
      for (let i = 0; i < 4; i++) {
        if (!slotContents[i]) {
          targetSlot = i;
          break;
        }
      }
      if (targetSlot === -1) {
        for (let i = 0; i < 4; i++) {
          if (slotContents[i]?.type === "image" && !isSlotGenerating(i)) {
            targetSlot = i;
            break;
          }
        }
      }
      if (targetSlot === -1) {
        const videoIndices: number[] = [];
        for (let i = 0; i < 4; i++) {
          if (slotContents[i]?.type === "video") videoIndices.push(i);
        }
        if (videoIndices.length > 0) {
          let chosenIndex = videoIndices[0];
          let chosenTime = slotCompletedAt[chosenIndex];
          for (let i = 1; i < videoIndices.length; i++) {
            const idx = videoIndices[i];
            const t = slotCompletedAt[idx];
            if (t !== null && (chosenTime === null || t < chosenTime)) {
              chosenIndex = idx;
              chosenTime = t;
            }
          }
          targetSlot = chosenIndex;
        }
      }

      if (targetSlot === -1) {
        // 모든 슬롯이 진행 중이거나 배치 불가
        return false;
      }

      setSlotContents(prev => {
        const next = [...prev];
        next[targetSlot] = { type: "video", data: video };
        return next;
      });
      setSlotStates(prev => {
        const next = [...prev];
        next[targetSlot] = "completed";
        return next;
      });
      setSlotCompletedAt(prev => {
        const next = [...prev];
        next[targetSlot] = Date.now();
        return next;
      });
      return true;
    },
    [slotContents, slotCompletedAt]
  );

  /**
   * 슬롯 직접 선택(미리보기 활성화)
   */
  const handleSlotSelect = useCallback((index: number, video: GeneratedVideo | null) => {
    setSelectedSlotIndex(index);
    setActiveVideo(video);
  }, []);

  /**
   * 슬롯 콘텐츠 제거 (단순 비우기)
   */
  const handleRemoveContent = useCallback((index: number) => {
    setSlotContents(prev => {
      const next = [...prev];
      next[index] = null;
      return next;
    });
    setSlotStates(prev => {
      const next = [...prev];
      next[index] = "empty";
      return next;
    });
    setSlotCompletedAt(prev => {
      const next = [...prev];
      next[index] = null;
      return next;
    });
  }, []);

  /**
   * 즐겨찾기 플래그를 슬롯 내 해당 비디오에 반영
   */
  const updateVideoFavoriteFlag = useCallback((videoId: string, isFavorite: boolean) => {
    setSlotContents(prev => prev.map(slot => {
      if (slot?.type === "video" && (slot.data as GeneratedVideo).id === videoId) {
        return {
          ...slot,
          data: { ...(slot.data as GeneratedVideo), isFavorite },
        } as SlotContent;
      }
      return slot;
    }));
  }, []);

  /**
   * 생성 진입 시 사용 가능한 슬롯 탐색
   * - 1) 현재 이미지가 있는 동일 슬롯(상태 empty)
   * - 2) 완전 빈 슬롯
   * - 3) 가장 오래된 completed 슬롯
   */
  const findAvailableSlotForGeneration = useCallback((imageUrl: string | null): number => {
    if (!imageUrl) return -1;
    let available = -1;

    // 1) 동일 이미지가 있고 empty 상태인 슬롯
    for (let i = 0; i < 4; i++) {
      const slot = slotContents[i];
      if (slot?.type === "image" && slot.data === imageUrl && slotStates[i] === "empty") {
        available = i;
        break;
      }
    }

    // 2) 완전 빈 슬롯
    if (available === -1) {
      for (let i = 0; i < 4; i++) {
        if (slotStates[i] === "empty" && !slotContents[i]) {
          available = i;
          break;
        }
      }
    }

    // 3) 가장 오래된 completed 슬롯
    if (available === -1) {
      const completedIndices: number[] = [];
      for (let i = 0; i < 4; i++) {
        if (slotStates[i] === "completed") completedIndices.push(i);
      }
      if (completedIndices.length > 0) {
        let chosenIndex = completedIndices[0];
        let chosenTime = slotCompletedAt[chosenIndex];
        for (let i = 1; i < completedIndices.length; i++) {
          const idx = completedIndices[i];
          const t = slotCompletedAt[idx];
          if (t !== null && (chosenTime === null || t < chosenTime)) {
            chosenIndex = idx;
            chosenTime = t;
          }
        }
        available = chosenIndex;
      }
    }

    return available;
  }, [slotContents, slotStates, slotCompletedAt]);

  /**
   * 슬롯을 이미지로 설정 (상태/완료시점은 별도 제어)
   */
  const setSlotToImage = useCallback((slotIndex: number, imageUrl: string) => {
    setSlotContents(prev => {
      const next = [...prev];
      next[slotIndex] = { type: "image", data: imageUrl };
      return next;
    });
    setSlotCompletedAt(prev => {
      const next = [...prev];
      next[slotIndex] = null;
      return next;
    });
  }, []);

  /**
   * 슬롯 상태를 generating으로 설정
   */
  const markSlotGenerating = useCallback((slotIndex: number) => {
    setSlotStates(prev => {
      const next = [...prev];
      next[slotIndex] = "generating";
      return next;
    });
  }, []);

  /**
   * 비디오를 슬롯에 배치하고 completed로 설정 + 완료시점 기록
   */
  const placeVideoInSlot = useCallback((slotIndex: number, video: GeneratedVideo) => {
    setSlotContents(prev => {
      const next = [...prev];
      next[slotIndex] = { type: "video", data: video };
      return next;
    });
    setSlotStates(prev => {
      const next = [...prev];
      next[slotIndex] = "completed";
      return next;
    });
    setSlotCompletedAt(prev => {
      const next = [...prev];
      next[slotIndex] = Date.now();
      return next;
    });
  }, []);

  /**
   * 슬롯 상태를 completed로만 업데이트 (필요 시 외부에서 사용)
   */
  const markSlotCompleted = useCallback((slotIndex: number) => {
    setSlotStates(prev => {
      const next = [...prev];
      next[slotIndex] = "completed";
      return next;
    });
    setSlotCompletedAt(prev => {
      const next = [...prev];
      next[slotIndex] = Date.now();
      return next;
    });
  }, []);

  /**
   * 실패 시 슬롯을 초기화 (empty)
   */
  const resetSlot = useCallback((slotIndex: number) => {
    setSlotStates(prev => {
      const next = [...prev];
      next[slotIndex] = "empty";
      return next;
    });
    setSlotContents(prev => {
      const next = [...prev];
      next[slotIndex] = null;
      return next;
    });
    setSlotCompletedAt(prev => {
      const next = [...prev];
      next[slotIndex] = null;
      return next;
    });
  }, []);

  return {
    // 상태
    slotContents,
    slotStates,
    slotCompletedAt,
    selectedSlotIndex,
    activeVideo,

    // 선택 제어
    setSelectedSlotIndex,
    setActiveVideo,
    handleSlotSelect,

    // 이미지/비디오 배치
    handleImageUpload,
    removeImageByUrlIfEmpty,
    handleVideoToggle,
    handleRemoveContent,

    // 생성 플로우 인터페이스
    findAvailableSlotForGeneration,
    setSlotToImage,
    markSlotGenerating,
    placeVideoInSlot,
    markSlotCompleted,
    resetSlot,
    updateVideoFavoriteFlag,
  };
}
</file>

<file path="app/canvas/_hooks/useVideoGeneration.ts">
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import type { GeneratedVideo } from "@/types/canvas";
import type { EffectTemplateWithMedia } from "@/types/database";

/**
 * 진행률 계산: 경과 시간 기반으로 0~90% 구간을 부드럽게 증가
 */
const calculateProgressForElapsedTime = (elapsedSeconds: number, expectedDuration: number = 190): number => {
  const checkpoints = [
    { time: 10, progress: 5 },
    { time: 30, progress: 15 },
    { time: 60, progress: 30 },
    { time: 100, progress: 50 },
    { time: 140, progress: 70 },
    { time: 170, progress: 83 },
    { time: 190, progress: 90 },
  ];

  let targetProgress = 0;

  for (let i = 0; i < checkpoints.length; i++) {
    const checkpoint = checkpoints[i];
    const nextCheckpoint = checkpoints[i + 1];
    if (elapsedSeconds >= checkpoint.time) {
      if (!nextCheckpoint || elapsedSeconds < nextCheckpoint.time) {
        if (nextCheckpoint) {
          const timeRatio = (elapsedSeconds - checkpoint.time) / (nextCheckpoint.time - checkpoint.time);
          const progressDiff = nextCheckpoint.progress - checkpoint.progress;
          targetProgress = checkpoint.progress + progressDiff * timeRatio;
        } else {
          targetProgress = checkpoint.progress;
        }
        break;
      }
    } else if (i === 0) {
      targetProgress = (elapsedSeconds / checkpoint.time) * checkpoint.progress;
      break;
    }
  }

  if (elapsedSeconds > expectedDuration) {
    const overtime = elapsedSeconds - expectedDuration;
    const slowdown = Math.log(1 + overtime / expectedDuration) * 2;
    targetProgress = Math.max(85, 90 - slowdown);
  }

  const smoothIncrement = 0.1 + Math.random() * 0.2;
  targetProgress += smoothIncrement;
  return Math.min(targetProgress, 90);
};

/**
 * 완료 애니메이션 시간 계산: 남은 진행률이 많을수록 더 오래
 */
const calculateCompletionAnimationDuration = (currentProgress: number): number => {
  const remainingProgress = 100 - currentProgress;
  return Math.min(3000, Math.max(500, (remainingProgress / 100) * 3000));
};

type SlotManagerApi = {
  slotStates: Array<"empty" | "generating" | "completed">;
  findAvailableSlotForGeneration: (imageUrl: string | null) => number;
  setSlotToImage: (slotIndex: number, imageUrl: string) => void;
  markSlotGenerating: (slotIndex: number) => void;
  placeVideoInSlot: (slotIndex: number, video: GeneratedVideo) => void;
  resetSlot: (slotIndex: number) => void;
};

interface UseVideoGenerationArgs {
  getCurrentImage: () => string | null;
  selectedEffects: EffectTemplateWithMedia[];
  promptText: string;
  selectedDuration: string;
  slotManager: SlotManagerApi;
  onVideoCompleted?: (video: GeneratedVideo, slotIndex: number) => void;
}

/**
 * 비디오 생성/폴링/진행률/에러를 관리하는 훅
 */
export function useVideoGeneration({
  getCurrentImage,
  selectedEffects,
  promptText,
  selectedDuration,
  slotManager,
  onVideoCompleted,
}: UseVideoGenerationArgs) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatingProgress, setGeneratingProgress] = useState<Map<string, number>>(new Map());
  const [generatingJobIds, setGeneratingJobIds] = useState<Map<string, string>>(new Map());
  const [generatingSlots, setGeneratingSlots] = useState<Set<number>>(new Set());
  const [generationError, setGenerationError] = useState<string | null>(null);

  // 최신 상태 보관용 ref (타이머 콜백에서 안전하게 사용)
  const progressRef = useRef(generatingProgress);
  useEffect(() => {
    progressRef.current = generatingProgress;
  }, [generatingProgress]);

  // 에러 자동 제거
  useEffect(() => {
    if (!generationError) return;
    const t = setTimeout(() => setGenerationError(null), 5000);
    return () => clearTimeout(t);
  }, [generationError]);

  const isSlotGenerating = useCallback((slotIndex: number) => {
    return progressRef.current.has(slotIndex.toString());
  }, []);

  const canGenerate = useMemo(() => {
    const imageUrl = getCurrentImage();
    const hasPromptOrEffect = selectedEffects.length > 0 || promptText.trim().length > 0;
    const concurrentLimitOk = generatingSlots.size < 2; // 동시 2개 제한
    return !!imageUrl && hasPromptOrEffect && concurrentLimitOk;
  }, [getCurrentImage, selectedEffects, promptText, generatingSlots.size]);

  /**
   * 비디오 생성 시작 핸들러
   */
  const generateVideo = useCallback(async () => {
    const imageUrl = getCurrentImage();
    if (!imageUrl) {
      setGenerationError("Please upload an image first.");
      return;
    }
    if (selectedEffects.length === 0 && !promptText.trim()) {
      setGenerationError("Please select at least one effect or enter a prompt.");
      return;
    }

    // 동시 생성 2개 제한 (슬롯 상태 기준)
    const generatingCount = slotManager.slotStates.filter(s => s === "generating").length;
    if (generatingCount >= 2) {
      setGenerationError("최대 2개까지 동시 생성이 가능합니다.");
      return;
    }

    // 배치할 슬롯 선택
    const availableSlot = slotManager.findAvailableSlotForGeneration(imageUrl);
    if (availableSlot === -1) {
      setGenerationError("사용 가능한 슬롯이 없습니다.");
      return;
    }

    // UI 선반영
    slotManager.setSlotToImage(availableSlot, imageUrl);
    slotManager.markSlotGenerating(availableSlot);
    setGeneratingSlots(prev => new Set([...prev, availableSlot]));
    setIsGenerating(true);
    setGenerationError(null);

    // 진행률 초기화
    setGeneratingProgress(prev => {
      const next = new Map(prev);
      next.set(availableSlot.toString(), 0);
      return next;
    });
    setGeneratingJobIds(prev => {
      const next = new Map(prev);
      next.set(availableSlot.toString(), `pending-${availableSlot}`);
      return next;
    });

    try {
      // 1. 비동기 생성 요청
      const response = await fetch("/api/canvas/generate-async", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageUrl,
          effectIds: selectedEffects.map(e => e.id),
          basePrompt: promptText,
          duration: selectedDuration,
        }),
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || "Video generation failed.");
      }

      const jobStartTimes = new Map<string, number>();
      const jobCompletedMap = new Map<string, boolean>();
      const completionStartTimes = new Map<string, number>();

      if (data.jobs && data.jobs.length > 0) {
        const firstJob = data.jobs[0];
        setGeneratingProgress(prev => {
          const next = new Map(prev);
          next.set(availableSlot.toString(), 0);
          return next;
        });
        setGeneratingJobIds(prev => {
          const next = new Map(prev);
          next.set(availableSlot.toString(), firstJob.jobId);
          return next;
        });
        jobStartTimes.set(firstJob.jobId, Date.now());
        jobCompletedMap.set(firstJob.jobId, false);
      }

      // 2. 폴링
      const pollJobs = async (targetSlot: number) => {
        const pollPromises = (data.jobs as Array<{ jobId: string }>).map(async job => {
          const jobStartTime = jobStartTimes.get(job.jobId) || Date.now();
          const elapsedTime = Date.now() - jobStartTime;
          const elapsedMinutes = Math.floor(elapsedTime / 60000);

          // 5분 경과시 webhook 확인 및 직접 폴링
          if (elapsedMinutes >= 5 && elapsedTime % 60000 < 2000) {
            const webhookCheckResponse = await fetch(`/api/canvas/jobs/${job.jobId}/check-webhook`);
            const webhookCheckData = await webhookCheckResponse.json();
            if (webhookCheckData.webhookCheckRequired) {
              const pollResponse = await fetch(`/api/canvas/jobs/${job.jobId}/poll`);
              const pollData = await pollResponse.json();
              if (pollData.status === "completed" || pollData.status === "failed") {
                return pollData;
              }
            }
          }

          // 일반 상태
          const statusResponse = await fetch(`/api/canvas/jobs/${job.jobId}`);
          const statusData = await statusResponse.json();

          if (statusData.status === "processing") {
            if (!jobCompletedMap.get(job.jobId)) {
              const now = Date.now();
              const start = jobStartTimes.get(job.jobId) || now;
              const elapsedSeconds = (now - start) / 1000;
              const target = calculateProgressForElapsedTime(elapsedSeconds);
              setGeneratingProgress(prev => {
                const next = new Map(prev);
                const current = prev.get(targetSlot.toString()) || 0;
                next.set(targetSlot.toString(), Math.floor(Math.max(current, target)));
                return next;
              });
            }
          } else if (statusData.status === "completed") {
            if (!jobCompletedMap.get(job.jobId)) {
              jobCompletedMap.set(job.jobId, true);
              completionStartTimes.set(job.jobId, Date.now());

              const currentProgressValue = progressRef.current.get(targetSlot.toString()) || 0;
              const animationDuration = calculateCompletionAnimationDuration(currentProgressValue);

              const animateToComplete = () => {
                const startTime = completionStartTimes.get(job.jobId) || Date.now();
                const elapsed = Date.now() - startTime;
                const ratio = Math.min(elapsed / animationDuration, 1);
                const easeOut = 1 - Math.pow(1 - ratio, 3);
                setGeneratingProgress(prev => {
                  const next = new Map(prev);
                  const start = currentProgressValue;
                  const target = start + (100 - start) * easeOut;
                  next.set(targetSlot.toString(), Math.floor(target));
                  return next;
                });
                if (ratio < 1) {
                  setTimeout(animateToComplete, 16);
                }
              };
              animateToComplete();
            }
          }

          return statusData;
        });

        const jobStatuses = await Promise.all(pollPromises);

        // 완료된 비디오 처리
        const completedJobs = jobStatuses.filter((j: unknown) => {
          const job = j as { status: string };
          return job.status === "completed";
        });
        if (completedJobs.length > 0) {
          const newVideos: GeneratedVideo[] = completedJobs.map((job: unknown) => {
            const typedJob = job as {
              jobId: string;
              result: {
                videoUrl: string;
                thumbnailUrl: string;
                isFavorite?: boolean;
              };
              createdAt: string;
              modelType: string;
            };
            return {
              id: typedJob.jobId,
              url: typedJob.result.videoUrl,
              thumbnail: typedJob.result.thumbnailUrl,
              createdAt: new Date(typedJob.createdAt),
              modelType: typedJob.modelType as "seedance" | "hailo",
              isFavorite: typedJob.result.isFavorite || false,
            };
          });
          if (newVideos.length > 0) {
            slotManager.placeVideoInSlot(targetSlot, newVideos[0]);
            onVideoCompleted?.(newVideos[0], targetSlot);
          }
        }

        // 진행 중 작업 여부
        const processingJobs = jobStatuses.filter((j: unknown) => {
          const job = j as { status: string };
          return job.status === "pending" || job.status === "processing";
        });
        if (processingJobs.length > 0) {
          setTimeout(() => pollJobs(targetSlot), 3000);
        } else {
          // cleanup
          setGeneratingSlots(prev => {
            const next = new Set(prev);
            next.delete(targetSlot);
            if (next.size === 0) setIsGenerating(false);
            return next;
          });
          setGeneratingProgress(prev => {
            const next = new Map(prev);
            next.delete(targetSlot.toString());
            return next;
          });
          setGeneratingJobIds(prev => {
            const next = new Map(prev);
            next.delete(targetSlot.toString());
            return next;
          });

          const failedJobs = jobStatuses.filter((j: unknown) => {
            const job = j as { status: string };
            return job.status === "failed";
          });
          if (failedJobs.length === jobStatuses.length) {
            setGenerationError("All video generation attempts failed.");
            slotManager.resetSlot(targetSlot);
          }
        }
      };

      setTimeout(() => pollJobs(availableSlot), 3000);
    } catch (error: unknown) {
      console.error("Video generation error:", error);
      const errorMessage = error instanceof Error ? error.message : "An error occurred during video generation.";
      setGenerationError(errorMessage);

      // 해당 슬롯만 롤백/정리
      slotManager.resetSlot(availableSlot);
      setGeneratingSlots(prev => {
        const next = new Set(prev);
        next.delete(availableSlot);
        if (next.size === 0) setIsGenerating(false);
        return next;
      });
      setGeneratingProgress(prev => {
        const next = new Map(prev);
        next.delete(availableSlot.toString());
        return next;
      });
      setGeneratingJobIds(prev => {
        const next = new Map(prev);
        next.delete(availableSlot.toString());
        return next;
      });
    }
  }, [getCurrentImage, selectedEffects, promptText, selectedDuration, slotManager, onVideoCompleted]);

  return {
    isGenerating,
    generatingProgress,
    generatingJobIds,
    generatingSlots,
    generationError,
    canGenerate,
    isSlotGenerating,
    generateVideo,
    setGenerationError,
  } as const;
}
</file>

<file path="app/canvas/_services/api.ts">
import type { 
  FavoritesApiResponse, 
  ToggleFavoriteRequest, 
  ToggleFavoriteResponse 
} from '../_types'
import type { GeneratedVideo } from '@/types/canvas'

/**
 * Canvas 페이지의 모든 API 호출을 담당하는 서비스 레이어
 * 비즈니스 로직과 API 통신을 분리하여 테스트 가능성과 유지보수성 향상
 */
export class CanvasAPI {
  /**
   * 사용자의 즐겨찾기 목록을 가져옴
   */
  static async loadFavorites(): Promise<string[]> {
    const response = await fetch('/api/canvas/favorites', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Failed to fetch favorites: ${response.status} ${response.statusText}`)
    }

    const data: FavoritesApiResponse = await response.json()
    
    if (data.error) {
      throw new Error(data.error)
    }

    return data.favoriteIds || []
  }

  /**
   * 비디오의 즐겨찾기 상태를 토글
   */
  static async toggleFavorite(videoId: string, isFavorite: boolean): Promise<void> {
    const request: ToggleFavoriteRequest = {
      videoId,
      isFavorite,
    }

    const response = await fetch('/api/canvas/favorite', {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    })

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}))
      throw new Error(
        errorData.error || `Failed to toggle favorite: ${response.status} ${response.statusText}`
      )
    }

    const data: ToggleFavoriteResponse = await response.json()
    
    if (!data.success && data.error) {
      throw new Error(data.error)
    }
  }

  /**
   * 비디오 파일 다운로드
   */
  static async downloadVideo(video: GeneratedVideo): Promise<Blob> {
    if (!video.url) {
      throw new Error('Video URL is not available')
    }

    const response = await fetch(video.url)

    if (!response.ok) {
      throw new Error(`Failed to download video: ${response.status} ${response.statusText}`)
    }

    return await response.blob()
  }

  /**
   * 비디오 다운로드 및 로컬 저장
   */
  static async downloadAndSaveVideo(
    video: GeneratedVideo,
    effectName?: string
  ): Promise<void> {
    const blob = await this.downloadVideo(video)
    
    // 파일명 생성: voguedrop_날짜_효과명.mp4
    const date = new Date(video.createdAt).toISOString().split('T')[0]
    const effect = effectName?.toLowerCase().replace(/\s+/g, '-') || 'video'
    const filename = `voguedrop_${date}_${effect}.mp4`

    // Blob을 다운로드
    const url = window.URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.style.display = 'none'
    link.href = url
    link.download = filename
    
    document.body.appendChild(link)
    link.click()
    
    // 정리
    window.URL.revokeObjectURL(url)
    document.body.removeChild(link)
  }

  /**
   * 비디오 생성 작업 상태 확인
   */
  static async checkJobStatus(jobId: string): Promise<{ status: string; progress?: number }> {
    const response = await fetch(`/api/canvas/jobs/${jobId}/poll`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Failed to check job status: ${response.status} ${response.statusText}`)
    }

    return await response.json()
  }

  /**
   * 생성된 비디오 목록 가져오기
   */
  static async getGeneratedVideos(userId?: string): Promise<GeneratedVideo[]> {
    const params = new URLSearchParams()
    if (userId) {
      params.append('userId', userId)
    }

    const response = await fetch(`/api/canvas/videos?${params.toString()}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    })

    if (!response.ok) {
      throw new Error(`Failed to fetch videos: ${response.status} ${response.statusText}`)
    }

    const data = await response.json()
    return data.videos || []
  }
}
</file>

<file path="app/video-editor/_components/PlayerControls.tsx">
import React from 'react';

interface PlayerControlsProps {
  isPlaying: boolean;
  currentTime: number;
  duration: number;
  volume: number;
  isMuted: boolean;
  isReady: boolean;
  onPlayPause: () => void;
  onSeek: (time: number) => void;
  onVolumeChange: (volume: number) => void;
  onMuteToggle: () => void;
}

const formatTime = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

export function PlayerControls({
  isPlaying,
  currentTime,
  duration,
  volume,
  isMuted,
  isReady,
  onPlayPause,
  onSeek,
  onVolumeChange,
  onMuteToggle,
}: PlayerControlsProps) {
  const progress = duration > 0 ? (currentTime / duration) * 100 : 0;
  const volumeProgress = isMuted ? 0 : volume * 100;

  const handleSeekChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onSeek(parseFloat(e.target.value));
  };

  const handleVolumeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    onVolumeChange(parseFloat(e.target.value));
  };

  return (
    <div className="bg-gray-800 p-4 relative z-[10000] flex-shrink-0">
      <div className="flex flex-col gap-3">
        {/* 진행 바 */}
        <div className="flex items-center gap-3">
          <span className="text-white text-sm min-w-[50px]">
            {formatTime(currentTime)}
          </span>
          <input
            type="range"
            min="0"
            max={duration}
            value={currentTime}
            onChange={handleSeekChange}
            disabled={!isReady}
            className="flex-1 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
            style={{
              background: `linear-gradient(to right, #38f47cf9 ${progress}%, #4b5563 ${progress}%)`
            }}
          />
          <span className="text-white text-sm min-w-[50px] text-right">
            {formatTime(duration)}
          </span>
        </div>
        
        {/* 컨트롤 버튼들 */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            {/* 재생/일시정지 버튼 */}
            <button
              onClick={onPlayPause}
              disabled={!isReady}
              className={`p-3 rounded-full transition-colors ${
                isReady 
                  ? 'bg-[#38f47cf9] hover:bg-[#38f47cf9]/80 cursor-pointer' 
                  : 'bg-gray-600 cursor-not-allowed opacity-50'
              }`}
              title={!isReady ? 'Rendering in progress...' : ''}
            >
              <i className={`${isPlaying ? 'ri-pause-fill' : 'ri-play-fill'} text-2xl ${
                isReady ? 'text-black' : 'text-gray-400'
              }`}></i>
            </button>
            
            {/* 볼륨 컨트롤 */}
            <div className="flex items-center gap-2">
              <button
                onClick={onMuteToggle}
                className="p-2 text-white hover:text-[#38f47cf9] transition-colors"
              >
                <i className={`${
                  isMuted ? 'ri-volume-mute-fill' : 'ri-volume-up-fill'
                } text-xl`}></i>
              </button>
              <input
                type="range"
                min="0"
                max="1"
                step="0.1"
                value={isMuted ? 0 : volume}
                onChange={handleVolumeChange}
                className="w-24 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer volume-slider"
                style={{
                  background: `linear-gradient(to right, #38f47cf9 ${volumeProgress}%, #4b5563 ${volumeProgress}%)`
                }}
              />
            </div>
          </div>
          
          {/* 우측 정보 */}
          <div className="text-white text-sm">
            <span className="text-gray-400">Fullscreen Preview</span>
          </div>
        </div>
      </div>

      <style jsx>{`
        .slider::-webkit-slider-thumb {
          appearance: none;
          width: 16px;
          height: 16px;
          background: #38f47cf9;
          border-radius: 50%;
          cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
          width: 16px;
          height: 16px;
          background: #38f47cf9;
          border-radius: 50%;
          cursor: pointer;
          border: none;
        }

        .volume-slider::-webkit-slider-thumb {
          appearance: none;
          width: 12px;
          height: 12px;
          background: #38f47cf9;
          border-radius: 50%;
          cursor: pointer;
        }
        
        .volume-slider::-moz-range-thumb {
          width: 12px;
          height: 12px;
          background: #38f47cf9;
          border-radius: 50%;
          cursor: pointer;
          border: none;
        }
      `}</style>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/RenderingModal.tsx">
'use client';

import { useEffect } from 'react';

interface RenderingModalProps {
  isOpen: boolean;
  onClose: () => void;
  renderProgress: number;
  renderComplete: boolean;
  renderOutputUrl: string | null;
}

export default function RenderingModal({
  isOpen,
  onClose,
  renderProgress,
  renderComplete,
  renderOutputUrl
}: RenderingModalProps) {
  // ESC 키로 모달 닫기
  useEffect(() => {
    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && renderComplete) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      // 모달이 열릴 때 body 스크롤 방지
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, renderComplete, onClose]);

  if (!isOpen) return null;

  const handleDownload = () => {
    if (renderOutputUrl) {
      const link = document.createElement('a');
      link.href = renderOutputUrl;
      link.download = `video-${Date.now()}.mp4`;
      link.target = '_blank';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      {/* 배경 오버레이 */}
      <div 
        className="absolute inset-0 bg-black/80 backdrop-blur-sm"
        onClick={renderComplete ? onClose : undefined}
      />
      
      {/* 모달 컨텐츠 */}
      <div className="relative z-10 mx-auto max-w-md">
        <div className="flex flex-col items-center gap-4 p-8 bg-gray-900/95 rounded-2xl backdrop-blur-md border border-gray-700 shadow-2xl">
          {renderComplete ? (
            <>
              {/* 렌더링 완료 */}
              <button
                onClick={onClose}
                className="absolute top-4 right-4 w-8 h-8 flex items-center justify-center rounded-full bg-gray-800 hover:bg-gray-700 transition-colors"
              >
                <i className="ri-close-line text-white text-lg"></i>
              </button>
              
              <div className="relative">
                <div className="w-20 h-20 bg-gradient-to-r from-[#38f47cf9] to-[#4affb0] rounded-full flex items-center justify-center animate-pulse">
                  <i className="ri-check-line text-4xl text-white"></i>
                </div>
              </div>
              
              <div className="text-center">
                <p className="text-white text-xl font-medium mb-2">Rendering Complete!</p>
                <p className="text-gray-400 text-sm mb-6">Your video is ready to download</p>
              </div>
              
              <button
                onClick={handleDownload}
                className="px-6 py-3 bg-[#38f47cf9] text-black rounded-xl hover:bg-[#4affb0] transition-colors text-base font-medium flex items-center gap-2"
              >
                <i className="ri-download-line text-xl"></i>
                Download Video
              </button>
              
              <button
                onClick={onClose}
                className="mt-2 px-6 py-2 text-gray-400 hover:text-white transition-colors text-sm"
              >
                Close
              </button>
            </>
          ) : (
            <>
              {/* 렌더링 진행 중 */}
              <div className="relative">
                <div className="w-20 h-20 border-4 border-gray-600 border-t-[#38f47cf9] rounded-full animate-spin"></div>
                <i className="ri-vidicon-line text-3xl text-[#38f47cf9] absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"></i>
              </div>
              
              <div className="text-center">
                <p className="text-white text-xl font-medium mb-2">
                  Rendering Video...
                </p>
                <p className="text-gray-400 text-sm">Please wait, this may take a few minutes</p>
              </div>
              
              {/* 진행률 바 */}
              <div className="w-80">
                <div className="flex justify-between text-xs text-gray-400 mb-2">
                  <span>Progress</span>
                  <span>{renderProgress}%</span>
                </div>
                <div className="h-2 bg-gray-700 rounded-full overflow-hidden">
                  <div 
                    className="h-full bg-gradient-to-r from-[#38f47cf9] to-[#4affb0] transition-all duration-500 ease-out"
                    style={{ width: `${renderProgress}%` }}
                  />
                </div>
              </div>
              
              {/* 상태 메시지 */}
              <p className="text-xs text-gray-500 text-center">
                {renderProgress < 30 
                  ? 'Initializing render engine...' 
                  : renderProgress < 50
                    ? 'Processing video frames...'
                    : renderProgress < 70 
                      ? 'Applying effects and transitions...' 
                      : renderProgress < 90
                        ? 'Encoding video...'
                        : 'Finalizing output...'}
              </p>
              
              {/* 취소 불가 안내 */}
              <p className="text-xs text-gray-600 text-center mt-2">
                Please do not close this window
              </p>
            </>
          )}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/SoundGenerationProgress.tsx">
import React, { useEffect, useRef } from 'react';

interface SoundGenerationProgressProps {
  progress: number;
  isVisible: boolean;
  jobId?: string;
}

export function SoundGenerationProgress({ 
  progress, 
  isVisible,
  jobId
}: SoundGenerationProgressProps) {
  const previousProgressRef = useRef(progress);
  const startTimeRef = useRef<number>(Date.now());
  
  // Progress 변화 시 로깅
  useEffect(() => {
    if (isVisible && progress !== previousProgressRef.current) {
      previousProgressRef.current = progress;
    }
  }, [progress, isVisible, jobId]);
  
  // 컴포넌트 마운트 시 시작 시간 초기화
  useEffect(() => {
    if (isVisible) {
      startTimeRef.current = Date.now();
    }
  }, [isVisible]);
  
  if (!isVisible) return null;

  return (
    <div className="absolute inset-0 z-30 bg-black/60 flex items-center justify-center">
      {/* Progress bar container - 상단 진행 바 */}
      <div className="absolute top-0 left-0 right-0 h-2 bg-gray-800/80">
        <div 
          className="h-full bg-green-500 transition-all duration-500 ease-out relative overflow-hidden"
          style={{ width: `${progress}%` }}
        >
          {/* Animated shine effect */}
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/30 to-transparent w-1/2 -skew-x-12 animate-shimmer" />
        </div>
      </div>
      
      {/* Progress info container - 중앙 퍼센트 표시 */}
      <div className="text-center">
        {/* Percentage display with shadow for better visibility */}
        <div className="text-white text-7xl font-bold drop-shadow-2xl">
          {Math.round(progress)}%
        </div>
        <div className="text-white/70 text-lg mt-4">
          Generating sound...
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/TimelinePlayhead.tsx">
'use client';

import { useRef } from 'react';

interface TimelinePlayheadProps {
  position: number; // in pixels
  height?: string;
  onMouseDown: (e: React.MouseEvent) => void;
}

/**
 * Timeline playhead component
 * Displays the current playback position indicator
 */
export default function TimelinePlayhead({ 
  position, 
  height = '100%',
  onMouseDown 
}: TimelinePlayheadProps) {
  const playheadRef = useRef<HTMLDivElement>(null);

  return (
    <div
      ref={playheadRef}
      className="absolute"
      style={{
        top: '0',
        bottom: '0',
        left: `${position}px`,
        zIndex: 40,
        width: '13px', // Draggable area width
        cursor: 'ew-resize',
        height,
      }}
      onMouseDown={onMouseDown}
    >
      {/* Actual red line */}
      <div 
        className="absolute top-0 bottom-0 w-0.5 bg-red-500"
        style={{
          left: '50%',
          transform: 'translateX(-50%)',
          boxShadow: '0 0 6px rgba(239, 68, 68, 0.8)',
          pointerEvents: 'none'
        }}
      />
      {/* Playhead top triangle marker */}
      <div className="absolute -top-2 left-1/2 transform -translate-x-1/2">
        <div className="w-0 h-0 border-l-[7px] border-l-transparent border-r-[7px] border-r-transparent border-t-[10px] border-t-red-500"></div>
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/TimelineSelectionBox.tsx">
'use client';

interface SelectionBoxProps {
  left: number;
  top: number;
  width: number;
  height: number;
  isActive?: boolean;
  onMouseDown?: (e: React.MouseEvent<HTMLDivElement>) => void;
  onResizeStart?: (e: React.MouseEvent<HTMLDivElement>, handle: 'left' | 'right' | 'top' | 'bottom') => void;
}

/**
 * Timeline selection box component
 * Displays range selection overlay with resize handles
 */
export default function TimelineSelectionBox({
  left,
  top,
  width,
  height,
  isActive = false,
  onMouseDown,
  onResizeStart,
}: SelectionBoxProps) {
  const baseClassName = isActive 
    ? "absolute bg-red-500/10 border border-red-400"
    : "absolute bg-red-500/20 border border-red-400/60 pointer-events-none";

  return (
    <div
      className={baseClassName}
      style={{ 
        left: `${left}px`, 
        top: `${top}px`, 
        width: `${width}px`, 
        height: `${height}px`, 
        zIndex: isActive ? 41 : 40 
      }}
      onMouseDown={onMouseDown}
    >
      {isActive && onResizeStart && (
        <>
          {/* Left resize handle */}
          <div
            className="absolute inset-y-0 left-0 w-1 bg-red-400 cursor-ew-resize"
            onMouseDown={(e) => onResizeStart(e, 'left')}
          />
          {/* Right resize handle */}
          <div
            className="absolute inset-y-0 right-0 w-1 bg-red-400 cursor-ew-resize"
            onMouseDown={(e) => onResizeStart(e, 'right')}
          />
          {/* Top resize handle */}
          <div
            className="absolute inset-x-0 top-0 h-1 bg-red-400 cursor-ns-resize"
            onMouseDown={(e) => onResizeStart(e, 'top')}
          />
          {/* Bottom resize handle */}
          <div
            className="absolute inset-x-0 bottom-0 h-1 bg-red-400 cursor-ns-resize"
            onMouseDown={(e) => onResizeStart(e, 'bottom')}
          />
        </>
      )}
    </div>
  );
}
</file>

<file path="app/video-editor/_hooks/useDragAndDrop.ts">
import { useState } from 'react';

/**
 * Drag and drop state management hook
 * Manages dragging and resizing operations for timeline clips
 */
export function useDragAndDrop() {
  // Drag state
  const [isDragging, setIsDragging] = useState(false);
  const [dragStartX, setDragStartX] = useState(0);
  const [initialDragX, setInitialDragX] = useState(0);
  const [dragDirection, setDragDirection] = useState<'left' | 'right'>('right');
  
  // Resize state
  const [isResizing, setIsResizing] = useState(false);
  const [resizeHandle, setResizeHandle] = useState<'left' | 'right' | null>(null);
  const [startWidth, setStartWidth] = useState(0);
  const [startPosition, setStartPosition] = useState(0);
  const [resizeMoved, setResizeMoved] = useState(false);
  const [finalResizeWidth, setFinalResizeWidth] = useState(0);
  const [finalResizePosition, setFinalResizePosition] = useState(0);
  
  // Playhead drag state
  const [isDraggingPlayhead, setIsDraggingPlayhead] = useState(false);
  
  const RESIZE_ACTIVATION_DELTA = 10;

  // Start dragging operation
  const startDrag = (clientX: number) => {
    setIsDragging(true);
    setInitialDragX(clientX);
    setDragStartX(clientX);
  };

  // Start resize operation
  const startResize = (
    clientX: number, 
    handle: 'left' | 'right',
    currentWidth: number,
    currentPosition: number
  ) => {
    setIsResizing(true);
    setResizeHandle(handle);
    setDragStartX(clientX);
    setResizeMoved(false);
    setStartWidth(currentWidth);
    setStartPosition(currentPosition);
    setFinalResizeWidth(currentWidth);
    setFinalResizePosition(currentPosition);
  };

  // Reset drag state
  const resetDragState = () => {
    setIsDragging(false);
    setIsResizing(false);
    setResizeHandle(null);
    setResizeMoved(false);
    setFinalResizeWidth(0);
    setFinalResizePosition(0);
  };

  // Update drag direction based on movement
  const updateDragDirection = (currentX: number) => {
    const totalDelta = currentX - initialDragX;
    setDragDirection(totalDelta >= 0 ? 'right' : 'left');
  };

  // Check if resize threshold is met
  const checkResizeActivation = (currentX: number): boolean => {
    const delta = Math.abs(currentX - dragStartX);
    if (!resizeMoved && delta > RESIZE_ACTIVATION_DELTA) {
      setResizeMoved(true);
      return true;
    }
    return resizeMoved;
  };

  return {
    // Drag state
    isDragging,
    dragStartX,
    initialDragX,
    dragDirection,
    
    // Resize state
    isResizing,
    resizeHandle,
    startWidth,
    startPosition,
    resizeMoved,
    finalResizeWidth,
    finalResizePosition,
    
    // Playhead state
    isDraggingPlayhead,
    setIsDraggingPlayhead,
    
    // Actions
    startDrag,
    startResize,
    resetDragState,
    updateDragDirection,
    checkResizeActivation,
    setFinalResizeWidth,
    setFinalResizePosition,
  };
}
</file>

<file path="app/video-editor/_hooks/useSelectionState.ts">
import { useState, useRef } from 'react';

/**
 * Selection box state management hook
 * Manages range selection (Shift+drag) functionality
 */
export function useSelectionState() {
  // Selection container ref
  const selectionContainerRef = useRef<HTMLDivElement>(null);
  
  // Active selection drawing state
  const [isSelectingRange, setIsSelectingRange] = useState(false);
  const [selectionStartX, setSelectionStartX] = useState<number | null>(null);
  const [selectionCurrentX, setSelectionCurrentX] = useState<number | null>(null);
  const [selectionStartY, setSelectionStartY] = useState<number | null>(null);
  const [selectionCurrentY, setSelectionCurrentY] = useState<number | null>(null);
  
  // Persistent selection state (after mouse up)
  const [isRangeActive, setIsRangeActive] = useState(false);
  const [selectionRangeStartX, setSelectionRangeStartX] = useState<number | null>(null);
  const [selectionRangeEndX, setSelectionRangeEndX] = useState<number | null>(null);
  const [selectionRangeStartY, setSelectionRangeStartY] = useState<number | null>(null);
  const [selectionRangeEndY, setSelectionRangeEndY] = useState<number | null>(null);
  
  // Selection resize state
  const [isAdjustingSelection, setIsAdjustingSelection] = useState(false);
  const [selectionResizeHandle, setSelectionResizeHandle] = useState<'left' | 'right' | 'top' | 'bottom' | null>(null);
  const [selectionDragStartClientX, setSelectionDragStartClientX] = useState(0);
  const [selectionDragStartClientY, setSelectionDragStartClientY] = useState(0);
  const [selectionInitialStartX, setSelectionInitialStartX] = useState(0);
  const [selectionInitialEndX, setSelectionInitialEndX] = useState(0);
  const [selectionInitialStartY, setSelectionInitialStartY] = useState(0);
  const [selectionInitialEndY, setSelectionInitialEndY] = useState(0);
  
  // Selection move state
  const [isMovingSelection, setIsMovingSelection] = useState(false);
  const [moveStartClientX, setMoveStartClientX] = useState(0);
  const [moveStartClientY, setMoveStartClientY] = useState(0);
  const [moveInitialStartX, setMoveInitialStartX] = useState(0);
  const [moveInitialEndX, setMoveInitialEndX] = useState(0);
  const [moveInitialStartY, setMoveInitialStartY] = useState(0);
  const [moveInitialEndY, setMoveInitialEndY] = useState(0);

  // Start selection
  const startSelection = (x: number, y: number) => {
    setIsRangeActive(false);
    setSelectionRangeStartX(null);
    setSelectionRangeEndX(null);
    setSelectionRangeStartY(null);
    setSelectionRangeEndY(null);
    setIsSelectingRange(true);
    setSelectionStartX(x);
    setSelectionCurrentX(x);
    setSelectionStartY(y);
    setSelectionCurrentY(y);
  };

  // Update selection while dragging
  const updateSelection = (x: number, y: number) => {
    setSelectionCurrentX(x);
    setSelectionCurrentY(y);
  };

  // End selection
  const endSelection = () => {
    setIsSelectingRange(false);
    setSelectionStartX(null);
    setSelectionCurrentX(null);
    setSelectionStartY(null);
    setSelectionCurrentY(null);
    setIsRangeActive(false);
    setSelectionRangeStartX(null);
    setSelectionRangeEndX(null);
    setSelectionRangeStartY(null);
    setSelectionRangeEndY(null);
  };

  // Start adjusting selection box
  const startAdjustSelection = (
    e: React.MouseEvent<HTMLDivElement>,
    handle: 'left' | 'right' | 'top' | 'bottom'
  ) => {
    e.preventDefault();
    e.stopPropagation();
    if (!isRangeActive) return;
    
    setIsAdjustingSelection(true);
    setSelectionResizeHandle(handle);
    setSelectionDragStartClientX(e.clientX);
    setSelectionDragStartClientY(e.clientY);
    setSelectionInitialStartX(selectionRangeStartX || 0);
    setSelectionInitialEndX(selectionRangeEndX || 0);
    setSelectionInitialStartY(selectionRangeStartY || 0);
    setSelectionInitialEndY(selectionRangeEndY || 0);
  };

  // Start moving selection box
  const startMoveSelection = (e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    if (!isRangeActive) return;
    
    setIsMovingSelection(true);
    setMoveStartClientX(e.clientX);
    setMoveStartClientY(e.clientY);
    setMoveInitialStartX(selectionRangeStartX || 0);
    setMoveInitialEndX(selectionRangeEndX || 0);
    setMoveInitialStartY(selectionRangeStartY || 0);
    setMoveInitialEndY(selectionRangeEndY || 0);
  };

  // Reset all selection states
  const resetSelection = () => {
    setIsSelectingRange(false);
    setIsAdjustingSelection(false);
    setIsMovingSelection(false);
    setSelectionResizeHandle(null);
    endSelection();
  };

  // Calculate selection bounds
  const getSelectionBounds = () => {
    if (isSelectingRange && selectionStartX !== null && selectionCurrentX !== null && 
        selectionStartY !== null && selectionCurrentY !== null) {
      return {
        left: Math.min(selectionStartX, selectionCurrentX),
        right: Math.max(selectionStartX, selectionCurrentX),
        top: Math.min(selectionStartY, selectionCurrentY),
        bottom: Math.max(selectionStartY, selectionCurrentY),
        width: Math.abs(selectionCurrentX - selectionStartX),
        height: Math.abs(selectionCurrentY - selectionStartY),
      };
    }
    
    if (isRangeActive && selectionRangeStartX !== null && selectionRangeEndX !== null &&
        selectionRangeStartY !== null && selectionRangeEndY !== null) {
      return {
        left: Math.min(selectionRangeStartX, selectionRangeEndX),
        right: Math.max(selectionRangeStartX, selectionRangeEndX),
        top: Math.min(selectionRangeStartY, selectionRangeEndY),
        bottom: Math.max(selectionRangeStartY, selectionRangeEndY),
        width: Math.abs(selectionRangeEndX - selectionRangeStartX),
        height: Math.abs(selectionRangeEndY - selectionRangeStartY),
      };
    }
    
    return null;
  };

  return {
    // Refs
    selectionContainerRef,
    
    // Selection state
    isSelectingRange,
    selectionStartX,
    selectionCurrentX,
    selectionStartY,
    selectionCurrentY,
    
    // Active selection state
    isRangeActive,
    selectionRangeStartX,
    selectionRangeEndX,
    selectionRangeStartY,
    selectionRangeEndY,
    
    // Adjustment state
    isAdjustingSelection,
    selectionResizeHandle,
    selectionDragStartClientX,
    selectionDragStartClientY,
    selectionInitialStartX,
    selectionInitialEndX,
    selectionInitialStartY,
    selectionInitialEndY,
    
    // Move state
    isMovingSelection,
    moveStartClientX,
    moveStartClientY,
    moveInitialStartX,
    moveInitialEndX,
    moveInitialStartY,
    moveInitialEndY,
    
    // Actions
    startSelection,
    updateSelection,
    endSelection,
    startAdjustSelection,
    startMoveSelection,
    resetSelection,
    getSelectionBounds,
    
    // Setters for complex operations
    setSelectionRangeStartX,
    setSelectionRangeEndX,
    setSelectionRangeStartY,
    setSelectionRangeEndY,
    setIsAdjustingSelection,
    setIsMovingSelection,
    setSelectionResizeHandle,
  };
}
</file>

<file path="app/video-editor/_hooks/useTimelineResize.ts">
import { useState, useEffect, useRef, useCallback } from 'react';
import { TIMELINE_CONFIG } from '../_constants';

interface UseTimelineResizeOptions {
  defaultHeight?: number;
  minHeight?: number;
  maxHeight?: number;
}

export function useTimelineResize(options?: UseTimelineResizeOptions) {
  const {
    defaultHeight = TIMELINE_CONFIG.DEFAULT_HEIGHT,
    minHeight = TIMELINE_CONFIG.MIN_HEIGHT,
    maxHeight = TIMELINE_CONFIG.MAX_HEIGHT
  } = options || {};

  const [timelineHeight, setTimelineHeight] = useState(defaultHeight);
  const [isResizing, setIsResizing] = useState(false);
  const [dragStartY, setDragStartY] = useState(0);
  const [initialHeight, setInitialHeight] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  const handleResizerMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
    setDragStartY(e.clientY);
    setInitialHeight(timelineHeight);
  }, [timelineHeight]);

  useEffect(() => {
    if (!isResizing) return;

    const handleMouseMove = (e: MouseEvent) => {
      // 드래그 시작점 대비 상대적 변화량 계산 (위로 드래그하면 음수)
      const deltaY = dragStartY - e.clientY;
      const newHeight = initialHeight + deltaY;
      
      setTimelineHeight(Math.min(maxHeight, Math.max(minHeight, newHeight)));
    };

    const handleMouseUp = () => {
      setIsResizing(false);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    document.body.style.cursor = 'ns-resize';
    
    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
      document.body.style.cursor = '';
    };
  }, [isResizing, dragStartY, initialHeight, minHeight, maxHeight]);

  const getResizerCursor = () => {
    return timelineHeight >= maxHeight ? 'cursor-s-resize' : 'cursor-ns-resize';
  };

  const getResizerTitle = () => {
    return timelineHeight >= maxHeight 
      ? "드래그하여 타임라인 축소" 
      : "드래그하여 타임라인 크기 조정";
  };

  return {
    timelineHeight,
    isResizing,
    containerRef,
    handleResizerMouseDown,
    getResizerCursor,
    getResizerTitle
  };
}
</file>

<file path="app/video-editor/_hooks/useTimelineState.ts">
import { useState } from 'react';

/**
 * Core timeline state management hook
 * Manages active clips, selection, and playback state
 */
export function useTimelineState() {
  // Active clip state (currently being dragged/resized)
  const [activeClip, setActiveClip] = useState<string | null>(null);
  const [activeClipType, setActiveClipType] = useState<'video' | 'text' | 'sound' | null>(null);
  
  // Selected clip state (for toolbar actions)
  const [selectedClip, setSelectedClip] = useState<string | null>(null);
  const [selectedClipType, setSelectedClipType] = useState<'video' | 'text' | 'sound' | null>(null);
  
  // Multi-selection state
  const [rectSelectedClips, setRectSelectedClips] = useState<{ 
    id: string; 
    type: 'video' | 'text' | 'sound' 
  }[]>([]);

  // Clear all selections
  const clearSelection = () => {
    setSelectedClip(null);
    setSelectedClipType(null);
    setRectSelectedClips([]);
  };

  // Handle single clip selection
  const selectClip = (clipId: string, clipType: 'video' | 'text' | 'sound') => {
    if (rectSelectedClips.length > 0) {
      setRectSelectedClips([]);
    }
    setSelectedClip(clipId);
    setSelectedClipType(clipType);
  };

  // Set active clip for operations
  const setActiveClipInfo = (clipId: string | null, clipType: 'video' | 'text' | 'sound' | null) => {
    setActiveClip(clipId);
    setActiveClipType(clipType);
  };

  return {
    // State
    activeClip,
    activeClipType,
    selectedClip,
    selectedClipType,
    rectSelectedClips,
    
    // Actions
    setActiveClipInfo,
    selectClip,
    clearSelection,
    setRectSelectedClips,
  };
}
</file>

<file path="app/video-editor/_hooks/useVideoPlayback.ts">
import { useState, useEffect, useRef, useCallback } from 'react';
import { PlayerRef } from '@remotion/player';
import { VideoClip, TextClip, SoundClip } from '@/types/video-editor';
import { TIMELINE_CONFIG } from '../_constants';

interface UseVideoPlaybackProps {
  timelineClips: VideoClip[];
  textClips: TextClip[];
  soundClips: SoundClip[];
}

export function useVideoPlayback({ 
  timelineClips, 
  textClips, 
  soundClips 
}: UseVideoPlaybackProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const playerRef = useRef<PlayerRef | null>(null);
  const prevFrameRef = useRef<number>(0);

  const handlePlayPause = useCallback(() => {
    if (playerRef.current) {
      if (isPlaying) {
        playerRef.current.pause();
      } else {
        playerRef.current.play();
      }
    }
    setIsPlaying(!isPlaying);
  }, [isPlaying]);

  const handleSeek = useCallback((time: number) => {
    setCurrentTime(time);
    if (playerRef.current) {
      const frame = Math.round(time * TIMELINE_CONFIG.FPS);
      playerRef.current.seekTo(frame);
    }
  }, []);

  // Player 상태 폴링으로 시간 업데이트 및 재생 완료 감지
  useEffect(() => {
    if (!isPlaying || !playerRef.current) {
      prevFrameRef.current = 0;
      return;
    }
    
    // 총 프레임 계산
    const videoEnd = timelineClips.length > 0 
      ? Math.max(...timelineClips.map(c => (c.position || 0) + c.duration))
      : 0;
    const textEnd = textClips.length > 0
      ? Math.max(...textClips.map(c => (c.position || 0) + c.duration))
      : 0;
    const soundEnd = soundClips.length > 0
      ? Math.max(...soundClips.map(c => (c.position || 0) + c.duration))
      : 0;
    
    const totalPx = Math.max(videoEnd, textEnd, soundEnd);
    const totalSeconds = totalPx / TIMELINE_CONFIG.PIXELS_PER_SECOND;
    const totalFrames = Math.max(30, Math.round(totalSeconds * TIMELINE_CONFIG.FPS));
    
    const interval = setInterval(() => {
      if (playerRef.current) {
        const frame = playerRef.current.getCurrentFrame();
        const time = frame / TIMELINE_CONFIG.FPS;
        
        // Player가 끝에서 자동으로 0으로 리셋된 경우 감지
        if (prevFrameRef.current > totalFrames * 0.9 && frame < 10) {
          setIsPlaying(false);
          setCurrentTime(0);
          if (playerRef.current) {
            playerRef.current.pause();
          }
          prevFrameRef.current = 0;
          return;
        }
        
        // 재생이 거의 끝에 도달한 경우 (95% 이상)
        if (frame >= totalFrames * 0.95) {
          setIsPlaying(false);
          setCurrentTime(0);
          if (playerRef.current) {
            playerRef.current.pause();
            playerRef.current.seekTo(0);
          }
          prevFrameRef.current = 0;
          return;
        }
        
        // 정상 재생 중
        prevFrameRef.current = frame;
        setCurrentTime(time);
      }
    }, 100); // 100ms마다 업데이트
    
    return () => clearInterval(interval);
  }, [isPlaying, timelineClips, textClips, soundClips]);

  return {
    isPlaying,
    currentTime,
    playerRef,
    handlePlayPause,
    handleSeek,
    setIsPlaying
  };
}
</file>

<file path="app/video-editor/_hooks/useVideoSoundGeneration.ts">
import { useState, useCallback } from 'react';
import { VideoClip } from '@/types/video-editor';

interface JobProgress {
  jobId: string;
  variationNumber: number;
  progress: number;
  status: 'pending' | 'processing' | 'completed' | 'failed';
}

interface UseVideoSoundGenerationReturn {
  isGenerating: boolean;
  error: string | null;
  jobProgresses: JobProgress[];
  generateFromVideo: (clip: VideoClip, durationSeconds: number) => Promise<string[]>;
  pollJobStatus: (jobId: string) => Promise<{ status: string; [key: string]: unknown } | null>;
  clearError: () => void;
}

export function useVideoSoundGeneration(): UseVideoSoundGenerationReturn {
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [jobProgresses, setJobProgresses] = useState<JobProgress[]>([]);
  
  // 진행률 계산 함수
  const calculateProgressForElapsedTime = (elapsedSeconds: number, expectedDuration: number = 15): number => {
    const checkpoints = [
      { time: 2, progress: 15 },
      { time: 4, progress: 30 },
      { time: 6, progress: 50 },
      { time: 8, progress: 65 },
      { time: 10, progress: 80 },
      { time: 12, progress: 88 },
      { time: 15, progress: 90 }
    ];
    
    let targetProgress = 0;
    
    for (let i = 0; i < checkpoints.length; i++) {
      const checkpoint = checkpoints[i];
      const nextCheckpoint = checkpoints[i + 1];
      
      if (elapsedSeconds >= checkpoint.time) {
        if (!nextCheckpoint || elapsedSeconds < nextCheckpoint.time) {
          if (nextCheckpoint) {
            const timeRatio = (elapsedSeconds - checkpoint.time) / (nextCheckpoint.time - checkpoint.time);
            const progressDiff = nextCheckpoint.progress - checkpoint.progress;
            targetProgress = checkpoint.progress + (progressDiff * timeRatio);
          } else {
            targetProgress = checkpoint.progress;
          }
          break;
        }
      } else if (i === 0) {
        targetProgress = (elapsedSeconds / checkpoint.time) * checkpoint.progress;
        break;
      }
    }
    
    if (elapsedSeconds > expectedDuration) {
      const overtime = elapsedSeconds - expectedDuration;
      const slowdown = Math.log(1 + overtime / expectedDuration) * 2;
      targetProgress = Math.max(85, 90 - slowdown);
    }
    
    return Math.min(targetProgress, 90);
  };
  
  // Job 상태 조회
  const pollJobStatus = useCallback(async (jobId: string): Promise<{ status: string; [key: string]: unknown } | null> => {
    try {
      const response = await fetch(`/api/sound/jobs/${jobId}`);
      if (!response.ok) {
        throw new Error('Failed to fetch job status');
      }
      return await response.json();
    } catch (err) {
      console.error(`Failed to poll job ${jobId}:`, err);
      return null;
    }
  }, []);
  
  // 비디오 기반 음악 생성
  const generateFromVideo = useCallback(async (
    clip: VideoClip, 
    durationSeconds: number
  ): Promise<string[]> => {
    setIsGenerating(true);
    setError(null);
    setJobProgresses([]);
    
    try {
      // job_id 추출 (URL에서 추출하거나 메타데이터에서 가져오기)
      // VideoClip에 job_id가 없으므로, URL 기반으로 추출하거나 다른 식별자 사용
      const videoJobId = extractJobIdFromClip(clip);
      
      // 디버깅을 위한 로그
      console.log('VideoClip for sound generation:', {
        clipId: clip.id,
        clipUrl: clip.url,
        extractedJobId: videoJobId
      });
      
      if (!videoJobId) {
        throw new Error(`비디오 정보를 찾을 수 없습니다. (Clip ID: ${clip.id})`);
      }
      
      // API 호출 (프롬프트는 서버에서만 처리)
      const response = await fetch('/api/sound/generate-from-video', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          video_job_id: videoJobId,
          duration_seconds: durationSeconds,
        }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || '음악 생성에 실패했습니다.');
      }
      
      const { jobIds } = data;
      
      // Job 진행률 초기화
      const initialProgresses: JobProgress[] = jobIds.map((jobId: string, index: number) => ({
        jobId,
        variationNumber: index + 1,
        progress: 0,
        status: 'processing' as const
      }));
      
      setJobProgresses(initialProgresses);
      
      // 진행률 시뮬레이션
      const startTimes = new Map<string, number>();
      jobIds.forEach((jobId: string) => {
        startTimes.set(jobId, Date.now() + Math.random() * 2000);
      });
      
      const progressInterval = setInterval(() => {
        setJobProgresses(prevProgresses => 
          prevProgresses.map(job => {
            if (job.status === 'completed' || job.status === 'failed') return job;
            
            const startTime = startTimes.get(job.jobId) || Date.now();
            const elapsed = Math.max(0, (Date.now() - startTime) / 1000);
            const newProgress = calculateProgressForElapsedTime(elapsed, 15);
            
            return { ...job, progress: Math.floor(newProgress) };
          })
        );
      }, 500);
      
      // Job 상태 폴링
      const pollIntervals = new Map<string, NodeJS.Timeout>();
      const pollCounts = new Map<string, number>();
      const maxPolls = 60;
      const completedJobs: string[] = [];
      
      await new Promise<void>((resolve) => {
        jobIds.forEach((jobId: string) => {
          pollCounts.set(jobId, 0);
          
          const interval = setInterval(async () => {
            const currentPollCount = (pollCounts.get(jobId) || 0) + 1;
            pollCounts.set(jobId, currentPollCount);
            
            const status = await pollJobStatus(jobId);
            
            if (status?.status === 'completed') {
              clearInterval(interval);
              pollIntervals.delete(jobId);
              completedJobs.push(jobId);
              
              setJobProgresses(prev => 
                prev.map(j => j.jobId === jobId 
                  ? { ...j, status: 'completed', progress: 100 }
                  : j
                )
              );
              
              // 모든 job이 완료되었는지 확인
              if (completedJobs.length === jobIds.length || 
                  pollIntervals.size === 0) {
                clearInterval(progressInterval);
                resolve();
              }
            } else if (status?.status === 'failed' || currentPollCount >= maxPolls) {
              clearInterval(interval);
              pollIntervals.delete(jobId);
              
              setJobProgresses(prev => 
                prev.map(j => j.jobId === jobId 
                  ? { ...j, status: 'failed', progress: 0 }
                  : j
                )
              );
              
              if (pollIntervals.size === 0) {
                clearInterval(progressInterval);
                resolve();
              }
            }
          }, 2000);
          
          pollIntervals.set(jobId, interval);
        });
      });
      
      // 완료된 job ID 반환
      return completedJobs;
      
    } catch (err) {
      console.error('Video-based sound generation error:', err);
      setError(err instanceof Error ? err.message : '음악 생성 중 오류가 발생했습니다.');
      return [];
    } finally {
      setIsGenerating(false);
    }
  }, [pollJobStatus]);
  
  const clearError = useCallback(() => {
    setError(null);
  }, []);
  
  return {
    isGenerating,
    error,
    jobProgresses,
    generateFromVideo,
    pollJobStatus,
    clearError,
  };
}

// VideoClip에서 job_id 추출하는 헬퍼 함수
function extractJobIdFromClip(clip: VideoClip): string | null {
  // clip.id에서 job_id 추출 (형식: "clip-{job_id}-{timestamp}-{index}")
  if (clip.id && clip.id.startsWith('clip-')) {
    // job_id는 "job_"로 시작하고 그 뒤에 문자/숫자/언더스코어/하이픈이 올 수 있음
    // nanoid는 URL-safe 문자를 사용: A-Za-z0-9_-
    const jobIdMatch = clip.id.match(/clip-(job_[a-zA-Z0-9_-]+)-\d+-\d+/);
    if (jobIdMatch && jobIdMatch[1]) {
      console.log('Extracted job_id from clip.id:', jobIdMatch[1]);
      return jobIdMatch[1]; // "job_xxxxx" 반환
    }
    
    // 레거시 형식 지원: clip-job_xxxxx (timestamp와 index 없는 경우)
    const legacyMatch = clip.id.match(/clip-(job_[a-zA-Z0-9_-]+)/);
    if (legacyMatch && legacyMatch[1]) {
      console.log('Extracted job_id from legacy clip.id:', legacyMatch[1]);
      return legacyMatch[1];
    }
  }
  
  // URL에서 job_id 추출 시도 (fallback)
  if (clip.url) {
    const match = clip.url.match(/job_[a-zA-Z0-9_-]+/);
    if (match) {
      console.log('Extracted job_id from URL:', match[0]);
      return match[0]; // "job_xyz123" 형태로 반환
    }
  }
  
  // clip.id가 직접 job_id인 경우 (레거시 지원)
  if (clip.id && clip.id.startsWith('job_')) {
    console.log('Using clip.id as job_id directly:', clip.id);
    return clip.id;
  }
  
  console.error('Failed to extract job_id from clip:', {
    clipId: clip.id,
    clipUrl: clip.url
  });
  
  // fallback: null 반환
  return null;
}
</file>

<file path="app/video-editor/_types/timeline-props.ts">
import { VideoClip, TextClip, SoundClip } from '@/types/video-editor';

/**
 * Grouped timeline props for better organization
 */

// Clip data props
export interface TimelineClipsProps {
  clips: VideoClip[];
  textClips: TextClip[];
  soundClips: SoundClip[];
}

// Clip manipulation callbacks
export interface TimelineClipCallbacks {
  // Add callbacks
  onAddClip: () => void;
  onAddText?: () => void;
  onAddSound?: () => void;
  
  // Edit callbacks
  onEditTextClip?: (clip: TextClip) => void;
  onEditSoundClip?: (clip: SoundClip) => void;
  
  // Delete callbacks
  onDeleteVideoClip?: (id: string) => void;
  onDeleteTextClip?: (id: string) => void;
  onDeleteSoundClip?: (id: string) => void;
  
  // Duplicate callbacks
  onDuplicateVideoClip?: (id: string) => void;
  onDuplicateTextClip?: (id: string) => void;
  onDuplicateSoundClip?: (id: string) => void;
  
  // Split callbacks
  onSplitVideoClip?: (id: string) => void;
  onSplitTextClip?: (id: string) => void;
  onSplitSoundClip?: (id: string) => void;
  
  // Resize callbacks
  onResizeVideoClip?: (id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => void;
  onResizeTextClip?: (id: string, newDuration: number) => void;
  onResizeSoundClip?: (id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => void;
  
  // Position update callbacks
  onUpdateVideoClipPosition?: (id: string, newPosition: number) => void;
  onUpdateTextClipPosition?: (id: string, newPosition: number) => void;
  onUpdateSoundClipPosition?: (id: string, newPosition: number) => void;
  
  // Batch update callbacks
  onUpdateAllVideoClips?: (clips: VideoClip[]) => void;
  onUpdateAllTextClips?: (clips: TextClip[]) => void;
  onUpdateAllSoundClips?: (clips: SoundClip[]) => void;
  
  // Legacy reorder callbacks (may be deprecated)
  onReorderVideoClips?: (clips: VideoClip[]) => void;
  onReorderTextClips?: (clips: TextClip[]) => void;
  onReorderSoundClips?: (clips: SoundClip[]) => void;
}

// Playback control props
export interface TimelinePlaybackProps {
  currentTime?: number; // in seconds
  isPlaying?: boolean;
  onSeek?: (time: number) => void;
  onPlayPause?: () => void;
}

// History control props
export interface TimelineHistoryProps {
  onUndo?: () => void;
  onRedo?: () => void;
  canUndo?: boolean;
  canRedo?: boolean;
}

// Configuration props
export interface TimelineConfigProps {
  pixelsPerSecond?: number;
}

// Combined Timeline Props
export interface TimelineProps {
  clips: TimelineClipsProps;
  callbacks: TimelineClipCallbacks;
  playback?: TimelinePlaybackProps;
  history?: TimelineHistoryProps;
  config?: TimelineConfigProps;
}
</file>

<file path="app/video-editor/_utils/audio-analysis.ts">
/**
 * Audio analysis utilities using Web Audio API
 * Handles waveform data extraction and audio processing
 */

interface AudioAnalysisResult {
  waveformData: number[];
  duration: number;
  sampleRate: number;
}

/**
 * Analyzes an audio file and extracts waveform data
 * @param audioUrl - URL of the audio file to analyze
 * @param samples - Number of samples to extract (default: 200)
 * @returns Promise with waveform data and audio metadata
 */
export async function analyzeAudioFile(
  audioUrl: string,
  samples: number = 200
): Promise<AudioAnalysisResult> {
  try {
    // Fetch the audio file
    const response = await fetch(audioUrl);
    const arrayBuffer = await response.arrayBuffer();

    // Create audio context
    const audioContext = new (window.AudioContext || (window as unknown as { webkitAudioContext: typeof AudioContext }).webkitAudioContext)();
    
    // Decode audio data
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
    
    // Extract waveform data
    const waveformData = extractWaveformData(audioBuffer, samples);
    
    // Clean up
    audioContext.close();
    
    return {
      waveformData,
      duration: audioBuffer.duration,
      sampleRate: audioBuffer.sampleRate
    };
  } catch (error) {
    console.error('Error analyzing audio file:', error);
    // Return default waveform data on error
    return {
      waveformData: generateDefaultWaveform(samples),
      duration: 0,
      sampleRate: 44100
    };
  }
}

/**
 * Extracts normalized waveform data from an AudioBuffer
 * @param audioBuffer - The decoded audio buffer
 * @param samples - Number of samples to extract
 * @returns Array of normalized peak values (0-1)
 */
function extractWaveformData(audioBuffer: AudioBuffer, samples: number): number[] {
  const channelData = audioBuffer.getChannelData(0); // Get first channel
  const blockSize = Math.floor(channelData.length / samples);
  const waveformData: number[] = [];

  for (let i = 0; i < samples; i++) {
    const start = blockSize * i;
    const end = Math.min(start + blockSize, channelData.length);
    
    // Find the peak value in this block
    let peak = 0;
    for (let j = start; j < end; j++) {
      const value = Math.abs(channelData[j]);
      if (value > peak) {
        peak = value;
      }
    }
    
    // Normalize to 0-1 range
    waveformData.push(peak);
  }

  return waveformData;
}

/**
 * Generates a default waveform pattern for fallback
 * @param samples - Number of samples to generate
 * @returns Array of random waveform values
 */
function generateDefaultWaveform(samples: number): number[] {
  const waveform: number[] = [];
  
  for (let i = 0; i < samples; i++) {
    // Generate a realistic-looking waveform pattern
    const base = 0.3 + Math.random() * 0.4;
    const variation = Math.sin(i * 0.1) * 0.2;
    waveform.push(Math.max(0, Math.min(1, base + variation)));
  }
  
  return waveform;
}

/**
 * Draws waveform data on a canvas element
 * @param canvas - The canvas element to draw on
 * @param waveformData - Array of normalized peak values
 * @param volume - Volume level (0-200)
 * @param color - Waveform color (default: green)
 * @param backgroundColor - Background color (default: transparent)
 */
export function drawWaveform(
  canvas: HTMLCanvasElement,
  waveformData: number[],
  volume: number = 100,
  color: string = 'rgba(74, 222, 128, 0.8)',
  backgroundColor: string = 'transparent'
): void {
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const width = canvas.width;
  const height = canvas.height;
  const barWidth = width / waveformData.length;
  const volumeMultiplier = volume / 100;

  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  // Fill background if specified
  if (backgroundColor !== 'transparent') {
    ctx.fillStyle = backgroundColor;
    ctx.fillRect(0, 0, width, height);
  }

  // Draw waveform bars
  ctx.fillStyle = color;
  
  for (let i = 0; i < waveformData.length; i++) {
    const barHeight = waveformData[i] * height * 0.8 * volumeMultiplier;
    const x = i * barWidth;
    const y = (height - barHeight) / 2;
    
    // Draw mirrored bars for symmetric waveform
    ctx.fillRect(x, y, barWidth - 1, barHeight);
  }
}

/**
 * Draws Final Cut Pro style waveform (bottom-up with gradient)
 * @param canvas - The canvas element to draw on
 * @param waveformData - Array of normalized peak values
 * @param volume - Volume level (0-100)
 * @param isActive - Whether the clip is active/selected
 */
export function drawWaveformFinalCutStyle(
  canvas: HTMLCanvasElement,
  waveformData: number[],
  volume: number = 100,
  isActive: boolean = false
): void {
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const width = canvas.width;
  const height = canvas.height;
  const barWidth = Math.max(1, width / waveformData.length);
  const gap = barWidth > 3 ? 1 : 0; // Add gap between bars if they're wide enough
  
  // Clear canvas
  ctx.clearRect(0, 0, width, height);
  
  // Create gradient for waveform
  const gradient = ctx.createLinearGradient(0, height, 0, 0);
  if (isActive) {
    // Active state - brighter blue
    gradient.addColorStop(0, 'rgba(56, 244, 124, 0.9)'); // Bright green at bottom
    gradient.addColorStop(1, 'rgba(56, 244, 124, 0.3)'); // Faded at top
  } else {
    // Inactive state - Final Cut Pro blue
    gradient.addColorStop(0, 'rgba(74, 144, 226, 0.9)'); // Solid blue at bottom
    gradient.addColorStop(0.7, 'rgba(74, 144, 226, 0.6)'); // Mid fade
    gradient.addColorStop(1, 'rgba(74, 144, 226, 0.2)'); // Faded at top
  }
  
  ctx.fillStyle = gradient;
  
  // Draw waveform bars from bottom up
  for (let i = 0; i < waveformData.length; i++) {
    // Apply volume scaling (0-100% range)
    const scaledHeight = waveformData[i] * (volume / 100);
    const barHeight = scaledHeight * height * 0.9; // Use 90% of available height
    const x = i * barWidth;
    const y = height - barHeight; // Start from bottom
    
    // Draw bar
    ctx.fillRect(x, y, barWidth - gap, barHeight);
  }
  
  // Add subtle reflection effect (optional)
  if (barWidth > 2) {
    ctx.globalAlpha = 0.1;
    ctx.fillStyle = 'white';
    for (let i = 0; i < waveformData.length; i++) {
      const scaledHeight = waveformData[i] * (volume / 100);
      const barHeight = scaledHeight * height * 0.9;
      const x = i * barWidth;
      const y = height - barHeight;
      
      // Draw thin highlight on left edge of each bar
      ctx.fillRect(x, y, 1, barHeight);
    }
    ctx.globalAlpha = 1;
  }
}

/**
 * Calculates the RMS (Root Mean Square) value for volume visualization
 * @param waveformData - Array of normalized peak values
 * @returns RMS value (0-1)
 */
export function calculateRMS(waveformData: number[]): number {
  if (waveformData.length === 0) return 0;
  
  const sum = waveformData.reduce((acc, val) => acc + val * val, 0);
  return Math.sqrt(sum / waveformData.length);
}

/**
 * Smooths waveform data for better visualization
 * @param waveformData - Raw waveform data
 * @param smoothingFactor - How much to smooth (0-1, higher = smoother)
 * @returns Smoothed waveform data
 */
export function smoothWaveform(
  waveformData: number[],
  smoothingFactor: number = 0.3
): number[] {
  const smoothed: number[] = [];
  
  for (let i = 0; i < waveformData.length; i++) {
    let sum = waveformData[i];
    let count = 1;
    
    // Average with neighboring samples
    const range = Math.floor(smoothingFactor * 5);
    for (let j = 1; j <= range; j++) {
      if (i - j >= 0) {
        sum += waveformData[i - j];
        count++;
      }
      if (i + j < waveformData.length) {
        sum += waveformData[i + j];
        count++;
      }
    }
    
    smoothed.push(sum / count);
  }
  
  return smoothed;
}

/**
 * Resamples waveform data to a different number of samples
 * Useful when resizing the waveform display
 * @param waveformData - Original waveform data
 * @param newSampleCount - Desired number of samples
 * @returns Resampled waveform data
 */
export function resampleWaveform(
  waveformData: number[],
  newSampleCount: number
): number[] {
  if (waveformData.length === newSampleCount) return waveformData;
  
  const resampled: number[] = [];
  const ratio = waveformData.length / newSampleCount;
  
  for (let i = 0; i < newSampleCount; i++) {
    const index = i * ratio;
    const lowerIndex = Math.floor(index);
    const upperIndex = Math.min(Math.ceil(index), waveformData.length - 1);
    const fraction = index - lowerIndex;
    
    // Linear interpolation between samples
    const value = waveformData[lowerIndex] * (1 - fraction) + 
                  waveformData[upperIndex] * fraction;
    resampled.push(value);
  }
  
  return resampled;
}
</file>

<file path="app/video-editor/_utils/timeline-helpers.ts">
import { VideoClip, TextClip, SoundClip } from '@/types/video-editor';
import { BaseClip } from './timeline-utils';

/**
 * Generic timeline helper functions to reduce code duplication
 */

// Clip type union
export type AnyClip = VideoClip | TextClip | SoundClip;
export type ClipType = 'video' | 'text' | 'sound';

/**
 * Generic function to find a clip by ID
 */
export function findClipById<T extends BaseClip>(
  clips: T[],
  clipId: string
): T | undefined {
  return clips.find(c => c.id === clipId);
}

/**
 * Generic function to get clip at position
 */
export function getClipAtPosition<T extends BaseClip>(
  clips: T[],
  position: number
): T | null {
  const clip = clips.find(c => 
    position >= c.position &&
    position <= c.position + c.duration
  );
  return clip || null;
}

/**
 * Generic function to check if clips overlap
 */
export function checkClipsOverlap<T extends BaseClip>(
  clip1: T,
  clip2: T
): boolean {
  const clip1Start = clip1.position;
  const clip1End = clip1.position + clip1.duration;
  const clip2Start = clip2.position;
  const clip2End = clip2.position + clip2.duration;
  
  return clip1Start < clip2End && clip1End > clip2Start;
}

/**
 * Generic function to sort clips by position
 */
export function sortClipsByPosition<T extends BaseClip>(clips: T[]): T[] {
  return [...clips].sort((a, b) => a.position - b.position);
}

/**
 * Generic function to get clips in range
 */
export function getClipsInRange<T extends BaseClip>(
  clips: T[],
  startPosition: number,
  endPosition: number
): T[] {
  return clips.filter(clip => {
    const clipStart = clip.position;
    const clipEnd = clip.position + clip.duration;
    
    // Check if clip overlaps with range
    return clipStart < endPosition && clipEnd > startPosition;
  });
}

/**
 * Generic function to update clip position
 */
export function updateClipPosition<T extends BaseClip>(
  clips: T[],
  clipId: string,
  newPosition: number
): T[] {
  return clips.map(clip => 
    clip.id === clipId 
      ? { ...clip, position: Math.max(0, newPosition) }
      : clip
  );
}

/**
 * Generic function to update clip duration
 */
export function updateClipDuration<T extends BaseClip>(
  clips: T[],
  clipId: string,
  newDuration: number
): T[] {
  return clips.map(clip => 
    clip.id === clipId 
      ? { ...clip, duration: Math.max(80, newDuration) } // Minimum 80px width
      : clip
  );
}

/**
 * Get clips by type from timeline state
 */
export function getClipsByType(
  type: ClipType,
  videoClips: VideoClip[],
  textClips: TextClip[],
  soundClips: SoundClip[]
): AnyClip[] {
  switch (type) {
    case 'video':
      return videoClips;
    case 'text':
      return textClips;
    case 'sound':
      return soundClips;
    default:
      return [];
  }
}

/**
 * Calculate timeline duration from all tracks
 */
export function calculateTimelineDuration(
  videoClips: VideoClip[],
  textClips: TextClip[],
  soundClips: SoundClip[],
  pixelsPerSecond: number
): number {
  const getTrackEnd = (clips: BaseClip[]) => {
    if (clips.length === 0) return 0;
    return Math.max(...clips.map(c => c.position + c.duration));
  };
  
  const videoEnd = getTrackEnd(videoClips) / pixelsPerSecond;
  const textEnd = getTrackEnd(textClips) / pixelsPerSecond;
  const soundEnd = getTrackEnd(soundClips) / pixelsPerSecond;
  
  return Math.max(videoEnd, textEnd, soundEnd, 0);
}

/**
 * Format time display (seconds to MM:SS)
 */
export function formatTime(seconds: number): string {
  const minutes = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
}

/**
 * Generate time markers for timeline
 */
export function generateTimeMarkers(duration: number, interval: number = 1): string[] {
  const markers: string[] = [];
  for (let i = 0; i <= Math.ceil(duration); i += interval) {
    markers.push(formatTime(i));
  }
  return markers;
}

/**
 * Check if position is near clip edge (for snapping)
 */
export function isNearClipEdge<T extends BaseClip>(
  position: number,
  clips: T[],
  threshold: number = 10
): { snap: boolean; snapPosition: number } {
  for (const clip of clips) {
    const clipStart = clip.position;
    const clipEnd = clip.position + clip.duration;
    
    if (Math.abs(position - clipStart) <= threshold) {
      return { snap: true, snapPosition: clipStart };
    }
    
    if (Math.abs(position - clipEnd) <= threshold) {
      return { snap: true, snapPosition: clipEnd };
    }
  }
  
  return { snap: false, snapPosition: position };
}

/**
 * Get the next available clip ID
 */
export function generateClipId(prefix: string = 'clip'): string {
  return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Check if a rectangle intersects with a clip
 */
export function isClipInSelectionRect<T extends BaseClip>(
  clip: T,
  rectLeft: number,
  rectRight: number,
  trackTop: number,
  trackBottom: number,
  clipTop: number,
  clipHeight: number
): boolean {
  const clipLeft = clip.position;
  const clipRight = clip.position + clip.duration;
  const clipBottom = clipTop + clipHeight;
  
  return (
    clipLeft < rectRight &&
    clipRight > rectLeft &&
    clipTop < trackBottom &&
    clipBottom > trackTop
  );
}

/**
 * Batch delete clips by IDs
 */
export function deleteClipsByIds<T extends BaseClip>(
  clips: T[],
  idsToDelete: string[]
): T[] {
  return clips.filter(clip => !idsToDelete.includes(clip.id));
}

/**
 * Duplicate a clip with new ID and position
 */
export function duplicateClip<T extends BaseClip>(
  clip: T,
  newPosition?: number
): T {
  return {
    ...clip,
    id: generateClipId(clip.id.split('_')[0]),
    position: newPosition ?? clip.position + clip.duration,
  };
}
</file>

<file path="app/video-editor/_utils/video-metadata.ts">
/**
 * 비디오 파일에서 메타데이터를 추출하는 유틸리티 함수
 * HTML5 Video API를 사용하여 클라이언트 사이드에서 처리
 */

export interface VideoMetadata {
  duration: number;
  aspectRatio: string;
  width: number;
  height: number;
}

/**
 * 비디오 파일에서 메타데이터 추출
 * @param file - 비디오 파일
 * @returns 비디오 메타데이터 (duration, aspectRatio, width, height)
 */
export async function extractVideoMetadata(file: File): Promise<VideoMetadata> {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const url = URL.createObjectURL(file);
    
    video.src = url;
    video.preload = 'metadata';
    
    const handleLoadedMetadata = () => {
      const width = video.videoWidth;
      const height = video.videoHeight;
      const duration = video.duration;
      
      // 유효성 검사
      if (!width || !height || !isFinite(duration)) {
        cleanup();
        reject(new Error('Invalid video metadata'));
        return;
      }
      
      // Aspect ratio 계산
      const ratio = width / height;
      let aspectRatio = `${width}:${height}`;
      
      // 일반적인 비율로 정규화 (tolerance: 0.1)
      if (Math.abs(ratio - 16/9) < 0.1) {
        aspectRatio = '16:9';
      } else if (Math.abs(ratio - 9/16) < 0.1) {
        aspectRatio = '9:16';
      } else if (Math.abs(ratio - 1) < 0.1) {
        aspectRatio = '1:1';
      } else if (Math.abs(ratio - 4/3) < 0.1) {
        aspectRatio = '4:3';
      } else if (Math.abs(ratio - 3/4) < 0.1) {
        aspectRatio = '3:4';
      } else if (Math.abs(ratio - 21/9) < 0.1) {
        aspectRatio = '21:9'; // 울트라와이드
      } else if (Math.abs(ratio - 9/21) < 0.1) {
        aspectRatio = '9:21';
      }
      
      cleanup();
      resolve({ 
        duration: Math.round(duration * 100) / 100, // 소수점 2자리
        aspectRatio, 
        width, 
        height 
      });
    };
    
    const handleError = () => {
      cleanup();
      reject(new Error('Failed to load video metadata'));
    };
    
    const cleanup = () => {
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('error', handleError);
      URL.revokeObjectURL(url);
    };
    
    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('error', handleError);
    
    // 타임아웃 설정 (10초)
    setTimeout(() => {
      cleanup();
      reject(new Error('Video metadata extraction timeout'));
    }, 10000);
  });
}

/**
 * 비디오 길이를 포맷팅 (초 -> mm:ss)
 * @param seconds - 초 단위 길이
 * @returns 포맷된 시간 문자열
 */
export function formatVideoDuration(seconds: number): string {
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

/**
 * 파일 크기를 포맷팅 (bytes -> MB)
 * @param bytes - 바이트 단위 크기
 * @returns 포맷된 크기 문자열
 */
export function formatFileSize(bytes: number): string {
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}

/**
 * 비디오 파일의 첫 프레임을 썸네일로 추출
 * @param file - 비디오 파일
 * @param quality - JPEG 품질 (0-1, 기본값 0.8)
 * @returns 썸네일 Blob
 */
export async function extractVideoThumbnail(file: File, quality = 0.8): Promise<Blob> {
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const url = URL.createObjectURL(file);
    
    if (!ctx) {
      reject(new Error('Canvas context not available'));
      return;
    }
    
    video.src = url;
    video.crossOrigin = 'anonymous';
    
    const handleLoadedData = () => {
      // 비디오가 로드되면 첫 프레임 시간으로 이동
      video.currentTime = 0.1; // 0.1초 지점 (첫 프레임이 검은 화면일 수 있으므로)
    };
    
    const handleSeeked = () => {
      // Canvas 크기를 비디오 크기에 맞춤 (최대 640px 너비로 제한)
      const maxWidth = 640;
      const scale = Math.min(1, maxWidth / video.videoWidth);
      
      canvas.width = video.videoWidth * scale;
      canvas.height = video.videoHeight * scale;
      
      // 비디오 프레임을 Canvas에 그리기
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      
      // Canvas를 Blob으로 변환
      canvas.toBlob(
        (blob) => {
          cleanup();
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Failed to create thumbnail blob'));
          }
        },
        'image/jpeg',
        quality
      );
    };
    
    const handleError = () => {
      cleanup();
      reject(new Error('Failed to load video for thumbnail extraction'));
    };
    
    const cleanup = () => {
      video.removeEventListener('loadeddata', handleLoadedData);
      video.removeEventListener('seeked', handleSeeked);
      video.removeEventListener('error', handleError);
      URL.revokeObjectURL(url);
    };
    
    video.addEventListener('loadeddata', handleLoadedData);
    video.addEventListener('seeked', handleSeeked);
    video.addEventListener('error', handleError);
    
    // 타임아웃 설정 (10초)
    setTimeout(() => {
      cleanup();
      reject(new Error('Thumbnail extraction timeout'));
    }, 10000);
  });
}
</file>

<file path="app/video-editor/_utils/video.ts">
/**
 * 비디오 관련 유틸리티 함수들
 */

/**
 * 초 단위 시간을 MM:SS 형식으로 포맷팅
 * @param seconds - 초 단위 시간
 * @returns MM:SS 형식의 문자열
 */
export function formatTime(seconds: number): string {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/**
 * 프레임을 초로 변환 (30fps 기준)
 * @param frames - 프레임 수
 * @param fps - 초당 프레임 수 (기본값: 30)
 * @returns 초 단위 시간
 */
export function framesToSeconds(frames: number, fps: number = 30): number {
  return frames / fps;
}

/**
 * 초를 프레임으로 변환 (30fps 기준)
 * @param seconds - 초 단위 시간
 * @param fps - 초당 프레임 수 (기본값: 30)
 * @returns 프레임 수
 */
export function secondsToFrames(seconds: number, fps: number = 30): number {
  return Math.round(seconds * fps);
}

/**
 * 픽셀을 초로 변환 (타임라인 기준 40px = 1초)
 * @param pixels - 픽셀 수
 * @param pixelsPerSecond - 초당 픽셀 수 (기본값: 40)
 * @returns 초 단위 시간
 */
export function pixelsToSeconds(pixels: number, pixelsPerSecond: number = 40): number {
  return pixels / pixelsPerSecond;
}

/**
 * 초를 픽셀로 변환 (타임라인 기준 40px = 1초)
 * @param seconds - 초 단위 시간
 * @param pixelsPerSecond - 초당 픽셀 수 (기본값: 40)
 * @returns 픽셀 수
 */
export function secondsToPixels(seconds: number, pixelsPerSecond: number = 40): number {
  return seconds * pixelsPerSecond;
}
</file>

<file path="app/error.tsx">
'use client'

import { useEffect } from 'react'
import { Button } from '@/components/ui/button'

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  useEffect(() => {
    // 에러를 로깅 서비스에 기록
    console.error('Application error:', error)
  }, [error])

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-background">
      <div className="text-center space-y-4 max-w-md px-4">
        <h1 className="text-4xl font-bold text-foreground">
          Something went wrong
        </h1>
        <p className="text-text-secondary">
          An unexpected error occurred. Please try again later.
        </p>
        <div className="pt-4">
          <Button
            onClick={reset}
            className="bg-primary text-primary-foreground hover:bg-primary/90"
          >
            Try again
          </Button>
        </div>
        {process.env.NODE_ENV === 'development' && (
          <div className="mt-8 p-4 bg-surface-secondary rounded-lg text-left">
            <p className="text-xs text-text-secondary font-mono">
              {error.message}
            </p>
          </div>
        )}
      </div>
    </div>
  )
}
</file>

<file path="app/global-error.tsx">
'use client'

export default function GlobalError({
  reset,
}: {
  error: Error & { digest?: string }
  reset: () => void
}) {
  return (
    <html>
      <body>
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          backgroundColor: '#0a0a0a',
          color: '#ffffff',
          fontFamily: 'system-ui, -apple-system, sans-serif'
        }}>
          <h1 style={{ fontSize: '2rem', marginBottom: '1rem' }}>
            System Error
          </h1>
          <p style={{ marginBottom: '2rem', color: '#888' }}>
            A critical error has occurred in the application.
          </p>
          <button
            onClick={reset}
            style={{
              padding: '0.75rem 1.5rem',
              backgroundColor: '#6366f1',
              color: 'white',
              border: 'none',
              borderRadius: '0.375rem',
              cursor: 'pointer',
              fontSize: '1rem'
            }}
          >
            Try Again
          </button>
        </div>
      </body>
    </html>
  )
}
</file>

<file path="components/layout/Header.tsx">
import { Bell, Edit2 } from "lucide-react"
import Link from "next/link"
import { useState, useEffect } from "react"

interface HeaderProps {
  onLibraryClick?: () => void
  activePage?: 'clip' | 'edit'
  projectTitle?: string
  onEditClick?: () => void
  onProjectTitleChange?: (title: string) => void
}

export function Header({ 
  onLibraryClick, 
  activePage = 'clip',
  projectTitle,
  onEditClick,
  onProjectTitleChange
}: HeaderProps) {
  const [isEditingTitle, setIsEditingTitle] = useState(false)
  const [tempTitle, setTempTitle] = useState(projectTitle || '')
  
  // Update tempTitle when projectTitle changes
  useEffect(() => {
    setTempTitle(projectTitle || '')
  }, [projectTitle])
  return (
    <header className="bg-background/95 backdrop-blur-sm py-4 px-6 flex justify-between items-center border-b border-border">
      <div className="flex items-center gap-6">
        <Link href="/" className="text-2xl font-bold text-primary tracking-tight">
          vogue drop
        </Link>
        {activePage === 'edit' && (
          <div className="flex items-center gap-2">
            {isEditingTitle ? (
              <input
                type="text"
                value={tempTitle}
                onChange={(e) => setTempTitle(e.target.value)}
                onBlur={() => {
                  const finalTitle = tempTitle.trim() || projectTitle || 'Untitled Project'
                  onProjectTitleChange?.(finalTitle)
                  setIsEditingTitle(false)
                }}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    const finalTitle = tempTitle.trim() || projectTitle || 'Untitled Project'
                    onProjectTitleChange?.(finalTitle)
                    setIsEditingTitle(false)
                  } else if (e.key === 'Escape') {
                    setTempTitle(projectTitle || '')
                    setIsEditingTitle(false)
                  }
                }}
                className="input-base input-sm font-medium"
                autoFocus
              />
            ) : (
              <button
                onClick={() => {
                  setTempTitle(projectTitle || '')
                  setIsEditingTitle(true)
                }}
                className="flex items-center gap-2 px-3 py-1 rounded-md hover:bg-surface-secondary transition-colors"
              >
                <span className="text-sm font-medium text-text-secondary">
                  {projectTitle || 'Untitled Project'}
                </span>
                <Edit2 className="w-3 h-3 text-text-tertiary" />
              </button>
            )}
          </div>
        )}
      </div>
      <div className="flex space-x-8">
        <Link 
          href="/canvas" 
          className={`font-medium text-sm transition-colors ${
            activePage === 'clip' 
              ? 'text-primary hover:text-primary/80' 
              : 'text-text-secondary hover:text-text-primary'
          }`}
        >
          Clip
        </Link>
        <button 
          className={`font-medium text-sm transition-colors ${
            activePage === 'edit' 
              ? 'text-primary hover:text-primary/80' 
              : 'text-text-secondary hover:text-text-primary'
          }`}
          onClick={activePage === 'clip' ? onEditClick : undefined}
        >
          Edit
        </button>
        <button 
          className="font-medium text-sm text-text-secondary hover:text-text-primary transition-colors" 
          onClick={onLibraryClick}
        >
          Library
        </button>
      </div>
      <div className="flex items-center space-x-4">
        <div className="w-8 h-8 flex items-center justify-center text-text-tertiary hover:text-text-primary transition-colors cursor-pointer">
          <Bell className="w-5 h-5" />
        </div>
        <div className="w-10 h-10 bg-surface-secondary rounded-full flex items-center justify-center">
          <span className="text-xs text-text-primary">Matt</span>
        </div>
      </div>
    </header>
  )
}
</file>

<file path="components/modals/library/components/LibraryCard.tsx">
'use client';

import { LibraryVideo, LibraryProject, UserUploadedVideo } from '@/types/video-editor';
import { LibraryModalConfig } from '@/types/library-modal';
import { CARD_CONTAINER_CLASS, getContentFitStyle } from '../utils/constants';
import Image from 'next/image';
import { Play, Download, Loader2, Star, Folder, Upload as UploadIcon } from 'lucide-react';

interface LibraryCardProps {
  item: LibraryVideo | LibraryProject | UserUploadedVideo;
  type: 'clip' | 'project' | 'upload';
  isSelected?: boolean;
  selectionOrder?: number;
  isFavorite?: boolean;
  isDownloading?: boolean;
  onSelect?: () => void;
  onFavoriteToggle?: () => void;
  onDownload?: () => void;
  theme?: LibraryModalConfig['theme'];
}

export function LibraryCard({
  item,
  type,
  isSelected = false,
  selectionOrder,
  isFavorite = false,
  isDownloading = false,
  onSelect,
  onFavoriteToggle,
  onDownload,
  theme
}: LibraryCardProps) {
  // 타입별 데이터 접근
  const getAspectRatio = () => {
    if (type === 'clip') return (item as LibraryVideo).aspect_ratio || '9:16';
    if (type === 'project') return (item as LibraryProject).content_snapshot?.aspect_ratio || '16:9';
    if (type === 'upload') return (item as UserUploadedVideo).aspect_ratio || '16:9';
    return '16:9';
  };

  const getVideoUrl = () => {
    if (type === 'clip') return (item as LibraryVideo).output_video_url;
    if (type === 'project') return (item as LibraryProject).latest_video_url;
    if (type === 'upload') return (item as UserUploadedVideo & { url?: string }).url;
    return undefined;
  };

  const getThumbnailUrl = () => {
    if (type === 'clip') return (item as LibraryVideo).input_image_url;
    if (type === 'project') return (item as LibraryProject).thumbnail_url;
    if (type === 'upload') return (item as UserUploadedVideo).thumbnail_url;
    return undefined;
  };

  const getTitle = () => {
    if (type === 'clip') {
      const clip = item as LibraryVideo;
      return clip.selected_effects?.[0]?.name || 'Video';
    }
    if (type === 'project') return (item as LibraryProject).project_name;
    if (type === 'upload') return (item as UserUploadedVideo).file_name;
    return undefined;
  };

  const getDate = () => {
    if (type === 'clip') return new Date((item as LibraryVideo).created_at);
    if (type === 'project') return new Date((item as LibraryProject).updated_at);
    if (type === 'upload') return new Date((item as UserUploadedVideo).uploaded_at);
    return new Date();
  };

  const contentFitClass = getContentFitStyle(getAspectRatio());
  const videoUrl = getVideoUrl();
  const thumbnailUrl = getThumbnailUrl();
  const title = getTitle();
  const selectionColor = theme?.selectionColor || '#38f47cf9';

  // 카드 클릭 핸들러
  const handleCardClick = () => {
    if (onSelect) {
      onSelect();
    }
  };

  // 아이콘 렌더링
  const renderPlaceholderIcon = () => {
    switch(type) {
      case 'clip':
        return <i className="ri-video-line text-4xl text-gray-600"></i>;
      case 'project':
        return <Folder className="w-12 h-12 text-gray-600" />;
      case 'upload':
        return <UploadIcon className="w-12 h-12 text-gray-600" />;
    }
  };

  return (
    <div 
      onClick={handleCardClick}
      className={`${CARD_CONTAINER_CLASS} bg-gray-900 rounded-lg overflow-hidden relative transition-all
        ${onSelect ? 'cursor-pointer' : ''}
        ${isSelected 
          ? `ring-2 scale-[0.98]` 
          : onSelect ? 'hover:ring-2 hover:ring-opacity-50' : ''}`}
      style={{
        '--tw-ring-color': isSelected ? selectionColor : `${selectionColor}80`,
      } as React.CSSProperties}
    >
      <div className="relative h-full group">
        {/* Thumbnail or Video Preview */}
        {thumbnailUrl ? (
          <Image 
            src={thumbnailUrl} 
            alt={title || 'Library item'} 
            className={`w-full h-full ${contentFitClass}`}
            fill
            sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
          />
        ) : videoUrl ? (
          <video 
            src={videoUrl}
            className={`w-full h-full ${contentFitClass}`}
            muted
            playsInline
            preload="metadata"
            onError={(e) => {
              const target = e.target as HTMLVideoElement;
              target.style.display = 'none';
            }}
          />
        ) : (
          <div className="w-full h-full bg-gray-800 flex items-center justify-center">
            {renderPlaceholderIcon()}
          </div>
        )}
        
        {/* Selection number indicator */}
        {isSelected && selectionOrder && (
          <div 
            className="absolute top-2 right-2 w-8 h-8 rounded-full flex items-center justify-center text-black font-bold text-sm z-10"
            style={{ backgroundColor: selectionColor }}
          >
            {selectionOrder}
          </div>
        )}
        
        {/* Hover overlay with actions */}
        {videoUrl && (
          <div className="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center gap-2">
            <a 
              href={videoUrl}
              target="_blank"
              rel="noopener noreferrer"
              className="w-10 h-10 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center text-white"
              onClick={(e) => {
                e.stopPropagation();
              }}
            >
              <Play className="w-4 h-4" />
            </a>
            {onDownload && (
              <button 
                onClick={(e) => {
                  e.stopPropagation();
                  onDownload();
                }}
                disabled={isDownloading}
                className="w-10 h-10 bg-white/20 hover:bg-white/30 rounded-full flex items-center justify-center text-white disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isDownloading ? (
                  <Loader2 className="w-4 h-4 animate-spin" />
                ) : (
                  <Download className="w-4 h-4" />
                )}
              </button>
            )}
          </div>
        )}
        
        {/* Favorite button */}
        {onFavoriteToggle && type === 'clip' && (
          <div className="absolute top-2 right-2">
            <button
              onClick={(e) => {
                e.stopPropagation();
                onFavoriteToggle();
              }}
              className="bg-black/60 p-1.5 rounded-full hover:bg-black/80 transition-colors"
            >
              <Star className={`w-5 h-5 drop-shadow-[0_1px_2px_rgba(0,0,0,0.8)] ${
                isFavorite
                  ? "text-yellow-400 fill-current"
                  : "text-white/70 hover:text-white"
              }`} />
            </button>
          </div>
        )}
        
        {/* Info overlay - Unified for all types */}
        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/80 to-transparent p-3">
          {/* Title for all types */}
          {title && (
            <h4 className="text-sm font-medium text-white truncate">
              {title}
            </h4>
          )}
          
          {/* Date only */}
          <div className="text-[10px] text-gray-400 mt-1">
            {getDate().toLocaleDateString()}
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/modals/library/components/LibrarySidebar.tsx">
'use client';

import { Video, Folder, Upload } from 'lucide-react';
import { LibraryCategory, LibraryCounts, LibraryModalConfig } from '@/types/library-modal';
import { Input } from '@/components/ui/input';

interface LibrarySidebarProps {
  activeCategory: LibraryCategory;
  onCategoryChange: (category: LibraryCategory) => void;
  counts: LibraryCounts;
  dateFilter?: {
    enabled: boolean;
    startDate: string;
    endDate: string;
    onStartDateChange: (date: string) => void;
    onEndDateChange: (date: string) => void;
  };
  uploadSection?: React.ReactNode;
  theme?: LibraryModalConfig['theme'];
}

export function LibrarySidebar({
  activeCategory,
  onCategoryChange,
  counts,
  dateFilter,
  uploadSection,
  theme
}: LibrarySidebarProps) {
  const primaryColor = theme?.primaryColor || 'primary';
  const isCustomColor = primaryColor.startsWith('#');
  
  const getButtonClass = (isActive: boolean) => {
    if (isActive) {
      if (isCustomColor) {
        return 'text-white';
      }
      return `bg-${primaryColor}/20 text-${primaryColor}`;
    }
    return 'hover:bg-gray-800 text-gray-400 hover:text-white';
  };

  const categories: Array<{
    id: LibraryCategory;
    icon: React.ReactNode;
    label: string;
  }> = [
    {
      id: 'clips',
      icon: <Video className="w-5 h-5" />,
      label: 'Clips'
    },
    {
      id: 'projects',
      icon: <Folder className="w-5 h-5" />,
      label: 'Projects'
    },
    {
      id: 'uploads',
      icon: <Upload className="w-5 h-5" />,
      label: 'Uploads'
    }
  ];

  return (
    <div className="w-[200px] bg-gray-900 border-r border-gray-700 p-4">
      <div className="space-y-2">
        {categories.map((category) => {
          const isActive = activeCategory === category.id;
          return (
            <button
              key={category.id}
              onClick={() => onCategoryChange(category.id)}
              className={`w-full px-4 py-3 rounded-lg text-left transition-colors flex items-center justify-between
                ${getButtonClass(isActive)}`}
              style={isActive && isCustomColor ? {
                backgroundColor: `${primaryColor}20`,
                color: primaryColor
              } : undefined}
            >
              <div className="flex items-center gap-3">
                {category.icon}
                <span className="text-sm font-medium">{category.label}</span>
              </div>
              <span className="text-xs bg-gray-700 px-2 py-1 rounded">
                {counts[category.id]}
              </span>
            </button>
          );
        })}
      </div>
      
      {/* Upload Section */}
      {activeCategory === 'uploads' && uploadSection && (
        <div className="mt-4">
          {uploadSection}
        </div>
      )}

      {/* Date Filter */}
      {dateFilter?.enabled && (
        <div className="mt-6 pt-6 border-t border-gray-700">
          <p className="text-xs text-gray-500 mb-3">Filter by date</p>
          <div className="space-y-2">
            <Input
              type="date"
              className="bg-gray-800 text-white text-xs border-gray-600 focus:border-primary h-8"
              value={dateFilter.startDate}
              onChange={(e) => dateFilter.onStartDateChange(e.target.value)}
              placeholder="Start"
            />
            <span className="text-gray-500 text-xs block text-center">to</span>
            <Input
              type="date"
              className="bg-gray-800 text-white text-xs border-gray-600 focus:border-primary h-8"
              value={dateFilter.endDate}
              onChange={(e) => dateFilter.onEndDateChange(e.target.value)}
              placeholder="End"
            />
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/modals/library/hooks/useLibraryData.ts">
import { useState, useEffect, useCallback } from 'react';
import { LibraryVideo, LibraryProject, UserUploadedVideo } from '@/types/video-editor';
import { LibraryCounts } from '@/types/library-modal';
import { useAuth } from '@/lib/auth/AuthContext';

interface UseLibraryDataReturn {
  clipItems: LibraryVideo[];
  projectItems: LibraryProject[];
  uploadItems: UserUploadedVideo[];
  counts: LibraryCounts;
  isLoading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
  updateUploadItems: (newItem: UserUploadedVideo) => void;
  updateCounts: (key: keyof LibraryCounts, delta: number) => void;
}

/**
 * Library 데이터를 관리하는 커스텀 훅
 * @param isOpen - 모달이 열려있는지 여부
 * @returns Library 데이터와 관련 메서드
 */
export function useLibraryData(isOpen: boolean): UseLibraryDataReturn {
  const [clipItems, setClipItems] = useState<LibraryVideo[]>([]);
  const [projectItems, setProjectItems] = useState<LibraryProject[]>([]);
  const [uploadItems, setUploadItems] = useState<UserUploadedVideo[]>([]);
  const [counts, setCounts] = useState<LibraryCounts>({ clips: 0, projects: 0, uploads: 0 });
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { user } = useAuth();

  const fetchLibraryData = useCallback(async () => {
    if (!user) {
      setClipItems([]);
      setProjectItems([]);
      setUploadItems([]);
      setIsLoading(false);
      return;
    }

    try {
      setIsLoading(true);
      setError(null);
      
      const response = await fetch('/api/canvas/library?limit=100');
      
      if (!response.ok) {
        throw new Error('Failed to fetch library data');
      }
      
      const data = await response.json();
      
      // 응답 데이터 처리
      const clips = data.clips || data.videos || [];
      const projects = data.projects || [];
      const uploads = data.uploads || [];
      
      setClipItems(clips);
      setProjectItems(projects);
      setUploadItems(uploads);
      
      setCounts(data.counts || { 
        clips: clips.length, 
        projects: projects.length,
        uploads: uploads.length
      });
    } catch (err) {
      console.error('Failed to fetch library data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load library. Please try again.');
    } finally {
      setIsLoading(false);
    }
  }, [user]);

  // 모달이 열릴 때 데이터 페칭
  useEffect(() => {
    if (isOpen && user) {
      fetchLibraryData();
    } else if (isOpen && !user) {
      setClipItems([]);
      setProjectItems([]);
      setUploadItems([]);
      setIsLoading(false);
    }
  }, [isOpen, user, fetchLibraryData]);

  // 업로드 아이템 추가 메서드
  const updateUploadItems = useCallback((newItem: UserUploadedVideo) => {
    setUploadItems(prev => [newItem, ...prev]);
  }, []);

  // 카운트 업데이트 메서드
  const updateCounts = useCallback((key: keyof LibraryCounts, delta: number) => {
    setCounts(prev => ({ ...prev, [key]: prev[key] + delta }));
  }, []);

  return {
    clipItems,
    projectItems,
    uploadItems,
    counts,
    isLoading,
    error,
    refetch: fetchLibraryData,
    updateUploadItems,
    updateCounts
  };
}
</file>

<file path="components/modals/library/utils/constants.ts">
/**
 * 모든 카드를 9:16 비율로 고정
 */
export const CARD_CONTAINER_CLASS = 'w-full aspect-[9/16]';

/**
 * 콘텐츠의 object-fit 스타일 결정
 * @param aspectRatio - 콘텐츠의 원본 비율
 * @returns object-fit 클래스 문자열
 */
export const getContentFitStyle = (aspectRatio?: string): string => {
  switch(aspectRatio) {
    case '9:16':
      // 컨테이너와 동일한 비율 - 꽉 채움
      return 'object-cover';
    case '1:1':
      // 정사각형 콘텐츠 - 레터박스 처리
      return 'object-contain bg-black';
    case '16:9':
      // 가로형 콘텐츠 - 레터박스 처리
      return 'object-contain bg-black';
    default:
      return 'object-cover';
  }
};
</file>

<file path="components/modals/library/LibraryModalBase.tsx">
'use client';

import { useState, useCallback, useMemo } from 'react';
import { X, Info, Loader2, Video, Folder, Upload } from 'lucide-react';
import { LibraryModalBaseProps, LibraryCategory } from '@/types/library-modal';
import { LibraryVideo, LibraryProject, UserUploadedVideo, LibraryItem } from '@/types/video-editor';
import { useLibraryData } from './hooks/useLibraryData';
import { LibraryCard } from './components/LibraryCard';
import { LibrarySidebar } from './components/LibrarySidebar';
import { LibraryUpload } from './components/LibraryUpload';

export function LibraryModalBase({ isOpen, onClose, config }: LibraryModalBaseProps) {
  const [activeCategory, setActiveCategory] = useState<LibraryCategory>('clips');
  const [selectedItems, setSelectedItems] = useState<Map<string, number>>(new Map());
  const [isAdding, setIsAdding] = useState(false);
  const [startDate, setStartDate] = useState('');
  const [endDate, setEndDate] = useState('');
  const [downloadingVideos, setDownloadingVideos] = useState<Set<string>>(new Set());
  
  const { 
    clipItems, 
    projectItems, 
    uploadItems, 
    counts, 
    isLoading, 
    error,
    updateUploadItems,
    updateCounts
  } = useLibraryData(isOpen);

  // 선택 모드 핸들러
  const handleItemSelect = useCallback((itemId: string) => {
    if (!config.selection?.enabled) return;
    
    setSelectedItems(prev => {
      const newMap = new Map(prev);
      if (newMap.has(itemId)) {
        // Deselect
        const removedOrder = newMap.get(itemId)!;
        newMap.delete(itemId);
        // Update order numbers
        newMap.forEach((order, id) => {
          if (order > removedOrder) {
            newMap.set(id, order - 1);
          }
        });
      } else {
        // Select (최대 개수 체크)
        if (newMap.size < (config.selection?.maxItems || 10)) {
          newMap.set(itemId, newMap.size + 1);
        }
      }
      return newMap;
    });
  }, [config.selection]);

  // 선택된 아이템 추가 핸들러
  const handleAddSelected = useCallback(async () => {
    if (!config.selection?.onSelect || selectedItems.size === 0) return;
    
    setIsAdding(true);
    try {
      // Sort items by selection order
      const sortedItemIds = Array.from(selectedItems.entries())
        .sort((a, b) => a[1] - b[1])
        .map(([itemId]) => itemId);
      
      const selectedLibraryItems: LibraryItem[] = [];
      
      // Map selected IDs to actual items
      if (activeCategory === 'clips') {
        sortedItemIds.forEach(id => {
          const clip = clipItems.find(c => c.id === id);
          if (clip) {
            selectedLibraryItems.push({ type: 'clip', data: clip });
          }
        });
      } else if (activeCategory === 'projects') {
        sortedItemIds.forEach(id => {
          const project = projectItems.find(p => p.id.toString() === id);
          if (project) {
            selectedLibraryItems.push({ type: 'project', data: project });
          }
        });
      } else {
        sortedItemIds.forEach(id => {
          const upload = uploadItems.find(u => u.id.toString() === id);
          if (upload) {
            selectedLibraryItems.push({ type: 'upload', data: upload });
          }
        });
      }
      
      await config.selection.onSelect(selectedLibraryItems);
      onClose();
    } finally {
      setIsAdding(false);
    }
  }, [config.selection, selectedItems, activeCategory, clipItems, projectItems, uploadItems, onClose]);

  // 카테고리 변경 핸들러
  const handleCategoryChange = useCallback((category: LibraryCategory) => {
    if (category !== activeCategory) {
      setSelectedItems(new Map()); // Clear selection when changing category
      setActiveCategory(category);
    }
  }, [activeCategory]);

  // 다운로드 핸들러
  const handleDownload = useCallback(async (item: LibraryVideo | LibraryProject | (UserUploadedVideo & { url?: string }), type: 'clip' | 'project' | 'upload') => {
    if (!config.download?.enabled) return;
    
    let url: string | undefined;
    let filename: string;
    let itemId: string;
    
    if (type === 'clip') {
      const clip = item as LibraryVideo;
      url = clip.output_video_url;
      itemId = clip.job_id || String(clip.id);
      const date = new Date(clip.created_at).toISOString().split('T')[0];
      const effectName = clip.selected_effects[0]?.name.toLowerCase().replace(/\s+/g, '-') || 'video';
      filename = `voguedrop_${date}_${effectName}.mp4`;
    } else if (type === 'project') {
      const project = item as LibraryProject;
      url = project.latest_video_url;
      itemId = String(project.id);
      const date = new Date(project.updated_at).toISOString().split('T')[0];
      const projectName = project.project_name.toLowerCase().replace(/\s+/g, '-');
      filename = `voguedrop_project_${date}_${projectName}.mp4`;
    } else {
      const upload = item as UserUploadedVideo & { url?: string };
      url = upload.url;
      itemId = String(upload.id);
      const date = new Date(upload.uploaded_at).toISOString().split('T')[0];
      const fileName = upload.file_name.toLowerCase().replace(/\s+/g, '-');
      filename = `voguedrop_upload_${date}_${fileName}`;
    }
    
    if (!url || downloadingVideos.has(itemId)) return;
    
    setDownloadingVideos(prev => new Set(prev).add(itemId));
    
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error('Download failed');
      
      const blob = await response.blob();
      const blobUrl = window.URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.style.display = 'none';
      a.href = blobUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      
      window.URL.revokeObjectURL(blobUrl);
      document.body.removeChild(a);
    } catch (error) {
      console.error('Download failed:', error);
      alert('다운로드에 실패했습니다. 다시 시도해주세요.');
    } finally {
      setDownloadingVideos(prev => {
        const newSet = new Set(prev);
        newSet.delete(itemId);
        return newSet;
      });
    }
  }, [config.download, downloadingVideos]);

  // 필터링된 아이템들
  const filteredItems = useMemo(() => {
    const filterByDate = (date: Date) => {
      const matchesStartDate = !startDate || date >= new Date(startDate);
      const matchesEndDate = !endDate || date <= new Date(endDate + 'T23:59:59');
      return matchesStartDate && matchesEndDate;
    };

    const filteredClips = config.dateFilter?.enabled 
      ? clipItems.filter(item => filterByDate(new Date(item.created_at)))
      : clipItems;
      
    const filteredProjects = config.dateFilter?.enabled
      ? projectItems.filter(item => filterByDate(new Date(item.updated_at)))
      : projectItems;
      
    const filteredUploads = config.dateFilter?.enabled
      ? uploadItems.filter(item => filterByDate(new Date(item.uploaded_at)))
      : uploadItems;

    // Sort clips with favorites first if favorites are enabled
    if (config.favorites?.enabled && config.favorites.favoriteIds) {
      filteredClips.sort((a, b) => {
        const aIsFavorite = config.favorites!.favoriteIds.has(a.job_id || String(a.id)) || a.is_favorite;
        const bIsFavorite = config.favorites!.favoriteIds.has(b.job_id || String(b.id)) || b.is_favorite;
        
        if (aIsFavorite && !bIsFavorite) return -1;
        if (!aIsFavorite && bIsFavorite) return 1;
        
        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
      });
    }

    return { clips: filteredClips, projects: filteredProjects, uploads: filteredUploads };
  }, [clipItems, projectItems, uploadItems, startDate, endDate, config.dateFilter, config.favorites]);

  // 업로드 완료 핸들러
  const handleUploadComplete = useCallback((video: UserUploadedVideo) => {
    updateUploadItems(video);
    updateCounts('uploads', 1);
  }, [updateUploadItems, updateCounts]);

  // Info 메시지
  const getInfoMessage = () => {
    switch(activeCategory) {
      case 'clips':
        return config.favorites?.enabled 
          ? "Only favorited videos are permanently stored. Other videos will be automatically deleted after 7 days."
          : "Your AI-generated video clips.";
      case 'projects':
        return "Your saved video projects with render history.";
      case 'uploads':
        return "Your uploaded videos (max 20MB per file).";
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4">
      <div className="bg-gray-800 rounded-xl w-full max-w-[1200px] max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="flex justify-between items-center p-6 pb-2">
          <div className="flex items-center gap-4">
            <h3 className="text-xl font-medium text-white">
              {config.mode === 'selection' ? 'Video Library' : 'Library'}
            </h3>
            {config.selection?.enabled && selectedItems.size > 0 && (
              <span className="text-sm text-gray-400">
                {selectedItems.size} selected (max {config.selection.maxItems})
              </span>
            )}
          </div>
          <button className="text-gray-400 hover:text-gray-300" onClick={onClose}>
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Info Bar */}
        {config.mode === 'view' && (
          <div className="flex items-center gap-2 px-6 pb-4">
            <Info className="w-4 h-4 text-primary" />
            <p className="text-sm text-gray-400">
              {getInfoMessage()}
            </p>
          </div>
        )}

        {/* Main Content */}
        <div className="flex flex-1 overflow-hidden">
          {/* Sidebar */}
          <LibrarySidebar
            activeCategory={activeCategory}
            onCategoryChange={handleCategoryChange}
            counts={counts}
            dateFilter={config.dateFilter?.enabled ? {
              enabled: true,
              startDate,
              endDate,
              onStartDateChange: setStartDate,
              onEndDateChange: setEndDate
            } : undefined}
            uploadSection={activeCategory === 'uploads' ? (
              <LibraryUpload 
                onUploadComplete={handleUploadComplete}
              />
            ) : undefined}
            theme={config.theme}
          />
          
          {/* Content Area */}
          <div className="flex-1 overflow-y-auto p-6">
            {isLoading ? (
              <div className="flex items-center justify-center py-20">
                <div className="text-center">
                  <Loader2 className="w-8 h-8 animate-spin text-gray-400 mx-auto mb-4" />
                  <p className="text-gray-400">Loading library...</p>
                </div>
              </div>
            ) : error ? (
              <div className="flex items-center justify-center py-20">
                <div className="text-center">
                  <p className="text-red-400">{error}</p>
                </div>
              </div>
            ) : (
              <>
                {activeCategory === 'clips' && (
                  filteredItems.clips.length === 0 ? (
                    <div className="flex items-center justify-center py-20">
                      <div className="text-center">
                        <Video className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                        <p className="text-gray-400">No clips found</p>
                        <p className="text-sm text-gray-500 mt-2">Generate videos in Canvas to see them here</p>
                      </div>
                    </div>
                  ) : (
                    <div className="grid grid-cols-4 gap-4">
                      {filteredItems.clips.map(clip => (
                        <LibraryCard
                          key={clip.id}
                          item={clip}
                          type="clip"
                          isSelected={selectedItems.has(clip.id)}
                          selectionOrder={selectedItems.get(clip.id)}
                          isFavorite={config.favorites?.favoriteIds?.has(clip.job_id || String(clip.id)) || clip.is_favorite}
                          isDownloading={downloadingVideos.has(clip.job_id || String(clip.id))}
                          onSelect={config.selection?.enabled ? () => handleItemSelect(clip.id) : undefined}
                          onFavoriteToggle={config.favorites?.enabled ? () => config.favorites!.onToggle(clip.job_id || String(clip.id)) : undefined}
                          onDownload={config.download?.enabled ? () => handleDownload(clip, 'clip') : undefined}
                          theme={config.theme}
                        />
                      ))}
                    </div>
                  )
                )}
                
                {activeCategory === 'projects' && (
                  filteredItems.projects.length === 0 ? (
                    <div className="flex items-center justify-center py-20">
                      <div className="text-center">
                        <Folder className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                        <p className="text-gray-400">No projects found</p>
                        <p className="text-sm text-gray-500 mt-2">Save your video projects to see them here</p>
                      </div>
                    </div>
                  ) : (
                    <div className="grid grid-cols-4 gap-4">
                      {filteredItems.projects.map(project => (
                        <LibraryCard
                          key={project.id}
                          item={project}
                          type="project"
                          isSelected={selectedItems.has(project.id.toString())}
                          selectionOrder={selectedItems.get(project.id.toString())}
                          isDownloading={downloadingVideos.has(String(project.id))}
                          onSelect={config.selection?.enabled ? () => handleItemSelect(project.id.toString()) : undefined}
                          onDownload={config.download?.enabled ? () => handleDownload(project, 'project') : undefined}
                          theme={config.theme}
                        />
                      ))}
                    </div>
                  )
                )}
                
                {activeCategory === 'uploads' && (
                  filteredItems.uploads.length === 0 ? (
                    <div className="flex items-center justify-center py-20">
                      <div className="text-center">
                        <Upload className="w-12 h-12 text-gray-500 mx-auto mb-4" />
                        <p className="text-gray-400">No uploaded videos found</p>
                        <p className="text-sm text-gray-500 mt-2">Upload your own videos to use them here</p>
                      </div>
                    </div>
                  ) : (
                    <div className="grid grid-cols-4 gap-4">
                      {filteredItems.uploads.map(upload => (
                        <LibraryCard
                          key={upload.id}
                          item={upload}
                          type="upload"
                          isSelected={selectedItems.has(upload.id.toString())}
                          selectionOrder={selectedItems.get(upload.id.toString())}
                          isDownloading={downloadingVideos.has(String(upload.id))}
                          onSelect={config.selection?.enabled ? () => handleItemSelect(upload.id.toString()) : undefined}
                          onDownload={config.download?.enabled ? () => handleDownload(upload, 'upload') : undefined}
                          theme={config.theme}
                        />
                      ))}
                    </div>
                  )
                )}
              </>
            )}
          </div>
        </div>
        
        {/* Footer - Selection Mode */}
        {config.selection?.enabled && (
          <div className="p-6 border-t border-gray-700">
            <div className="flex justify-between items-center">
              <div className="flex gap-2">
                {selectedItems.size > 0 && (
                  <button 
                    onClick={() => setSelectedItems(new Map())}
                    className="px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600 text-sm"
                  >
                    Clear Selection
                  </button>
                )}
              </div>
              <div className="flex gap-3">
                <button 
                  onClick={onClose}
                  className="px-4 py-2 bg-gray-700 rounded-lg hover:bg-gray-600"
                >
                  Cancel
                </button>
                {selectedItems.size > 0 && (
                  <button 
                    onClick={handleAddSelected}
                    disabled={isAdding}
                    className="px-4 py-2 rounded-lg font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                    style={{
                      backgroundColor: config.theme?.primaryColor || '#38f47cf9',
                      color: config.theme?.primaryColor?.startsWith('#38') ? 'black' : 'white'
                    }}
                  >
                    {isAdding ? (
                      <div className="flex items-center gap-2">
                        <Loader2 className="w-4 h-4 animate-spin" />
                        <span>Adding...</span>
                      </div>
                    ) : (
                      `Add Selected (${selectedItems.size})`
                    )}
                  </button>
                )}
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="constants/fonts.ts">
/**
 * 폰트 옵션 중앙 관리
 * TextEditorModal과 Remotion 렌더링에서 공통 사용
 */

export interface FontOption {
  value: string;
  label: string;
  googleFontUrl?: string; // Google Fonts WOFF2 file URL
  weight?: string;
}

// Google Fonts에서 제공하는 실제 WOFF2 파일 URL
// @remotion/fonts loadFont()에서 직접 로드 가능
export const FONT_OPTIONS: FontOption[] = [
  { 
    value: 'default', 
    label: 'Default' 
  },
  
  // System fonts (no URL needed)
  { 
    value: 'Arial', 
    label: 'Arial' 
  },
  { 
    value: 'Helvetica', 
    label: 'Helvetica' 
  },
  { 
    value: 'Times New Roman', 
    label: 'Times New Roman' 
  },
  { 
    value: 'Georgia', 
    label: 'Georgia' 
  },
  { 
    value: 'Courier New', 
    label: 'Courier New' 
  },
  
  // Modern Sans-Serif (with Google Fonts WOFF2 URLs)
  { 
    value: 'Roboto', 
    label: 'Roboto',
    googleFontUrl: 'https://fonts.gstatic.com/s/roboto/v48/KFOMCnqEu92Fr1ME7kSn66aGLdTylUAMQXC89YmC2DPNWubEbVmZiArmlw.woff2',
    weight: '400'
  },
  { 
    value: 'Roboto', 
    label: 'Roboto Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/roboto/v48/KFOMCnqEu92Fr1ME7kSn66aGLdTylUAMQXC89YmC2DPNWuYjalmZiArmlw.woff2',
    weight: '700'
  },
  { 
    value: 'Open Sans', 
    label: 'Open Sans',
    googleFontUrl: 'https://fonts.gstatic.com/s/opensans/v43/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsjZ0B4taVIGxA.woff2',
    weight: '400'
  },
  { 
    value: 'Open Sans', 
    label: 'Open Sans Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/opensans/v43/memSYaGs126MiZpBA-UvWbX2vVnXBbObj2OVZyOOSr4dVJWUgsg-1x4taVIGxA.woff2',
    weight: '700'
  },
  { 
    value: 'Montserrat', 
    label: 'Montserrat',
    googleFontUrl: 'https://fonts.gstatic.com/s/montserrat/v30/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Hw0aXpsog.woff2',
    weight: '400'
  },
  { 
    value: 'Montserrat', 
    label: 'Montserrat Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/montserrat/v30/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCuM73w0aXpsog.woff2',
    weight: '700'
  },
  { 
    value: 'Poppins', 
    label: 'Poppins',
    googleFontUrl: 'https://fonts.gstatic.com/s/poppins/v23/pxiEyp8kv8JHgFVrJJbecmNE.woff2',
    weight: '400'
  },
  { 
    value: 'Poppins', 
    label: 'Poppins Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/poppins/v23/pxiByp8kv8JHgFVrLCz7Z11lFc-K.woff2',
    weight: '700'
  },
  
  // Serif
  { 
    value: 'Playfair Display', 
    label: 'Playfair Display',
    googleFontUrl: 'https://fonts.gstatic.com/s/playfairdisplay/v39/nuFvD-vYSZviVYUb_rj3ij__anPXJzDwcbmjWBN2PKdFvXDTbtPY_Q.woff2',
    weight: '400'
  },
  { 
    value: 'Playfair Display', 
    label: 'Playfair Display Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/playfairdisplay/v39/nuFvD-vYSZviVYUb_rj3ij__anPXJzDwcbmjWBN2PKeiunDTbtPY_Q.woff2',
    weight: '700'
  },
  { 
    value: 'Merriweather', 
    label: 'Merriweather',
    googleFontUrl: 'https://fonts.gstatic.com/s/merriweather/v32/u-4D0qyriQwlOrhSvowK_l5UcA6zuSYEqOzpPe3HOZJ5eX1WtLaQwmYiScCmDxhtNOKl8yDr3icaGV31GvU.woff2',
    weight: '400'
  },
  { 
    value: 'Merriweather', 
    label: 'Merriweather Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/merriweather/v32/u-4D0qyriQwlOrhSvowK_l5UcA6zuSYEqOzpPe3HOZJ5eX1WtLaQwmYiScCmDxhtNOKl8yDrOSAaGV31GvU.woff2',
    weight: '700'
  },
  
  // Script & Casual
  { 
    value: 'Dancing Script', 
    label: 'Dancing Script',
    googleFontUrl: 'https://fonts.gstatic.com/s/dancingscript/v28/If2cXTr6YS-zF4S-kcSWSVi_sxjsohD9F50Ruu7BMSo3Rep8ltA.woff2',
    weight: '400'
  },
  { 
    value: 'Dancing Script', 
    label: 'Dancing Script Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/dancingscript/v28/If2cXTr6YS-zF4S-kcSWSVi_sxjsohD9F50Ruu7B1i03Rep8ltA.woff2',
    weight: '700'
  },
  { 
    value: 'Pacifico', 
    label: 'Pacifico',
    googleFontUrl: 'https://fonts.gstatic.com/s/pacifico/v22/FwZY7-Qmy14u9lezJ-6K6MmTpA.woff2',
    weight: '400'
  },
  { 
    value: 'Lobster', 
    label: 'Lobster',
    googleFontUrl: 'https://fonts.gstatic.com/s/lobster/v31/neILzCirqoswsqX9zo-mM5Ez.woff2',
    weight: '400'
  },
  
  // Display & Impact
  { 
    value: 'Bebas Neue', 
    label: 'Bebas Neue',
    googleFontUrl: 'https://fonts.gstatic.com/s/bebasneue/v15/JTUSjIg69CK48gW7PXoo9Wdhyzbi.woff2',
    weight: '400'
  },
  { 
    value: 'Oswald', 
    label: 'Oswald',
    googleFontUrl: 'https://fonts.gstatic.com/s/oswald/v56/TK3_WkUHHAIjg75cFRf3bXL8LICs1_FvsUtiZTaR.woff2',
    weight: '400'
  },
  { 
    value: 'Oswald', 
    label: 'Oswald Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/oswald/v56/TK3_WkUHHAIjg75cFRf3bXL8LICs1xZosUtiZTaR.woff2',
    weight: '700'
  },
  
  // Korean - 한글 폰트 (subset 포함)
  { 
    value: 'Noto Sans KR', 
    label: 'Noto Sans KR',
    googleFontUrl: 'https://fonts.gstatic.com/s/notosanskr/v37/PbyxFmXiEBPT4ITbgNA5Cgms3VYcOA-vvnIzzuoyeLGC5nwuDo-KBTUm6CryotyJROlrnQ.0.woff2',
    weight: '400'
  },
  { 
    value: 'Noto Sans KR', 
    label: 'Noto Sans KR Bold',
    googleFontUrl: 'https://fonts.gstatic.com/s/notosanskr/v37/PbyxFmXiEBPT4ITbgNA5Cgms3VYcOA-vvnIzzg01eLGC5nwuDo-KBTUm6CryotyJROlrnQ.0.woff2',
    weight: '700'
  },
];

// 폰트 패밀리별로 그룹화 (UI 표시용)
export const FONT_FAMILIES = [
  { value: 'default', label: 'Default' },
  { value: 'Arial', label: 'Arial' },
  { value: 'Helvetica', label: 'Helvetica' },
  { value: 'Times New Roman', label: 'Times New Roman' },
  { value: 'Georgia', label: 'Georgia' },
  { value: 'Courier New', label: 'Courier New' },
  { value: 'Roboto', label: 'Roboto' },
  { value: 'Open Sans', label: 'Open Sans' },
  { value: 'Montserrat', label: 'Montserrat' },
  { value: 'Poppins', label: 'Poppins' },
  { value: 'Playfair Display', label: 'Playfair Display' },
  { value: 'Merriweather', label: 'Merriweather' },
  { value: 'Dancing Script', label: 'Dancing Script' },
  { value: 'Pacifico', label: 'Pacifico' },
  { value: 'Lobster', label: 'Lobster' },
  { value: 'Bebas Neue', label: 'Bebas Neue' },
  { value: 'Oswald', label: 'Oswald' },
  { value: 'Noto Sans KR', label: 'Noto Sans KR' },
];

// 시스템 폰트 확인
export function isSystemFont(fontFamily: string): boolean {
  const systemFonts = [
    'default',
    'Arial',
    'Helvetica',
    'Times New Roman',
    'Georgia',
    'Courier New',
    'Verdana',
    'Tahoma',
    'Impact',
    'sans-serif',
    'serif',
    'monospace',
  ];
  
  return systemFonts.includes(fontFamily);
}

// 폰트가 지원되는지 확인
export function isSupportedFont(fontFamily: string): boolean {
  return FONT_FAMILIES.some(f => f.value === fontFamily) || isSystemFont(fontFamily);
}
</file>

<file path="docs/features/image-brush-deployment.md">
# Image Brush 기능 배포 가이드

## 개요
Image Brush는 AI를 활용한 이미지 인페인팅 기능으로, BFL FLUX Fill API를 통해 마스크 기반 이미지 편집을 제공합니다.

## 필수 사항

### 1. BFL API 토큰 발급
1. [BFL.ai](https://bfl.ai) 계정 생성
2. API Keys 섹션에서 토큰 생성
3. `.env.local`에 추가: `BFL_TOKEN=your-token`

### 2. Supabase 설정

#### 2.1 데이터베이스 테이블 생성
```bash
# Supabase 대시보드 SQL Editor에서 실행
# 또는 마이그레이션 파일 실행
npx supabase@latest db push --project-ref YOUR_PROJECT_REF
```

`supabase/migrations/20240119_create_image_brush_history.sql` 파일 내용을 실행하여 테이블 생성

**중요**: 이 테이블은 RLS가 **비활성화**되어 있습니다. 보안을 위해:
- 클라이언트에서 직접 접근 불가
- Next.js API Route를 통해서만 접근 가능
- Service Role Key 사용 필수

#### 2.2 Edge Function 배포
```bash
# 환경 변수 설정
export SUPABASE_ACCESS_TOKEN="your-access-token"

# Edge Function 배포
cd /Users/srlee/Desktop/커서개발/3. 서비스/voguedrop
npx supabase@latest functions deploy image-brush --project-ref YOUR_PROJECT_REF

# 배포 확인
npx supabase@latest functions list --project-ref YOUR_PROJECT_REF
```

#### 2.3 Edge Function 환경 변수 설정
```bash
# BFL API 토큰 설정 (필수)
npx supabase@latest secrets set BFL_TOKEN=your-bfl-token --project-ref YOUR_PROJECT_REF

# RunPod 설정 (선택사항 - I2I 모드용)
npx supabase@latest secrets set RUNPOD_API_KEY=your-key --project-ref YOUR_PROJECT_REF
npx supabase@latest secrets set RUNPOD_ENDPOINT_ID=your-id --project-ref YOUR_PROJECT_REF
```

### 3. 로컬 환경 설정

#### 3.1 환경 변수 파일 생성
`.env.local` 파일에 다음 추가:
```env
# Supabase Functions URL (필수)
NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL=https://YOUR_PROJECT_REF.supabase.co/functions/v1

# Supabase Service Key (필수 - 서버 사이드에서만 사용)
SUPABASE_SERVICE_KEY=your-service-role-key

# BFL Token (로컬 테스트용 - Edge Function에서는 별도 설정)
BFL_TOKEN=your-bfl-api-token
```

**보안 주의사항**:
- `SUPABASE_SERVICE_KEY`는 절대 클라이언트에 노출되면 안 됩니다
- `.env.local`은 `.gitignore`에 포함되어야 합니다
- Vercel 배포 시 Environment Variables에 안전하게 저장하세요

## 기능 테스트

### 1. 로컬 개발 서버 실행
```bash
npm run dev
```

### 2. 기능 테스트 순서
1. Canvas 페이지 접속 (`/canvas`)
2. 이미지 업로드 (드래그 앤 드롭 또는 클릭)
3. "Image Brush" 버튼 클릭
4. 마스크 영역 그리기 (브러시 도구 사용)
5. 프롬프트 입력 (예: "add floral pattern", "expand clothing")
6. "AI로 생성하기" 클릭
7. 처리 완료 후 결과 확인

### 3. Edge Function 로그 확인
```bash
# 실시간 로그 스트리밍
npx supabase@latest functions logs image-brush --project-ref YOUR_PROJECT_REF --tail

# 최근 100개 로그
npx supabase@latest functions logs image-brush --project-ref YOUR_PROJECT_REF --tail 100
```

## 트러블슈팅

### 🔴 문제: BFL API 에러
**증상**: "BFL API error: 401" 에러 발생

**해결**:
1. BFL 토큰이 올바른지 확인
2. Edge Function 환경 변수 재설정:
```bash
npx supabase@latest secrets set BFL_TOKEN=correct-token --project-ref YOUR_PROJECT_REF
```

### 🔴 문제: CORS 에러
**증상**: 브라우저 콘솔에 CORS 에러 표시

**해결**:
1. Edge Function이 OPTIONS 요청을 처리하는지 확인
2. `supabase/functions/_shared/cors.ts` 파일 확인
3. Edge Function 재배포

### 🔴 문제: 이미지 크기 제한
**증상**: "이미지 크기는 10MB를 초과할 수 없습니다" 에러

**해결**:
1. 클라이언트에서 이미지 리사이징 (최대 1024x1024)
2. Canvas 크기 제한 확인 (ImageBrushModal.tsx)

### 🔴 문제: 처리 시간 초과
**증상**: 2분 이상 처리 시 타임아웃

**해결**:
1. 이미지 크기 줄이기
2. 더 간단한 프롬프트 사용
3. BFL API 상태 확인 (https://status.bfl.ai)

## 프로덕션 배포

### 1. Vercel 배포
```bash
# 환경 변수 설정
vercel env add NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL

# 배포
vercel --prod
```

### 2. 모니터링
- Supabase Dashboard > Edge Functions에서 실행 통계 확인
- 에러 로그 모니터링
- API 사용량 추적 (BFL Dashboard)

## API 사용량 관리

### BFL API 제한
- 무료 티어: 100 요청/일
- 유료 티어: 요청당 과금
- 권장: 사용자별 일일 제한 구현

### 사용량 추적 (API Route 사용)
```javascript
// 히스토리 조회 API 호출
const response = await fetch('/api/canvas/image-brush/history?limit=10');
const { items, total } = await response.json();

// 특정 항목 삭제
await fetch('/api/canvas/image-brush/history', {
  method: 'DELETE',
  body: JSON.stringify({ id: itemId })
});
```

**주의**: RLS가 비활성화되어 있으므로 반드시 API Route를 통해서만 접근해야 합니다.

## 보안 고려사항

1. **API 키 보호**: 
   - Service Role Key는 서버 사이드에서만 사용
   - 절대 클라이언트 코드에 노출 금지
   - 환경 변수는 `.env.local`에만 저장

2. **데이터베이스 접근 제어**:
   - RLS 비활성화로 클라이언트 직접 접근 차단
   - 모든 데이터베이스 작업은 API Route를 통해서만 수행
   - Service Role Key로 서버 사이드 인증

3. **인증 필수**: 
   - 모든 API Route에서 JWT 토큰 검증
   - 사용자별 데이터 격리

4. **Rate Limiting**: 
   - 사용자별 요청 제한 구현 권장
   - BFL API 사용량 모니터링

5. **이미지 검증**: 
   - 업로드된 이미지 타입 및 크기 검증
   - Base64 크기 제한 (10MB)

## 성능 최적화

1. **이미지 압축**: 클라이언트에서 이미지 압축 후 전송
2. **캐싱**: 동일한 요청에 대한 결과 캐싱
3. **비동기 처리**: 긴 처리 시간을 위한 Job Queue 구현 고려

## 향후 개선사항

1. **I2I 모드 구현**: RunPod API 통합
2. **배치 처리**: 여러 이미지 동시 처리
3. **프리셋 저장**: 자주 사용하는 프롬프트 저장
4. **히스토리 관리**: 이전 편집 결과 관리 UI

## 참고 자료
- [BFL API Documentation](https://docs.bfl.ai)
- [Supabase Edge Functions](https://supabase.com/docs/guides/functions)
- [Image Brush 구현 문서](/docs/task/task_image_brush.md)
</file>

<file path="docs/task/task.md">
# LibraryModal 리팩토링 작업 계획

## 개요
VideoLibraryModal과 LibraryModal 컴포넌트의 90% 이상 중복 코드를 제거하고 공통 컴포넌트로 리팩토링

## 현재 상황 분석

### 공통 기능 (90% 동일)
- 데이터 페칭 로직 (`/api/canvas/library` 호출)
- 카테고리 관리 (clips, projects, uploads)
- 파일 업로드 처리 (썸네일 추출 포함)
- UI 레이아웃 구조
- 카드 렌더링 로직 (9:16 비율 고정, 레터박싱)
- 에러/로딩 상태 관리

### 핵심 차이점
1. **VideoLibraryModal (선택 모드)**
   - 다중 선택 기능 (최대 10개)
   - 선택 순서 표시
   - `onAddToTimeline` 콜백
   - 녹색 테마 (#38f47cf9)

2. **LibraryModal (뷰 모드)**
   - 즐겨찾기 토글
   - 날짜 필터링
   - 다운로드 기능
   - Primary 색상 테마

## 작업 목록

### 1. ✅ 새로운 library 폴더 구조 생성 및 타입 정의
- [x] `/components/modals/library/` 폴더 생성
- [x] `/types/library-modal.ts` 타입 정의 파일 생성
  - LibraryModalConfig 인터페이스
  - 모드별 설정 타입

### 2. ✅ 공통 훅 useLibraryData 생성
- [x] `/components/modals/library/hooks/useLibraryData.ts` 생성
- [x] 데이터 페칭 로직 추출
- [x] 에러 처리 및 로딩 상태 관리

### 3. ✅ 공통 컴포넌트 생성
- [x] `/components/modals/library/components/LibraryCard.tsx`
  - 클립/프로젝트/업로드 카드 통합
  - 선택/즐겨찾기/다운로드 기능 조건부 렌더링
- [x] `/components/modals/library/components/LibrarySidebar.tsx`
  - 카테고리 선택 UI
  - 날짜 필터 (조건부)
- [x] `/components/modals/library/components/LibraryUpload.tsx`
  - 파일 업로드 섹션
  - 진행률 표시
- [x] `/components/modals/library/utils/constants.ts`
  - CARD_CONTAINER_CLASS
  - getContentFitStyle 함수

### 4. ✅ LibraryModalBase 베이스 컴포넌트 생성
- [x] `/components/modals/library/LibraryModalBase.tsx` 생성
- [x] config 기반 조건부 렌더링
- [x] 선택/즐겨찾기 모드 통합

### 5. ✅ VideoLibraryModal을 래퍼 컴포넌트로 변경
- [x] 기존 코드를 28줄로 축소 (755줄 → 28줄, 96% 감소)
- [x] LibraryModalBase 사용
- [x] 선택 모드 config 전달

### 6. ✅ LibraryModal을 래퍼 컴포넌트로 변경
- [x] 기존 코드를 37줄로 축소 (810줄 → 37줄, 95% 감소)
- [x] LibraryModalBase 사용
- [x] 뷰 모드 config 전달

### 7. ✅ 테스트 및 빌드 확인
- [x] 타입 에러 확인 (`npm run build`) - ✅ 성공
- [x] ESLint 검사 (`npm run lint`) - ✅ No warnings or errors
- [ ] 기능 테스트 (수동 테스트 필요)
  - VideoLibraryModal: 선택 및 타임라인 추가
  - LibraryModal: 즐겨찾기 및 다운로드

## 예상 결과

### 코드 개선
- **중복 코드 감소**: 각 760줄 → 약 80줄로 축소
- **전체 코드량**: 1,520줄 → 약 500줄 (67% 감소)

### 품질 개선
- **일관성**: 두 모달의 UI와 동작 통일
- **유지보수성**: 한 곳에서 버그 수정 및 기능 개선
- **확장성**: 새로운 모드 추가 용이
- **테스트 용이성**: 공통 컴포넌트만 테스트


## 참고 사항
- 모든 카드는 9:16 비율로 고정 (CARD_CONTAINER_CLASS)
- 콘텐츠 비율에 따라 레터박싱 처리 (getContentFitStyle)
- extractVideoThumbnail 함수 활용하여 썸네일 생성
- TypeScript strict 모드 준수
</file>

<file path="docs/storage-structure.md">
# Storage 구조 가이드

## 개요
VogueDrop의 모든 사용자 업로드 파일은 `user-upload` 버킷에 카테고리별로 체계적으로 저장됩니다.

## Storage 버킷 구조

### 단일 버킷: `user-upload`
모든 사용자 업로드 파일은 하나의 버킷에서 관리됩니다.

```
user-upload/
├── image/                    # 이미지 파일
│   └── {user_id}/
│       └── {timestamp}-{random}.{ext}
│
├── video/                    # 비디오 파일
│   └── {user_id}/
│       ├── {timestamp}_{filename}.mp4
│       └── thumbnails/       # 비디오 썸네일
│           └── {timestamp}_thumbnail.jpg
│
└── music/                    # 음악/오디오 파일
    └── {user_id}/
        └── {timestamp}_{filename}.{ext}
```

## 파일 업로드 API

### 1. 이미지 업로드
- **엔드포인트**: `lib/supabase/storage.ts`의 `uploadImage()` 함수
- **경로 형식**: `image/{user_id}/{timestamp}-{random}.{ext}`
- **지원 형식**: JPG, PNG, GIF, WebP
- **최대 크기**: 5MB

### 2. 비디오 업로드
- **엔드포인트**: `/api/upload/video`
- **경로 형식**: `video/{user_id}/{timestamp}_{filename}.mp4`
- **썸네일**: `video/{user_id}/thumbnails/{timestamp}_thumbnail.jpg`
- **지원 형식**: MP4, WebM, MOV, AVI
- **최대 크기**: 20MB
- **DB 테이블**: `user_uploaded_videos`

### 3. 음악 업로드
- **엔드포인트**: `/api/upload/music`
- **경로 형식**: `music/{user_id}/{timestamp}_{filename}.{ext}`
- **지원 형식**: MP3, WAV, M4A, OGG, WebM, FLAC
- **최대 크기**: 10MB
- **DB 테이블**: `user_uploaded_music`

## 보안 처리

### API Router 기반 보안
- 모든 업로드/삭제 작업은 API Route를 통해 처리
- Service Client를 사용하여 RLS 정책 우회
- 각 요청에서 사용자 인증 상태 확인

```typescript
// 인증 확인 예시
const supabase = await createClient();
const { data: { user } } = await supabase.auth.getUser();
if (!user) {
  return NextResponse.json({ error: '로그인이 필요합니다.' }, { status: 401 });
}
```

### 파일 검증
- 파일 크기 제한 체크
- MIME 타입 검증
- 파일명 sanitization (특수문자 제거)

## 데이터베이스 구조

### user_uploaded_videos 테이블
```sql
- id: BIGSERIAL PRIMARY KEY
- user_id: UUID (auth.users 참조)
- file_name: TEXT
- storage_path: TEXT
- file_size: BIGINT
- duration: FLOAT
- aspect_ratio: TEXT
- thumbnail_url: TEXT
- metadata: JSONB
- is_deleted: BOOLEAN
- uploaded_at: TIMESTAMP
```

### user_uploaded_music 테이블
```sql
- id: BIGSERIAL PRIMARY KEY
- user_id: UUID (auth.users 참조)
- file_name: TEXT
- storage_path: TEXT
- file_size: BIGINT
- duration: FLOAT
- metadata: JSONB
- is_deleted: BOOLEAN
- uploaded_at: TIMESTAMP
```

## 파일 접근

### 공개 URL 생성
```typescript
const { data: { publicUrl } } = supabase.storage
  .from('user-upload')
  .getPublicUrl(storagePath);
```

### 파일 삭제 (Soft Delete)
- DB에서 `is_deleted` 플래그를 true로 설정
- 실제 Storage 파일은 유지 (필요시 별도 배치 작업으로 정리)

## 마이그레이션 노트

### 기존 파일 호환성
- 기존 `user-uploads` 버킷의 파일들은 그대로 유지
- 기존 `videos` 버킷의 파일들은 그대로 유지
- 새로운 업로드만 새 구조 적용

### 점진적 마이그레이션
필요시 다음 스크립트로 기존 파일 마이그레이션 가능:
```sql
-- 예시: 기존 경로를 새 경로로 업데이트
UPDATE user_uploaded_videos 
SET storage_path = REPLACE(storage_path, 'user-uploads/', 'video/')
WHERE storage_path LIKE 'user-uploads/%';
```

## 모니터링 및 유지보수

### 사용량 확인
```sql
-- 사용자별 총 업로드 용량
SELECT 
  user_id,
  SUM(CASE WHEN table_name = 'video' THEN file_size ELSE 0 END) / (1024*1024) as video_mb,
  SUM(CASE WHEN table_name = 'music' THEN file_size ELSE 0 END) / (1024*1024) as music_mb,
  SUM(file_size) / (1024*1024) as total_mb
FROM (
  SELECT user_id, file_size, 'video' as table_name FROM user_uploaded_videos WHERE is_deleted = false
  UNION ALL
  SELECT user_id, file_size, 'music' as table_name FROM user_uploaded_music WHERE is_deleted = false
) combined
GROUP BY user_id
ORDER BY total_mb DESC;
```

### 정리 작업
```sql
-- 30일 이상된 삭제 표시 파일 영구 삭제
DELETE FROM user_uploaded_videos 
WHERE is_deleted = true AND updated_at < NOW() - INTERVAL '30 days';

DELETE FROM user_uploaded_music 
WHERE is_deleted = true AND updated_at < NOW() - INTERVAL '30 days';
```
</file>

<file path="docs/timeline-resize-width-zero-bug.md">
# Timeline 클립 리사이즈 시 Width 0 버그 해결 가이드

## 문제 설명

### 증상
비디오 에디터의 Timeline 컴포넌트에서 클립을 리사이즈할 때 다음과 같은 문제가 발생:
- 클립의 왼쪽 핸들을 원본 시작점(startTime=0)에서 더 왼쪽으로 드래그하면 width가 0이 됨
- 클립의 오른쪽 핸들을 원본 끝점(maxDuration)에서 더 오른쪽으로 드래그하면 width가 0이 됨
- 가끔 position도 0으로 리셋되는 현상 발생

### 발생 시나리오
1. 비디오/사운드 클립이 이미 원본 미디어의 전체 구간을 사용 중
2. 사용자가 리사이즈 핸들을 원본 경계를 넘어서 드래그 시도
3. 마우스를 놓으면(mouseUp) 클립이 사라지거나 크기가 0이 됨

## 근본 원인

### 1. DOM 스타일 초기화 문제
```javascript
// 문제가 되는 코드
clipElement.style.width = '';  // 인라인 스타일 제거
clipElement.style.left = '';
```
- React 컴포넌트가 리렌더링되기 전에 인라인 스타일을 제거하면 클립의 width가 undefined 상태가 됨
- CSS에 기본 width가 정의되어 있지 않으면 브라우저가 width를 0으로 처리

### 2. 상태 동기화 문제
```javascript
// mouseMove에서 블로킹 시
if (isBlocked) {
  // DOM은 업데이트하지 않지만 상태는 저장해야 함
  setFinalResizeWidth(newWidth);   // 이 부분이 누락되면 문제 발생
  setFinalResizePosition(newPosition);
}
```
- 블로킹 상태에서도 최종 값을 상태로 저장해야 mouseUp에서 올바른 값 사용 가능
- 상태 저장을 건너뛰면 mouseUp에서 잘못된 값으로 업데이트 시도

### 3. React 상태 업데이트 비동기성
```javascript
onResizeVideoClip(activeClip, clampedWidth);  // 비동기 상태 업데이트
clipElement.style.width = '';  // 즉시 실행 - 문제 발생!
```
- React의 setState는 비동기로 처리되어 즉시 DOM에 반영되지 않음
- 인라인 스타일을 먼저 제거하면 상태 업데이트가 적용되기 전에 클립이 사라짐

## 해결 방법

### 1. 인라인 스타일 유지
```javascript
// 해결책: 스타일을 제거하지 않고 유지
// React가 다음 렌더링 사이클에서 상태 기반으로 스타일을 덮어씀
// clipElement.style.width = '';  // 이 줄을 제거!
```

### 2. 블로킹 상태에서도 유효한 값 저장
```javascript
// 블로킹 여부와 관계없이 항상 유효한 값 저장
setFinalResizeWidth(newWidth);
setFinalResizePosition(newPosition);

if (!isBlocked) {
  // DOM 업데이트는 블로킹되지 않은 경우에만
  clipElement.style.width = `${newWidth}px`;
}
```

### 3. 안전장치 추가
```javascript
// applyResizeTrim 함수에 최소 너비 보장
const safeDuration = Math.max(80, newDurationPx);  // 최소 80px

// handleResizeVideoClip에서 유효성 검증
if (newDuration <= 0) {
  console.error('Invalid duration:', newDuration);
  return;  // 잘못된 값으로 업데이트 방지
}
```

## 구현 체크리스트

### Timeline.tsx 수정사항
- [ ] mouseMove에서 블로킹 상태와 관계없이 `finalResizeWidth/Position` 저장
- [ ] mouseUp에서 인라인 스타일 제거 코드 삭제
- [ ] 블로킹된 상태에서 불필요한 업데이트 호출 방지

### clip-operations.ts 수정사항
- [ ] `applyResizeTrim` 함수에 최소 너비(80px) 보장 로직 추가
- [ ] duration 계산 시 `safeDuration` 사용

### page.tsx 수정사항
- [ ] `handleResizeVideoClip`에 0 이하 값 검증 추가

## 테스트 시나리오

1. **왼쪽 경계 테스트**
   - 클립의 startTime이 0인 상태에서 왼쪽 핸들을 더 왼쪽으로 드래그
   - 마우스 놓았을 때 클립이 원래 크기 유지하는지 확인

2. **오른쪽 경계 테스트**
   - 클립이 maxDuration에 도달한 상태에서 오른쪽 핸들을 더 오른쪽으로 드래그
   - 마우스 놓았을 때 클립이 원래 크기 유지하는지 확인

3. **정상 리사이즈 테스트**
   - 경계 내에서 리사이즈가 정상 작동하는지 확인
   - 인접 클립과의 충돌 감지가 작동하는지 확인

## 주의사항

1. **절대 인라인 스타일을 즉시 제거하지 말 것**
   - React 상태 업데이트가 완료될 때까지 기다려야 함
   - 필요하다면 `setTimeout(() => {}, 0)` 사용

2. **블로킹 로직과 상태 저장을 분리**
   - 블로킹은 DOM 업데이트만 방지
   - 상태 저장은 항상 수행

3. **최소값 보장**
   - width는 항상 MIN_CLIP_WIDTH(80px) 이상
   - position은 항상 0 이상

## 관련 파일
- `/app/video-editor/_components/Timeline.tsx` - 메인 타임라인 컴포넌트
- `/app/video-editor/_utils/clip-operations.ts` - 클립 조작 유틸리티
- `/app/video-editor/page.tsx` - 리사이즈 핸들러 함수

## 참고사항
이 문제는 DOM 조작과 React 상태 관리의 타이밍 차이에서 발생하는 전형적인 문제입니다. React의 선언적 UI 패러다임과 명령형 DOM 조작을 혼용할 때 주의가 필요합니다.
</file>

<file path="docs/user-upload-setup-guide.md">
# User Upload 기능 데이터베이스 설정 가이드

## 개요
사용자 업로드 기능은 기존 videos 버킷을 재사용하며, RLS 대신 API Route에서 Service Client를 통해 보안을 처리합니다. 이는 프로젝트 전체의 MVP 패턴을 따릅니다.

## 1. 데이터베이스 테이블 생성

Supabase Dashboard에서 다음 단계를 수행하세요:

1. **SQL Editor** 탭으로 이동
2. 아래 SQL을 실행하여 `user_uploaded_videos` 테이블 생성:

```sql
-- Create user_uploaded_videos table
CREATE TABLE IF NOT EXISTS public.user_uploaded_videos (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    storage_path TEXT NOT NULL,
    file_size BIGINT NOT NULL,
    duration FLOAT,
    aspect_ratio TEXT,
    thumbnail_url TEXT,
    metadata JSONB DEFAULT '{}',
    uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes
CREATE INDEX idx_user_uploaded_videos_user_id ON public.user_uploaded_videos(user_id);
CREATE INDEX idx_user_uploaded_videos_uploaded_at ON public.user_uploaded_videos(uploaded_at DESC);
CREATE INDEX idx_user_uploaded_videos_is_deleted ON public.user_uploaded_videos(is_deleted);

-- DISABLE RLS for MVP (security handled at API level)
ALTER TABLE public.user_uploaded_videos DISABLE ROW LEVEL SECURITY;

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_updated_at
    BEFORE UPDATE ON public.user_uploaded_videos
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- Grant permissions
GRANT ALL ON public.user_uploaded_videos TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.user_uploaded_videos_id_seq TO authenticated;
```

## 2. Storage 버킷 설정

### 2.1 기존 videos 버킷 확인

1. **Storage** 탭으로 이동
2. `videos` 버킷이 이미 존재하는지 확인
3. 버킷이 Public으로 설정되어 있는지 확인

### 2.2 Storage 정책 (MVP에서는 비활성화)

MVP에서는 Storage RLS 정책을 추가하지 않습니다. 모든 파일 작업은 API Route에서 Service Client를 통해 처리됩니다.

**폴더 구조**:
```
videos/
├── ai-generations/     (기존 AI 생성 비디오)
│   └── {job_id}/
│       └── output.mp4
└── user-uploads/       (사용자 업로드 비디오)
    └── {user_id}/
        └── {timestamp}_{filename}.mp4
```

**보안 처리**:
- 업로드: `/api/upload/video` API Route에서 인증 확인 후 Service Client로 처리
- 조회: `/api/canvas/library` API Route에서 user_id 필터링
- 삭제: API Route에서 소유권 확인 후 처리

## 3. 환경 변수 확인

`.env.local` 파일에 다음 변수들이 설정되어 있는지 확인:

```env
NEXT_PUBLIC_SUPABASE_URL=your-project-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key
```

## 4. 테스트

1. 애플리케이션을 실행: `npm run dev`
2. Video Editor 페이지로 이동
3. Video Library 모달 열기
4. Uploads 카테고리 선택
5. "Upload Video" 버튼 클릭
6. 20MB 이하의 비디오 파일 선택
7. 업로드 진행률 확인
8. 업로드 완료 후 라이브러리에 표시되는지 확인

## 5. 문제 해결

### 업로드 실패 시
- Supabase Dashboard에서 Storage 버킷이 생성되었는지 확인
- RLS 정책이 올바르게 설정되었는지 확인
- 환경 변수가 올바른지 확인
- 파일 크기가 20MB를 초과하지 않는지 확인

### 데이터베이스 오류 시
- `user_uploaded_videos` 테이블이 생성되었는지 확인
- RLS가 활성화되어 있는지 확인
- 사용자가 로그인되어 있는지 확인

## 6. 유지보수

### 오래된 업로드 정리 (선택사항)
```sql
-- 30일 이상된 삭제 표시된 파일 영구 삭제
DELETE FROM public.user_uploaded_videos 
WHERE is_deleted = true 
AND updated_at < NOW() - INTERVAL '30 days';
```

### 사용량 모니터링
```sql
-- 사용자별 업로드 용량 확인
SELECT 
    user_id,
    COUNT(*) as file_count,
    SUM(file_size) / (1024 * 1024) as total_mb
FROM public.user_uploaded_videos
WHERE is_deleted = false
GROUP BY user_id
ORDER BY total_mb DESC;
```
</file>

<file path="docs/video-editor-overlay-troubleshooting.md">
# Video Editor 오버레이 시스템 트러블슈팅 가이드

## 개요
이 문서는 Video Editor의 오버레이 시스템(특히 텍스트 편집기)에서 발생할 수 있는 문제와 해결 방법을 정리합니다.

## 주요 문제 사례: TextOverlayEditor 선택 불가 문제 (2025-08-13)

### 문제 상황
- Player 위에 렌더링된 텍스트가 특정 상황에서 선택되지 않음
- 화면 비율 변경 시 텍스트 선택이 작동하지 않음
- 마우스 이벤트가 Player에 가려져 텍스트 편집 불가

### 근본 원인 분석

#### 1. 포인터 이벤트 충돌
```tsx
// ❌ 문제가 있던 코드
<div className="absolute inset-0 z-40">  // 전체 영역을 덮는 컨테이너
  <TextOverlayEditor />
</div>

// ✅ 해결된 코드
<div style={{ 
  zIndex: 50,
  pointerEvents: 'none'  // 컨테이너는 이벤트를 받지 않음
}}>
  <div style={{ pointerEvents: 'auto' }}>  // 내부 요소만 이벤트 받음
    {/* 텍스트 요소들 */}
  </div>
</div>
```

#### 2. 스케일 계산 타이밍 문제
```tsx
// ❌ 문제: DOM 업데이트 전에 계산
const getScale = () => {
  const rect = containerRef.current?.getBoundingClientRect();
  // 비율 변경 직후 이전 크기로 계산됨
}

// ✅ 해결: DOM 업데이트 대기 후 계산
useEffect(() => {
  requestAnimationFrame(() => {
    setForceUpdate(prev => prev + 1);  // 강제 리렌더링
  });
}, [aspectRatio, containerWidth, containerHeight]);
```

#### 3. z-index 계층 구조 혼란
```tsx
// ❌ 문제: 불명확한 z-index 관리
<Player />  // z-index 없음
<TextOverlay className="z-40" />  // Tailwind 클래스 사용

// ✅ 해결: 명시적인 z-index 계층 구조
<Player style={{ zIndex: 0 }} />
<TextOverlay style={{ 
  zIndex: 50,  // 컨테이너
  // 텍스트 요소들
  textElement: { zIndex: isSelected ? 52 : 51 }
}} />
```

## 베스트 프랙티스

### 1. 오버레이 시스템 설계 원칙

#### 포인터 이벤트 관리
- **컨테이너는 항상 `pointerEvents: 'none'`**
- **상호작용이 필요한 요소만 `pointerEvents: 'auto'`**
- 이벤트 버블링을 고려한 `stopPropagation()` 사용

#### z-index 계층 구조
```
0-9:    기본 콘텐츠 (Player, Video)
10-19:  오버레이 효과 (letterbox, gradients)
20-29:  컨트롤 UI (buttons, controls)
30-39:  모달 배경
40-49:  모달 콘텐츠
50-59:  편집 도구 (TextOverlay, Resize handles)
60+:    긴급 알림, 토스트
```

#### 스케일 계산
- **Props 기반 계산 우선**: DOM 측정보다 props 사용
- **비동기 DOM 업데이트 고려**: `requestAnimationFrame` 활용
- **디바운싱 적용**: 빈번한 리사이즈 시 성능 최적화

### 2. 디버깅 체크리스트

#### 텍스트/오버레이가 선택되지 않을 때
1. [ ] 브라우저 개발자 도구에서 요소의 `pointer-events` 확인
2. [ ] z-index 계층 구조 검증
3. [ ] 부모 요소가 이벤트를 가로채는지 확인
4. [ ] `getBoundingClientRect()` 값이 올바른지 확인

#### 비율 변경 시 문제가 발생할 때
1. [ ] 스케일 계산 로직에 `console.log` 추가
2. [ ] DOM 업데이트 타이밍 확인
3. [ ] aspectRatio prop이 제대로 전달되는지 확인
4. [ ] 강제 리렌더링이 필요한지 검토

### 3. 코드 예제

#### 안전한 오버레이 컴포넌트 구조
```tsx
interface OverlayProps {
  children: React.ReactNode;
  containerWidth: number;
  containerHeight: number;
  aspectRatio: string;
}

function SafeOverlay({ children, containerWidth, containerHeight, aspectRatio }: OverlayProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [, forceUpdate] = useState(0);
  
  // 비율 변경 시 리렌더링
  useEffect(() => {
    requestAnimationFrame(() => {
      forceUpdate(prev => prev + 1);
    });
  }, [aspectRatio, containerWidth, containerHeight]);
  
  const getScale = useCallback(() => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (rect && containerWidth && containerHeight) {
      const scaleX = rect.width / containerWidth;
      const scaleY = rect.height / containerHeight;
      return Math.min(scaleX, scaleY);
    }
    return 1;
  }, [containerWidth, containerHeight]);
  
  return (
    <div 
      ref={containerRef}
      style={{
        position: 'absolute',
        inset: 0,
        zIndex: 50,
        pointerEvents: 'none'  // 중요!
      }}
    >
      <div style={{ 
        pointerEvents: 'auto',
        position: 'relative',
        width: '100%',
        height: '100%'
      }}>
        {children}
      </div>
    </div>
  );
}
```

#### 이벤트 처리 패턴
```tsx
function InteractiveElement({ onSelect, id }: Props) {
  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();  // 부모로 이벤트 전파 방지
    e.preventDefault();   // 기본 동작 방지
    onSelect(id);
  };
  
  const handleMouseDown = (e: React.MouseEvent) => {
    e.stopPropagation();
    // 드래그 시작 로직
  };
  
  return (
    <div
      onClick={handleClick}
      onMouseDown={handleMouseDown}
      style={{
        pointerEvents: 'auto',  // 명시적으로 활성화
        cursor: 'pointer',
        // ... 기타 스타일
      }}
    >
      {/* 콘텐츠 */}
    </div>
  );
}
```

## 테스트 시나리오

### 오버레이 시스템 테스트
1. **기본 상호작용**
   - [ ] 텍스트 클릭으로 선택
   - [ ] 빈 공간 클릭으로 선택 해제
   - [ ] 드래그로 위치 이동
   - [ ] 리사이즈 핸들로 크기 조절

2. **비율 변경 테스트**
   - [ ] 9:16 → 1:1 변경 후 텍스트 선택
   - [ ] 1:1 → 16:9 변경 후 텍스트 선택
   - [ ] 비율 변경 중 텍스트 위치 유지

3. **Player 상호작용**
   - [ ] 텍스트가 있어도 Player 재생/일시정지 가능
   - [ ] 타임라인 시크 동작
   - [ ] 스페이스바 단축키 동작

## 관련 파일
- `/app/video-editor/_components/VideoPreview.tsx`
- `/app/video-editor/_components/TextOverlayEditor.tsx`
- `/app/video-editor/_remotion/CompositePreview.tsx`

## 참고 사항
- Remotion Player는 자체적인 이벤트 시스템을 가지고 있음
- Tailwind의 z-index 클래스보다 인라인 스타일이 더 명확함
- React의 렌더링 사이클과 DOM 업데이트는 비동기적임

## 업데이트 로그
- 2025-08-13: 초기 문서 작성 - TextOverlayEditor 선택 문제 해결
</file>

<file path="docs/video-render-setup-guide.md">
# 비디오 렌더링 시스템 완벽 가이드 (초보자용)

## 📌 개요
이 가이드는 AWS Lambda와 Remotion을 사용하여 비디오를 MP4로 렌더링하는 시스템을 처음부터 끝까지 설정하는 방법을 설명합니다.

## 🎯 시스템 아키텍처
```
사용자 → Next.js 앱 → API Route → AWS Lambda → Remotion 렌더링 → S3 저장 → MP4 다운로드
```

---

## 📦 Part 1: 로컬 환경 설정

### 1.1 필요한 패키지 설치

프로젝트 루트에서 실행:
```bash
npm install
```

설치가 완료되면 다음 패키지들이 추가됩니다:
- `@remotion/cli` - Remotion 명령줄 도구
- `@remotion/lambda` - Lambda 렌더링 지원
- `@remotion/bundler` - 비디오 번들링
- `@remotion/renderer` - 비디오 렌더링 엔진
- `@aws-sdk/client-s3` - AWS S3 클라이언트

### 1.2 Remotion Studio에서 테스트

먼저 로컬에서 비디오가 제대로 렌더링되는지 확인합니다:

```bash
# Remotion Studio 실행
npm run remotion:studio
```

브라우저가 열리면:
1. 왼쪽 메뉴에서 `video-mobile`, `video-square`, `video-wide` 중 하나 선택
2. 우측 Props 패널에서 테스트 데이터 입력
3. 재생 버튼으로 미리보기 확인

### 1.3 로컬 렌더링 테스트

```bash
# 테스트 비디오 렌더링 (output.mp4 파일 생성)
npx remotion render src/remotion/index.ts video-mobile output.mp4
```

성공하면 `output.mp4` 파일이 생성됩니다.

---

## 🔧 Part 2: AWS 계정 설정

### 2.1 AWS 계정 생성

1. [AWS 콘솔](https://aws.amazon.com) 접속
2. 계정이 없다면 "Create an AWS Account" 클릭
3. 이메일, 비밀번호, 계정 이름 입력
4. 신용카드 정보 입력 (무료 티어 사용 가능)

### 2.2 IAM 사용자 생성 (보안을 위해 필수)

1. AWS 콘솔에서 **IAM** 서비스 검색
2. 좌측 메뉴에서 **Users** → **Add users** 클릭
3. 사용자 이름: `voguedrop-lambda-user`
4. **Attach policies directly** 선택하고 다음 정책 추가:
   - `AWSLambda_FullAccess`
   - `AmazonS3FullAccess`
   - `CloudWatchLogsFullAccess`
5. **Create user** 클릭

### 2.3 Access Key 생성

1. 생성한 사용자 클릭
2. **Security credentials** 탭
3. **Create access key** 클릭
4. **Command Line Interface (CLI)** 선택
5. Access Key ID와 Secret Access Key 저장 (⚠️ 한 번만 표시됨!)

### 2.4 AWS CLI 설치 및 설정

macOS:
```bash
# Homebrew 사용
brew install awscli

# 또는 공식 설치 프로그램 다운로드
# https://aws.amazon.com/cli/
```

Windows:
```bash
# 공식 설치 프로그램 다운로드
# https://aws.amazon.com/cli/
```

설정:
```bash
aws configure

# 입력할 내용:
AWS Access Key ID [None]: (위에서 받은 Access Key ID)
AWS Secret Access Key [None]: (위에서 받은 Secret Access Key)
Default region name [None]: us-east-1
Default output format [None]: json
```

---

## 🚀 Part 3: AWS 리소스 생성

### 3.1 S3 버킷 생성 (비디오 저장소)

```bash
# 버킷 생성 (이름은 전세계적으로 유일해야 함)
aws s3 mb s3://voguedrop-renders-{your-unique-id}

# 예시:
aws s3 mb s3://voguedrop-renders-20241214
```

버킷 공개 설정 (다운로드 가능하게):
```bash
# 버킷 정책 파일 생성
cat > bucket-policy.json << 'EOF'
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "PublicReadGetObject",
      "Effect": "Allow",
      "Principal": "*",
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::voguedrop-renders-{your-unique-id}/*"
    }
  ]
}
EOF

# 정책 적용
aws s3api put-bucket-policy --bucket voguedrop-renders-{your-unique-id} --policy file://bucket-policy.json
```

### 3.2 Lambda 함수용 IAM 역할 생성

```bash
# 신뢰 정책 파일 생성
cat > trust-policy.json << 'EOF'
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "lambda.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
EOF

# 역할 생성
aws iam create-role \
  --role-name voguedrop-lambda-role \
  --assume-role-policy-document file://trust-policy.json

# 필요한 정책 연결
aws iam attach-role-policy \
  --role-name voguedrop-lambda-role \
  --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

aws iam attach-role-policy \
  --role-name voguedrop-lambda-role \
  --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
```

---

## 💻 Part 4: Remotion Lambda 배포

### 4.1 Remotion Lambda 함수 배포

```bash
# Remotion이 제공하는 Lambda 함수 자동 배포
npx remotion lambda functions deploy
```

이 명령어가 하는 일:
- Lambda 함수 생성
- 필요한 권한 설정
- Chrome 브라우저 레이어 추가

성공하면 다음과 같은 메시지가 나타납니다:
```
✅ Deployed function "remotion-render-{region}"
```

### 4.2 Remotion 사이트 배포

```bash
# Remotion 번들을 S3에 업로드
npx remotion lambda sites create src/remotion/index.ts --site-name=voguedrop
```

성공하면 URL이 출력됩니다:
```
✅ Site uploaded to: https://remotionlambda-{id}.s3.amazonaws.com/sites/voguedrop/index.html
```

⚠️ **이 URL을 복사해서 저장하세요!**

---

## 🔐 Part 5: 환경 변수 설정

### 5.1 로컬 환경 변수 (.env.local)

프로젝트 루트에 `.env.local` 파일 생성:

```bash
# Supabase (기존 설정)
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_KEY=your-service-key

# AWS Lambda 설정
LAMBDA_RENDER_ENDPOINT=local
REMOTION_SERVE_URL=https://remotionlambda-{id}.s3.amazonaws.com/sites/voguedrop/index.html
AWS_S3_BUCKET_NAME=voguedrop-renders-{your-unique-id}
AWS_REGION=us-east-1
LAMBDA_FUNCTION_NAME=remotion-render-us-east-1

# AWS 자격 증명 (선택사항 - aws configure로 설정했다면 불필요)
AWS_ACCESS_KEY_ID=your-access-key
AWS_SECRET_ACCESS_KEY=your-secret-key
```

### 5.2 로컬 테스트용 API Route 수정

`app/api/video/render/route.ts` 파일을 수정하여 로컬 테스트를 지원하도록 합니다:

```typescript
// 파일 상단에 추가
import { renderMedia } from '@remotion/renderer';
import { bundle } from '@remotion/bundler';
import path from 'path';

// POST 함수 내부 수정
if (process.env.LAMBDA_RENDER_ENDPOINT === 'local') {
  // 로컬 렌더링 (개발용)
  const bundleLocation = await bundle({
    entryPoint: path.join(process.cwd(), 'src/remotion/index.ts'),
    webpackOverride: (config) => config,
  });

  const outputPath = path.join(process.cwd(), `output-${Date.now()}.mp4`);
  
  await renderMedia({
    composition: getCompositionId(aspectRatio),
    serveUrl: bundleLocation,
    codec: 'h264',
    outputLocation: outputPath,
    inputProps: {
      videoClips,
      textClips,
      soundClips,
    },
  });

  // 로컬 파일 URL 반환
  return NextResponse.json({
    success: true,
    url: `/api/video/download?file=${path.basename(outputPath)}`,
    renderId: 'local',
  });
} else {
  // 기존 Lambda 코드...
}
```

---

## 🧪 Part 6: 테스트

### 6.1 로컬 테스트

1. 개발 서버 시작:
```bash
npm run dev
```

2. 브라우저에서 `http://localhost:3000/video-editor` 접속

3. 비디오 클립 추가하고 Download 버튼 클릭

4. 콘솔에서 에러 확인:
```bash
# 브라우저 개발자 도구 (F12) → Console 탭
# 터미널의 Next.js 로그
```

### 6.2 Lambda 테스트

AWS 콘솔에서:
1. Lambda 서비스로 이동
2. `remotion-render-us-east-1` 함수 선택
3. **Test** 탭 클릭
4. 테스트 이벤트 생성:

```json
{
  "videoClips": [
    {
      "id": "test-1",
      "url": "https://example.com/video.mp4",
      "duration": 300,
      "position": 0
    }
  ],
  "textClips": [],
  "soundClips": [],
  "aspectRatio": "9:16",
  "durationInFrames": 300
}
```

5. **Test** 버튼 클릭

---

## 🌐 Part 7: 프로덕션 배포

### 7.1 API Gateway 설정 (Lambda를 HTTP로 접근)

1. AWS 콘솔에서 **API Gateway** 서비스 검색
2. **Create API** → **REST API** → **Build**
3. API 이름: `voguedrop-api`
4. **Create API** 클릭

5. 리소스 생성:
   - **Actions** → **Create Resource**
   - Resource Name: `render`
   - **Create Resource** 클릭

6. 메서드 생성:
   - `render` 선택 → **Actions** → **Create Method** → **POST**
   - Integration type: **Lambda Function**
   - Lambda Function: `remotion-render-us-east-1`
   - **Save** 클릭

7. 배포:
   - **Actions** → **Deploy API**
   - Stage name: `prod`
   - **Deploy** 클릭

8. URL 복사:
   ```
   https://{api-id}.execute-api.us-east-1.amazonaws.com/prod/render
   ```

### 7.2 Vercel 환경 변수 설정

Vercel 대시보드에서:
1. 프로젝트 설정 → Environment Variables
2. 다음 변수 추가:
   ```
   LAMBDA_RENDER_ENDPOINT=https://{api-id}.execute-api.us-east-1.amazonaws.com/prod/render
   REMOTION_SERVE_URL=https://remotionlambda-{id}.s3.amazonaws.com/sites/voguedrop/index.html
   AWS_S3_BUCKET_NAME=voguedrop-renders-{your-unique-id}
   AWS_REGION=us-east-1
   AWS_ACCESS_KEY_ID=your-access-key
   AWS_SECRET_ACCESS_KEY=your-secret-key
   ```

3. **Save** 후 재배포

---

## 🐛 문제 해결

### 자주 발생하는 에러와 해결법

#### 1. "Access Denied" 에러
```bash
# IAM 역할 권한 확인
aws iam list-attached-role-policies --role-name voguedrop-lambda-role
```

#### 2. "Timeout" 에러
Lambda 함수 설정에서:
- Timeout: 15분 (900초)
- Memory: 3008 MB

#### 3. "CORS" 에러
API Gateway에서:
1. 리소스 선택 → **Actions** → **Enable CORS**
2. 모든 옵션 체크 → **Enable CORS**

#### 4. 렌더링이 너무 오래 걸림
- 비디오 길이 줄이기
- 해상도 낮추기 (1080p → 720p)
- Lambda 메모리 증가

### 로그 확인

```bash
# CloudWatch 로그 확인
aws logs tail /aws/lambda/remotion-render-us-east-1 --follow

# S3 버킷 내용 확인
aws s3 ls s3://voguedrop-renders-{your-unique-id}/
```

---

## 💰 비용 관리

### 예상 비용 (월 기준)
- Lambda: 1000개 렌더링 시 약 $5-10
- S3: 100GB 저장 시 약 $2.3
- API Gateway: 10,000 요청 시 약 $0.035

### 비용 절감 팁
1. 렌더링된 비디오 자동 삭제 설정
2. Lambda 메모리 최적화
3. 불필요한 리렌더링 방지

---

## 📚 추가 리소스

- [Remotion 공식 문서](https://www.remotion.dev/)
- [AWS Lambda 가이드](https://docs.aws.amazon.com/lambda/)
- [Remotion Lambda 문서](https://www.remotion.dev/docs/lambda)

## 🆘 도움이 필요하신가요?

각 단계에서 막히는 부분이 있다면:
1. 에러 메시지를 정확히 복사
2. 어느 단계에서 발생했는지 확인
3. CloudWatch 로그 확인
4. 환경 변수가 올바르게 설정되었는지 확인
</file>

<file path="lambda/deploy-instructions.md">
# AWS Lambda 배포 가이드

## 사전 준비사항

1. AWS CLI 설치 및 설정
```bash
aws configure
# AWS Access Key ID 입력
# AWS Secret Access Key 입력
# Default region: us-east-1 (또는 원하는 region)
# Default output format: json
```

2. 필요한 패키지 설치
```bash
npm install
```

## Lambda 함수 배포 단계

### 1. Remotion Lambda 초기 설정

```bash
# Lambda 함수 배포 (처음 한 번만)
npx remotion lambda functions deploy
```

### 2. Remotion 사이트 배포

```bash
# Remotion 번들을 S3에 업로드
npm run remotion:lambda:sites

# 또는 직접 명령어 실행
npx remotion lambda sites create src/remotion/index.ts --site-name=voguedrop
```

이 명령어는 S3에 Remotion 번들을 업로드하고 URL을 반환합니다.
반환된 URL을 `REMOTION_SERVE_URL` 환경변수에 저장하세요.

### 3. Lambda 함수 코드 업데이트

1. Lambda 함수 코드 압축:
```bash
cd lambda
zip -r render-function.zip render.ts node_modules
```

2. AWS Console에서 Lambda 함수 업데이트:
   - Lambda 콘솔 접속
   - 함수 선택
   - 코드 소스 섹션에서 .zip 파일 업로드

### 4. 환경 변수 설정

Lambda 함수에 다음 환경변수 설정:

```
REMOTION_SERVE_URL=https://remotionlambda-xxx.s3.amazonaws.com/sites/voguedrop/index.html
AWS_S3_BUCKET_NAME=voguedrop-renders
AWS_REGION=us-east-1
LAMBDA_FUNCTION_NAME=voguedrop-render
```

### 5. API Gateway 설정 (선택사항)

Lambda 함수를 HTTP 엔드포인트로 노출하려면:

1. API Gateway 생성
2. POST /render 엔드포인트 생성
3. Lambda 함수와 통합
4. API 키 설정 (선택사항)
5. 배포

### 6. IAM 역할 설정

Lambda 함수에 필요한 권한:
- S3 읽기/쓰기 권한
- CloudWatch 로그 권한
- Lambda 실행 권한

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:PutObjectAcl"
      ],
      "Resource": "arn:aws:s3:::voguedrop-renders/*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "*"
    }
  ]
}
```

### 7. S3 버킷 설정

```bash
# 버킷 생성
aws s3 mb s3://voguedrop-renders

# 공개 읽기 권한 설정 (필요한 경우)
aws s3api put-bucket-acl --bucket voguedrop-renders --acl public-read
```

## 테스트

1. Lambda 콘솔에서 테스트 이벤트 생성:
```json
{
  "videoClips": [...],
  "textClips": [...],
  "soundClips": [...],
  "aspectRatio": "9:16",
  "durationInFrames": 900,
  "userId": "test",
  "projectId": "test-project"
}
```

2. 테스트 실행 및 결과 확인

## 모니터링

- CloudWatch 로그에서 실행 로그 확인
- Lambda 메트릭에서 성능 모니터링
- S3 버킷에서 생성된 비디오 확인

## 문제 해결

### 타임아웃 에러
- Lambda 함수 타임아웃을 15분으로 설정
- 메모리를 3008MB로 증가

### 권한 에러
- IAM 역할 권한 확인
- S3 버킷 정책 확인

### 렌더링 실패
- CloudWatch 로그 확인
- Remotion 서브 URL 유효성 확인
- 입력 데이터 형식 확인
</file>

<file path="lib/api/gallery.ts">
import { supabase } from '@/lib/supabase'
import type { EffectTemplateWithMedia, Category } from '@/types/database'

export async function getGalleryItems(): Promise<EffectTemplateWithMedia[]> {
  try {
    const { data, error } = await supabase
      .from('effect_templates')
      .select(`
        *,
        category:categories!category_id(*),
        preview_media:media_assets!preview_media_id(*)
      `)
      .not('preview_media_id', 'is', null)
      .eq('is_active', true)
      .order('category_id')
      .order('display_order')

    if (error) {
      console.error('Error fetching gallery items:', error)
      throw new Error('Failed to fetch gallery items')
    }

    // Transform the data to match our interface
    const transformedData: EffectTemplateWithMedia[] = (data || []).map(item => {
      return {
        id: item.id,
        name: item.name,
        prompt: item.prompt,
        category_id: item.category_id,
        preview_media_id: item.preview_media_id,
        is_active: item.is_active,
        created_at: item.created_at,
        display_order: item.display_order,
        category: item.category,
        preview_media: item.preview_media
      }
    })

    return transformedData
  } catch (error) {
    console.error('Gallery API error:', error)
    throw error
  }
}

export async function getCategories(): Promise<Category[]> {
  try {
    const { data, error } = await supabase
      .from('categories')
      .select('*')
      .order('name')

    if (error) {
      console.error('Error fetching categories:', error)
      throw new Error('Failed to fetch categories')
    }

    return data || []
  } catch (error) {
    console.error('Categories API error:', error)
    throw error
  }
}
</file>

<file path="lib/sound/utils.ts">
/**
 * 사운드 생성 관련 유틸리티 함수
 */

/**
 * 사운드 타이틀 처리 함수
 * 타이틀이 없으면 프롬프트의 첫 부분을 타이틀로 사용
 * @param title - 사용자가 입력한 타이틀 (선택사항)
 * @param prompt - 사운드 생성 프롬프트
 * @param maxLength - 타이틀 최대 길이 (기본값: 50)
 * @returns 처리된 타이틀
 */
export function processSoundTitle(
  title: string | undefined | null,
  prompt: string,
  maxLength: number = 50
): string {
  // 타이틀이 제공되고 비어있지 않으면 그대로 사용
  if (title && title.trim().length > 0) {
    return title.trim();
  }
  
  // 타이틀이 없으면 프롬프트를 타이틀로 사용
  const trimmedPrompt = prompt.trim();
  
  // 프롬프트가 maxLength보다 길면 잘라내고 '...' 추가
  if (trimmedPrompt.length > maxLength) {
    // 마지막 단어를 잘라내지 않도록 처리
    const truncated = trimmedPrompt.substring(0, maxLength);
    const lastSpaceIndex = truncated.lastIndexOf(' ');
    
    // 공백이 있으면 그 위치까지만 사용
    if (lastSpaceIndex > maxLength * 0.5) {
      return truncated.substring(0, lastSpaceIndex) + '...';
    }
    
    return truncated + '...';
  }
  
  return trimmedPrompt;
}

/**
 * 비디오 기반 사운드 타이틀 생성
 * @param videoTitle - 비디오 타이틀
 * @param variationNumber - 변형 번호 (선택사항)
 * @returns 생성된 타이틀
 */
export function generateVideoSoundTitle(
  videoTitle: string,
  variationNumber?: number
): string {
  if (variationNumber !== undefined) {
    return `${videoTitle} - Soundtrack ${variationNumber}`;
  }
  return `${videoTitle} - Soundtrack`;
}

/**
 * job_id에서 앞 5자리 추출
 * @param jobId - 전체 job_id (예: "job_3FpXr7k9...")
 * @returns job_id의 앞 5자리 (예: "3FpXr")
 */
export function extractJobIdPrefix(jobId: string): string {
  // "job_" 접두사 제거하고 앞 5자리 추출
  const idWithoutPrefix = jobId.startsWith('job_') ? jobId.substring(4) : jobId;
  return idWithoutPrefix.substring(0, 5);
}

/**
 * 사운드 그룹화를 위한 그룹 ID 생성
 * @param prefix - ID 접두사 (기본값: 'group')
 * @returns 생성된 그룹 ID
 */
export function generateSoundGroupId(prefix: string = 'group'): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 9);
  return `${prefix}_${timestamp}_${random}`;
}

/**
 * 사운드 히스토리 표시용 타이틀 포맷팅
 * 타이틀이 있으면 타이틀을, 없으면 프롬프트를 반환
 * @param title - 저장된 타이틀
 * @param prompt - 저장된 프롬프트
 * @param maxLength - 최대 표시 길이
 * @returns 포맷된 표시 텍스트
 */
export function formatSoundDisplayTitle(
  title: string | null,
  prompt: string,
  maxLength: number = 60
): string {
  const displayText = title && title.trim() ? title.trim() : prompt.trim();
  
  if (displayText.length > maxLength) {
    const truncated = displayText.substring(0, maxLength);
    const lastSpaceIndex = truncated.lastIndexOf(' ');
    
    if (lastSpaceIndex > maxLength * 0.5) {
      return truncated.substring(0, lastSpaceIndex) + '...';
    }
    
    return truncated + '...';
  }
  
  return displayText;
}
</file>

<file path="lib/supabase/storage.ts">
import { supabase } from '@/lib/supabase';

/**
 * Supabase Storage에 이미지를 업로드하고 공개 URL을 반환합니다.
 */
export async function uploadImage(file: File, userId: string = 'anonymous'): Promise<string> {
  try {
    // 파일명 생성 (timestamp + random string)
    const timestamp = Date.now();
    const randomString = Math.random().toString(36).substring(7);
    const fileExt = file.name.split('.').pop();
    // 새로운 경로 구조: image/{userId}/{filename}
    const fileName = `image/${userId}/${timestamp}-${randomString}.${fileExt}`;

    // Supabase Storage에 업로드 (user-upload 버킷으로 통일)
    const { error } = await supabase.storage
      .from('user-uploads') // 버킷 이름 통일
      .upload(fileName, file, {
        cacheControl: '3600',
        upsert: true
      });

    if (error) {
      console.error('Storage upload error:', error);
      throw new Error('이미지 업로드에 실패했습니다.');
    }

    // 공개 URL 가져오기
    const { data: { publicUrl } } = supabase.storage
      .from('user-uploads')
      .getPublicUrl(fileName);

    return publicUrl;
  } catch (error) {
    console.error('Upload error:', error);
    throw error;
  }
}

/**
 * Base64 이미지를 Blob으로 변환합니다.
 */
export function base64ToBlob(base64: string): Blob {
  // data:image/jpeg;base64, 부분 제거
  const base64Data = base64.split(',')[1];
  const mimeType = base64.match(/data:([^;]+);/)?.[1] || 'image/jpeg';
  
  // base64를 binary로 변환
  const binaryString = atob(base64Data);
  const bytes = new Uint8Array(binaryString.length);
  
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  
  return new Blob([bytes], { type: mimeType });
}

/**
 * Base64 이미지를 Supabase Storage에 업로드하고 URL을 반환합니다.
 */
export async function uploadBase64Image(base64: string, userId: string = 'anonymous'): Promise<string> {
  // Base64를 Blob으로 변환
  const blob = base64ToBlob(base64);
  
  // File 객체로 변환
  const file = new File([blob], 'upload.jpg', { type: blob.type });
  
  // 업로드 (동일한 uploadImage 함수 사용으로 자동으로 새 경로 구조 적용)
  return uploadImage(file, userId);
}
</file>

<file path="scripts/download-all-fonts.sh">
#!/bin/bash

# 폰트 디렉토리 생성
mkdir -p public/fonts

echo "📥 Downloading all fonts from Google Fonts..."

# Roboto 폰트
curl -L "https://github.com/google/fonts/raw/main/apache/roboto/static/Roboto-Regular.ttf" -o public/fonts/Roboto-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/apache/roboto/static/Roboto-Bold.ttf" -o public/fonts/Roboto-Bold.ttf

# Open Sans 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/opensans/static/OpenSans-Regular.ttf" -o public/fonts/OpenSans-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/opensans/static/OpenSans-Bold.ttf" -o public/fonts/OpenSans-Bold.ttf

# Montserrat 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/montserrat/static/Montserrat-Regular.ttf" -o public/fonts/Montserrat-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/montserrat/static/Montserrat-Bold.ttf" -o public/fonts/Montserrat-Bold.ttf

# Poppins 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/poppins/Poppins-Regular.ttf" -o public/fonts/Poppins-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/poppins/Poppins-Bold.ttf" -o public/fonts/Poppins-Bold.ttf

# Playfair Display 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/playfairdisplay/static/PlayfairDisplay-Regular.ttf" -o public/fonts/PlayfairDisplay-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/playfairdisplay/static/PlayfairDisplay-Bold.ttf" -o public/fonts/PlayfairDisplay-Bold.ttf

# Merriweather 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/merriweather/Merriweather-Regular.ttf" -o public/fonts/Merriweather-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/merriweather/Merriweather-Bold.ttf" -o public/fonts/Merriweather-Bold.ttf

# Dancing Script 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/dancingscript/static/DancingScript-Regular.ttf" -o public/fonts/DancingScript-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/dancingscript/static/DancingScript-Bold.ttf" -o public/fonts/DancingScript-Bold.ttf

# Pacifico 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/pacifico/Pacifico-Regular.ttf" -o public/fonts/Pacifico-Regular.ttf

# Lobster 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/lobster/Lobster-Regular.ttf" -o public/fonts/Lobster-Regular.ttf

# Bebas Neue 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/bebasneue/BebasNeue-Regular.ttf" -o public/fonts/BebasNeue-Regular.ttf

# Oswald 폰트
curl -L "https://github.com/google/fonts/raw/main/ofl/oswald/static/Oswald-Regular.ttf" -o public/fonts/Oswald-Regular.ttf
curl -L "https://github.com/google/fonts/raw/main/ofl/oswald/static/Oswald-Bold.ttf" -o public/fonts/Oswald-Bold.ttf

# Noto Sans KR 폰트 (파일 크기가 크므로 선택적)
echo "📥 Downloading Korean fonts (this may take longer)..."
curl -L "https://github.com/google/fonts/raw/main/ofl/notosanskr/NotoSansKR%5Bwght%5D.ttf" -o public/fonts/NotoSansKR-Regular.ttf

echo "✅ All fonts downloaded successfully!"
echo "📁 Font files are in public/fonts/"
echo ""
echo "📊 Downloaded fonts summary:"
ls -lh public/fonts/ | tail -n +2 | wc -l | xargs -I {} echo "Total fonts: {} files"
du -sh public/fonts/ | awk '{print "Total size: " $1}'
</file>

<file path="src/remotion/fonts.d.ts">
declare module '*.ttf' {
  const content: string;
  export default content;
}

declare module '*.woff' {
  const content: string;
  export default content;
}

declare module '*.woff2' {
  const content: string;
  export default content;
}

declare module '*.otf' {
  const content: string;
  export default content;
}
</file>

<file path="src/remotion/inject-fonts.ts">
/**
 * Lambda 렌더링을 위한 폰트 스타일 인젝션
 * CSS import 대신 직접 스타일 태그 삽입
 */

export function injectFontStyles(): void {
  if (typeof document === 'undefined') return;
  
  // 이미 추가된 경우 스킵
  if (document.getElementById('remotion-fonts-style')) {
    return;
  }
  
  const fontStyleSheet = `
    /* Google Fonts Import */
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap');
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
    
    /* Local font fallbacks */
    @font-face {
      font-family: 'Dancing Script';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/DancingScript-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Dancing Script';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/DancingScript-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Pacifico';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Pacifico-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Lobster';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Lobster-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Roboto';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Roboto-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Roboto';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/Roboto-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Montserrat';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Montserrat-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Montserrat';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/Montserrat-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Open Sans';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/OpenSans-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Open Sans';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/OpenSans-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Poppins';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Poppins-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Poppins';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/Poppins-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Playfair Display';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/PlayfairDisplay-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Playfair Display';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/PlayfairDisplay-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Merriweather';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Merriweather-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Merriweather';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/Merriweather-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Bebas Neue';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/BebasNeue-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Oswald';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/Oswald-Regular.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Oswald';
      font-weight: 700;
      font-style: normal;
      src: url('/fonts/Oswald-Bold.ttf') format('truetype');
      font-display: swap;
    }
    
    @font-face {
      font-family: 'Noto Sans KR';
      font-weight: 400;
      font-style: normal;
      src: url('/fonts/NotoSansKR-Regular.ttf') format('truetype');
      font-display: swap;
    }
  `;
  
  const style = document.createElement('style');
  style.id = 'remotion-fonts-style';
  style.textContent = fontStyleSheet;
  document.head.appendChild(style);
  
  console.log('[Font Injector] Font styles injected into document');
}
</file>

<file path="src/remotion/load-fonts.ts">
/**
 * Remotion 폰트 로더
 * Lambda와 브라우저 환경에서 웹폰트를 로드합니다.
 * 
 * Lambda 환경:
 * - CSS @import로 Google Fonts 로드
 * - FontFace API로 추가 보장
 * - /public/fonts TTF 파일 폴백
 * 
 * 브라우저 환경:
 * - CSS @import로 Google Fonts 로드
 * - document.fonts API 활용
 */

import { continueRender, delayRender, getRemotionEnvironment } from 'remotion';
import { FONT_OPTIONS } from '../../constants/fonts';

let fontsLoaded = false;
let fontLoadHandle: number | null = null;

// 실패한 폰트 추적
const failedFonts = new Set<string>();

/**
 * 시스템 폰트 체크
 */
function isSystemFont(fontFamily: string): boolean {
  const systemFonts = [
    'Arial', 'Helvetica', 'Times New Roman', 'Georgia',
    'Courier New', 'Verdana', 'Trebuchet MS', 'Impact',
    'Comic Sans MS', 'system-ui', '-apple-system', 'BlinkMacSystemFont',
    'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell',
    'sans-serif', 'serif', 'monospace', 'cursive', 'fantasy', 'default'
  ];
  
  return systemFonts.includes(fontFamily);
}

/**
 * Google Fonts CSS를 동적으로 삽입
 */
function injectGoogleFontsCSS(): void {
  if (typeof document === 'undefined') return;
  
  // 이미 추가된 경우 스킵
  if (document.querySelector('link[data-font-loader="remotion"]')) {
    return;
  }
  
  const families = FONT_OPTIONS
    .filter(font => font.googleFontUrl && !isSystemFont(font.value))
    .map(font => {
      const weight = font.weight ? `:wght@${font.weight}` : ':wght@400;700';
      return `${font.value.replace(/ /g, '+')}${weight}`;
    });
  
  if (families.length === 0) return;
  
  // Preconnect for performance
  const preconnect1 = document.createElement('link');
  preconnect1.rel = 'preconnect';
  preconnect1.href = 'https://fonts.googleapis.com';
  document.head.appendChild(preconnect1);
  
  const preconnect2 = document.createElement('link');
  preconnect2.rel = 'preconnect';
  preconnect2.href = 'https://fonts.gstatic.com';
  preconnect2.crossOrigin = 'anonymous';
  document.head.appendChild(preconnect2);
  
  // Main font link
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = `https://fonts.googleapis.com/css2?family=${families.join('&family=')}&display=swap`;
  link.setAttribute('data-font-loader', 'remotion');
  document.head.appendChild(link);
  
  console.log('[Font Loader] Google Fonts CSS injected');
}

/**
 * Lambda와 로컬 환경 모두에서 작동하는 웹폰트 로더
 * CSS @import와 FontFace API를 동시에 사용
 */
export async function loadCoreFonts(): Promise<void> {
  if (fontsLoaded) {
    return;
  }

  const environment = getRemotionEnvironment();
  const isLambda = environment.isRendering;
  
  console.log(`[Font Loader] ========================================`);
  console.log(`[Font Loader] Starting font loading process...`);
  console.log(`[Font Loader] Environment: ${isLambda ? '🔴 Lambda/Rendering' : '🟢 Studio/Player'}`);
  console.log(`[Font Loader] ========================================`);

  // 렌더링 환경에서만 지연 처리
  if (isLambda) {
    fontLoadHandle = delayRender('Loading fonts...');
  }

  try {
    // 1. CSS @import 방식으로 Google Fonts 로드
    injectGoogleFontsCSS();
    
    // 2. FontFace API로 추가 로드 (Lambda 환경 대비)
    if (typeof document !== 'undefined' && document.fonts) {
      const webFonts = FONT_OPTIONS.filter(font => font.googleFontUrl && !isSystemFont(font.value));
      console.log(`[Font Loader] Loading ${webFonts.length} fonts with FontFace API`);
      
      const fontPromises: Promise<void>[] = [];
      const loadedFonts: string[] = [];
      
      for (const font of webFonts) {
        const fontIdentifier = `${font.value} (${font.weight || '400'})`;
        
        // 이미 실패한 폰트는 건너뛰기
        if (failedFonts.has(fontIdentifier)) {
          console.log(`[Font Loader] ⏭️  Skipping: ${fontIdentifier}`);
          continue;
        }
        
        const loadPromise = new Promise<void>(async (resolve) => {
          try {
            // FontFace API 사용
            const fontFace = new FontFace(
              font.value,
              `url(${font.googleFontUrl})`,
              {
                weight: font.weight || '400',
                style: 'normal',
                display: 'swap'
              } as FontFaceDescriptors
            );
            
            await fontFace.load();
            document.fonts.add(fontFace);
            console.log(`[Font Loader] ✅ Loaded: ${fontIdentifier}`);
            loadedFonts.push(fontIdentifier);
            resolve();
          } catch {
            console.warn(`[Font Loader] ⚠️  Failed: ${fontIdentifier}`);
            failedFonts.add(fontIdentifier);
            // 개별 폰트 로드 실패해도 전체 프로세스는 계속
            resolve();
          }
        });
        
        fontPromises.push(loadPromise);
      }
      
      // 모든 폰트 로드 대기
      await Promise.all(fontPromises);
      
      console.log(`[Font Loader] ========================================`);
      console.log(`[Font Loader] Summary:`);
      console.log(`[Font Loader] ✅ Loaded: ${loadedFonts.length} fonts`);
      console.log(`[Font Loader] ⚠️  Failed: ${failedFonts.size} fonts`);
      console.log(`[Font Loader] ========================================`);
    }
    
    // 폰트 로딩 완료 표시
    fontsLoaded = true;
    
  } catch (error) {
    console.error('[Font Loader] Fatal error during font loading:', error);
  } finally {
    // 렌더링 지연 해제
    if (fontLoadHandle !== null) {
      continueRender(fontLoadHandle);
      fontLoadHandle = null;
    }
  }
}

/**
 * 텍스트 에디터용 폰트 로더
 * 개별 폰트를 동적으로 로드
 */
export async function loadFontForEditor(fontFamily: string): Promise<boolean> {
  if (isSystemFont(fontFamily)) {
    return true;
  }

  const fontOption = FONT_OPTIONS.find(f => f.value === fontFamily);
  if (!fontOption || !fontOption.googleFontUrl) {
    return false;
  }

  const fontIdentifier = `${fontFamily} (${fontOption.weight || '400'})`;
  
  // 이미 실패한 폰트는 재시도하지 않음
  if (failedFonts.has(fontIdentifier)) {
    return false;
  }

  try {
    if (typeof document !== 'undefined' && document.fonts) {
      // 먼저 이미 로드되었는지 확인
      const loaded = await document.fonts.load(`16px "${fontFamily}"`);
      if (loaded.length > 0) {
        return true;
      }
      
      // 로드되지 않았다면 FontFace API로 로드
      const fontFace = new FontFace(
        fontFamily,
        `url(${fontOption.googleFontUrl})`,
        {
          weight: fontOption.weight || '400',
          style: 'normal',
          display: 'swap'
        } as FontFaceDescriptors
      );
      
      await fontFace.load();
      document.fonts.add(fontFace);
      console.log(`[Font Loader] Editor font loaded: ${fontIdentifier}`);
      return true;
    }
  } catch {
    console.warn(`[Font Loader] Failed to load editor font: ${fontIdentifier}`);
    failedFonts.add(fontIdentifier);
  }
  
  return false;
}
</file>

<file path="styles/fonts.css">
/**
 * Google Fonts 웹폰트
 * Lambda 환경에서 권장되는 방식 - CDN을 통한 폰트 로딩
 * font-display: swap으로 빠른 렌더링과 폰트 교체
 */

/* Modern Sans-Serif */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap');

/* Serif */
@import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@400;700&display=swap');

/* Script & Casual */
@import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Lobster&display=swap');

/* Display & Impact */
@import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap');

/* Korean - Noto Sans KR */
@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

/* 
 * 폰트는 Google Fonts CDN에서 직접 로드됩니다.
 * @remotion/fonts의 loadFont()가 각 폰트를 비동기로 로드하며,
 * CSS @import는 브라우저 폴백으로 작동합니다.
 */
</file>

<file path="supabase/.temp/cli-latest">
v2.34.3
</file>

<file path="supabase/functions/_shared/cors.ts">
// Shared CORS headers for Supabase Edge Functions
export const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
};
</file>

<file path="supabase/functions/image-brush/index.ts">
// Supabase Edge Function for AI Image Brush (Inpainting)
// This function handles image editing with AI using BFL FLUX Fill API

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.52.1';
import { corsHeaders } from '../_shared/cors.ts';

// API Configuration
const BFL_API_URL = 'https://api.us1.bfl.ai/v1/flux-pro-1.0-fill';
const BFL_RESULT_URL = 'https://api.us1.bfl.ai/v1/get_result';

interface ImageBrushRequest {
  image: string;      // Base64 encoded original image
  mask: string;       // Base64 encoded mask image (white = inpaint area)
  prompt: string;     // User prompt for generation
  mode: 'flux' | 'i2i';  // Processing mode
  userId?: string;
}

interface ImageBrushResponse {
  success: boolean;
  imageUrl?: string;
  originalImageUrl?: string;  // Added for debugging
  maskImageUrl?: string;       // Added for debugging
  error?: string;
  processingTime?: number;
}

// Helper function to convert base64 to blob
function base64ToBlob(base64: string): Uint8Array {
  // Remove data URL prefix if present
  const base64Data = base64.includes(',') ? base64.split(',')[1] : base64;
  
  // Decode base64
  const binaryString = atob(base64Data);
  const bytes = new Uint8Array(binaryString.length);
  
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  
  return bytes;
}

// Helper function to download image from URL
async function downloadImage(url: string): Promise<Uint8Array> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download image: ${response.statusText}`);
  }
  const arrayBuffer = await response.arrayBuffer();
  return new Uint8Array(arrayBuffer);
}

// BFL FLUX Fill API call
async function callFluxFillAPI(
  image: string,
  mask: string, 
  prompt: string,
  bflToken: string
): Promise<string> {
  const startTime = Date.now();
  
  // Prepare request data
  const requestData = {
    prompt: prompt,
    seed: Math.floor(Math.random() * 999999),
    image: image.split(',')[1] || image, // Remove data URL prefix if present
    mask: mask.split(',')[1] || mask,
    guidance: 30,  // Reduced from 80 for more natural results
    output_format: 'png',
    safety_tolerance: 2,
    prompt_upsampling: false,
  };

  console.log('Calling BFL FLUX Fill API...');
  
  // Initial API call to start generation
  const response = await fetch(BFL_API_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Key': bflToken,
    },
    body: JSON.stringify(requestData),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('BFL API error:', errorText);
    throw new Error(`BFL API error: ${response.status} - ${errorText}`);
  }

  const responseData = await response.json();
  const genId = responseData.id;
  
  if (!genId) {
    throw new Error('No generation ID received from BFL API');
  }
  
  console.log(`Generation started with ID: ${genId}`);

  // Poll for result
  const maxAttempts = 60; // 60 attempts * 2 seconds = 2 minutes max
  let attempts = 0;
  
  while (attempts < maxAttempts) {
    attempts++;
    
    // Wait before checking
    await new Promise(resolve => setTimeout(resolve, 2000)); // 2 seconds
    
    // Check result
    const resultResponse = await fetch(`${BFL_RESULT_URL}?id=${genId}`, {
      method: 'GET',
      headers: {
        'X-Key': bflToken,
      },
    });

    if (!resultResponse.ok) {
      console.error(`Result check failed: ${resultResponse.status}`);
      continue; // Keep trying
    }

    const result = await resultResponse.json();
    const status = result.status;
    
    console.log(`Status (attempt ${attempts}): ${status}`);

    if (status === 'Ready') {
      const imageUrl = result.result?.sample || result.result?.url;
      if (!imageUrl) {
        throw new Error('No image URL in result');
      }
      
      console.log(`Generation completed in ${Date.now() - startTime}ms`);
      return imageUrl;
      
    } else if (status === 'Pending') {
      // Continue polling
      continue;
      
    } else if (status === 'Task not found' || status === 'Request Moderated' || 
               status === 'Content Moderated' || status === 'Error') {
      const errorMsg = result.error || status;
      throw new Error(`Generation failed: ${errorMsg}`);
    }
  }
  
  throw new Error('Generation timeout - took too long to complete');
}

serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  console.log('Image brush request received');
  const startTime = Date.now();

  try {
    // Get environment variables
    const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? '';
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '';
    const bflToken = Deno.env.get('BFL_TOKEN');
    
    if (!bflToken) {
      throw new Error('BFL_TOKEN not configured');
    }

    // Get auth token from request header
    const authHeader = req.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return new Response(
        JSON.stringify({ error: 'Authentication required.' }),
        { 
          status: 401,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const token = authHeader.replace('Bearer ', '');

    // Create Supabase client for auth
    const supabaseAnon = Deno.env.get('SUPABASE_ANON_KEY') ?? '';
    const supabaseAuth = createClient(supabaseUrl, supabaseAnon, {
      global: {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      },
    });
    
    // Verify user
    const { data: { user }, error: authError } = await supabaseAuth.auth.getUser();
    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: 'Login required.' }),
        { 
          status: 401,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Parse request body
    const body: ImageBrushRequest = await req.json();
    const { image, mask, prompt, mode } = body;

    // Validate required fields
    if (!image || !mask || !prompt) {
      return new Response(
        JSON.stringify({ error: 'Required fields are missing.' }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    console.log(`Processing ${mode} request for user ${user.id}`);

    // Create Supabase service client for storage operations
    const supabaseService = createClient(supabaseUrl, supabaseServiceKey);
    const timestamp = Date.now();

    // Save original image to storage
    console.log('Saving original image to storage...');
    const originalImageData = base64ToBlob(image);
    const originalFileName = `image-brush/${user.id}/${timestamp}_original.png`;
    
    const { error: originalUploadError } = await supabaseService.storage
      .from('user-uploads')
      .upload(originalFileName, originalImageData, {
        contentType: 'image/png',
        upsert: false
      });

    if (originalUploadError) {
      console.error('Original image upload error:', originalUploadError);
      throw new Error('Failed to save original image.');
    }

    // Get public URL for original image
    const { data: { publicUrl: originalImageUrl } } = supabaseService.storage
      .from('user-uploads')
      .getPublicUrl(originalFileName);

    // Save mask image to storage  
    console.log('Saving mask image to storage...');
    const maskImageData = base64ToBlob(mask);
    const maskFileName = `image-brush/${user.id}/${timestamp}_mask.png`;
    
    const { error: maskUploadError } = await supabaseService.storage
      .from('user-uploads')
      .upload(maskFileName, maskImageData, {
        contentType: 'image/png',
        upsert: false
      });

    if (maskUploadError) {
      console.error('Mask image upload error:', maskUploadError);
      throw new Error('Failed to save mask image.');
    }

    // Get public URL for mask image
    const { data: { publicUrl: maskImageUrl } } = supabaseService.storage
      .from('user-uploads')
      .getPublicUrl(maskFileName);

    console.log('Original image URL:', originalImageUrl);
    console.log('Mask image URL:', maskImageUrl);

    let resultImageUrl: string;

    if (mode === 'flux') {
      // Call BFL FLUX Fill API
      resultImageUrl = await callFluxFillAPI(image, mask, prompt, bflToken);
      
    } else if (mode === 'i2i') {
      // RunPod I2I mode (optional - not implemented in this version)
      return new Response(
        JSON.stringify({ error: 'I2I mode is not supported yet.' }),
        { 
          status: 501,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    } else {
      return new Response(
        JSON.stringify({ error: 'Invalid processing mode.' }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Download the generated image
    console.log('Downloading generated image...');
    const imageData = await downloadImage(resultImageUrl);
    
    // Save result image to Supabase Storage
    const resultFileName = `image-brush/${user.id}/${timestamp}_result.png`;
    
    const { error: uploadError } = await supabaseService.storage
      .from('user-uploads')
      .upload(resultFileName, imageData, {
        contentType: 'image/png',
        upsert: false
      });

    if (uploadError) {
      console.error('Storage upload error:', uploadError);
      throw new Error('Failed to save result image.');
    }

    // Get public URL for result image
    const { data: { publicUrl } } = supabaseService.storage
      .from('user-uploads')
      .getPublicUrl(resultFileName);

    // Save metadata to database with all URLs
    const { error: dbError } = await supabaseService
      .from('image_brush_history')
      .insert({
        user_id: user.id,
        original_image_url: originalImageUrl,  // URL instead of base64
        mask_image_url: maskImageUrl,          // URL instead of base64
        prompt: prompt,
        result_url: publicUrl,
        mode: mode,
        processing_time: Date.now() - startTime,
        created_at: new Date().toISOString()
      });

    if (dbError) {
      console.warn('Failed to save history:', dbError);
      // Continue even if history save fails
    }

    const processingTime = Date.now() - startTime;
    console.log(`Image brush completed in ${processingTime}ms`);

    // Return success response with all URLs
    const response: ImageBrushResponse = {
      success: true,
      imageUrl: publicUrl,
      originalImageUrl: originalImageUrl,  // Include for debugging
      maskImageUrl: maskImageUrl,          // Include for debugging
      processingTime
    };

    return new Response(
      JSON.stringify(response),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Image brush error:', error);
    
    const errorMessage = error instanceof Error ? error.message : 'An error occurred during processing.';
    
    const response: ImageBrushResponse = {
      success: false,
      error: errorMessage
    };

    return new Response(
      JSON.stringify(response),
      { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
</file>

<file path="supabase/functions/upload-video/index.ts">
// Supabase Edge Function for video upload
// This function handles large video file uploads (up to 50MB)
// It bypasses Vercel's 4.5MB limit by running on Supabase's edge runtime

import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.52.1';
import { corsHeaders } from '../_shared/cors.ts';

const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
const ALLOWED_TYPES = ['video/mp4', 'video/webm', 'video/quicktime', 'video/x-msvideo'];

// Sanitize filename for storage
function sanitizeFileName(fileName: string): string {
  return fileName
    .replace(/[^a-zA-Z0-9가-힣.\-_]/g, '_')
    .replace(/\s+/g, '_')
    .replace(/_{2,}/g, '_')
    .slice(0, 100);
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  console.log('Upload request received');
  const startTime = Date.now();

  try {
    // Get Supabase URL and keys from environment
    const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? '';
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '';

    // Get auth token from request header
    const authHeader = req.headers.get('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return new Response(
        JSON.stringify({ error: '인증이 필요합니다.' }),
        { 
          status: 401,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    const token = authHeader.replace('Bearer ', '');

    // Create Supabase client with anon key and set the user's token
    const supabaseAnon = Deno.env.get('SUPABASE_ANON_KEY') ?? '';
    const supabaseAuth = createClient(supabaseUrl, supabaseAnon, {
      global: {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      },
    });
    const { data: { user }, error: authError } = await supabaseAuth.auth.getUser();

    if (authError || !user) {
      return new Response(
        JSON.stringify({ error: '로그인이 필요합니다.' }),
        { 
          status: 401,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Parse multipart form data with timeout check
    console.log('Parsing form data...');
    const formData = await req.formData();
    console.log(`Form data parsed in ${Date.now() - startTime}ms`);
    const file = formData.get('file') as File;
    const thumbnail = formData.get('thumbnail') as File | null;
    
    // Extract metadata from form data
    const duration = formData.get('duration') as string | null;
    const aspectRatio = formData.get('aspectRatio') as string | null;
    const width = formData.get('width') as string | null;
    const height = formData.get('height') as string | null;

    if (!file) {
      return new Response(
        JSON.stringify({ error: '파일이 없습니다.' }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Validate file size
    if (file.size > MAX_FILE_SIZE) {
      return new Response(
        JSON.stringify({ 
          error: `파일 크기는 50MB를 초과할 수 없습니다. (현재: ${(file.size / 1024 / 1024).toFixed(2)}MB)` 
        }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Validate file type
    if (!ALLOWED_TYPES.includes(file.type)) {
      return new Response(
        JSON.stringify({ 
          error: '지원하지 않는 파일 형식입니다. MP4, WebM, MOV 파일만 업로드 가능합니다.' 
        }),
        { 
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Generate filename and storage path
    const originalName = file.name;
    const sanitizedName = sanitizeFileName(originalName);
    const timestamp = Date.now();
    const fileName = `${timestamp}_${sanitizedName}`;
    const storagePath = `video/${user.id}/${fileName}`;

    // Create service client for storage operations
    const supabaseService = createClient(supabaseUrl, supabaseServiceKey);

    // Upload video file to storage
    console.log(`Starting file upload (${(file.size / 1024 / 1024).toFixed(2)}MB)...`);
    const fileBuffer = await file.arrayBuffer();
    console.log(`File buffered in ${Date.now() - startTime}ms`);
    
    const { error: uploadError } = await supabaseService.storage
      .from('user-uploads')
      .upload(storagePath, fileBuffer, {
        contentType: file.type,
        upsert: false
      });
    console.log(`File uploaded in ${Date.now() - startTime}ms`);

    if (uploadError) {
      console.error('Upload error:', uploadError);
      return new Response(
        JSON.stringify({ error: '파일 업로드에 실패했습니다.' }),
        { 
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Get public URL for the uploaded video
    const { data: { publicUrl } } = supabaseService.storage
      .from('user-uploads')
      .getPublicUrl(storagePath);

    // Handle thumbnail upload if provided
    let thumbnailUrl: string | null = null;
    if (thumbnail) {
      try {
        const thumbnailPath = `video/${user.id}/thumbnails/${timestamp}_thumbnail.jpg`;
        const thumbnailBuffer = await thumbnail.arrayBuffer();
        
        const { error: thumbnailError } = await supabaseService.storage
          .from('user-uploads')
          .upload(thumbnailPath, thumbnailBuffer, {
            contentType: 'image/jpeg',
            upsert: false
          });
        
        if (!thumbnailError) {
          const { data: { publicUrl: thumbUrl } } = supabaseService.storage
            .from('user-uploads')
            .getPublicUrl(thumbnailPath);
          thumbnailUrl = thumbUrl;
        } else {
          console.warn('Thumbnail upload failed:', thumbnailError);
        }
      } catch (err) {
        console.warn('Thumbnail processing error:', err);
        // Continue even if thumbnail fails
      }
    }

    // Save metadata to database
    const { data: savedVideo, error: dbError } = await supabaseService
      .from('user_uploaded_videos')
      .insert({
        user_id: user.id,
        file_name: originalName,
        storage_path: storagePath,
        file_size: file.size,
        duration: duration ? parseFloat(duration) : null,
        aspect_ratio: aspectRatio || null,
        thumbnail_url: thumbnailUrl,
        metadata: {
          mime_type: file.type,
          original_name: originalName,
          width: width ? parseInt(width) : null,
          height: height ? parseInt(height) : null
        },
        uploaded_at: new Date().toISOString()
      })
      .select()
      .single();

    if (dbError) {
      console.error('Database error:', dbError);
      // Rollback: delete uploaded file from storage
      await supabaseService.storage
        .from('user-uploads')
        .remove([storagePath]);
      
      return new Response(
        JSON.stringify({ error: '데이터베이스 저장에 실패했습니다.' }),
        { 
          status: 500,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        }
      );
    }

    // Return success response with video data
    return new Response(
      JSON.stringify({
        success: true,
        video: {
          ...savedVideo,
          url: publicUrl
        }
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    console.error('Edge function error:', error);
    return new Response(
      JSON.stringify({ error: '업로드 중 오류가 발생했습니다.' }),
      { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
</file>

<file path="supabase/migrations/001_20250130_add_canvas_categories.sql">
-- Add Canvas AI categories
-- Created: 2025-01-30

-- Insert Canvas-related categories
-- Using INSERT ... ON CONFLICT to ensure idempotency
INSERT INTO public.categories (name) VALUES 
  ('effect'),   -- Visual effects like dreamy, vintage, etc.
  ('camera'),   -- Camera movements like zoom, pan, etc.
  ('model')     -- Model behaviors like walk, pose, etc.
ON CONFLICT (name) DO NOTHING;

-- Add comments for documentation
COMMENT ON COLUMN public.categories.name IS 'Category name. Canvas AI uses: effect, camera, model';
</file>

<file path="supabase/migrations/002_20250130_add_canvas_ai_tables.sql">
-- Canvas AI Video Generation Tables Migration
-- Created: 2025-01-30

-- Create effect_templates table (only this table is missing)
CREATE TABLE IF NOT EXISTS public.effect_templates (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category_id bigint NOT NULL REFERENCES public.categories(id) ON DELETE CASCADE,
  prompt text NOT NULL,
  preview_media_id bigint REFERENCES public.media_assets(id) ON DELETE SET NULL,
  display_order integer DEFAULT 0,
  is_active boolean DEFAULT true,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  CONSTRAINT unique_effect_template_per_category UNIQUE (name, category_id)
);

-- Create indexes for performance (IF NOT EXISTS)
CREATE INDEX IF NOT EXISTS idx_effect_templates_category ON public.effect_templates(category_id);
CREATE INDEX IF NOT EXISTS idx_effect_templates_active ON public.effect_templates(is_active);
CREATE INDEX IF NOT EXISTS idx_video_generations_user_id ON public.video_generations(user_id);
CREATE INDEX IF NOT EXISTS idx_video_generations_status ON public.video_generations(status);
CREATE INDEX IF NOT EXISTS idx_video_generations_created_at ON public.video_generations(created_at DESC);

-- Enable Row Level Security
ALTER TABLE public.effect_templates ENABLE ROW LEVEL SECURITY;

-- RLS is already enabled on video_generations, skip
-- ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

-- RLS Policies for effect_templates (public read access)
CREATE POLICY "Effect templates are viewable by everyone" 
ON public.effect_templates FOR SELECT 
USING (true);

-- RLS Policies for video_generations - create only if not exists
DO $$ 
BEGIN
  -- Check and create SELECT policy
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'video_generations' 
    AND policyname = 'Users can view their own video generations'
  ) THEN
    CREATE POLICY "Users can view their own video generations" 
    ON public.video_generations FOR SELECT 
    USING (user_id = COALESCE(auth.uid()::text, 'anonymous'));
  END IF;

  -- Check and create INSERT policy
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'video_generations' 
    AND policyname = 'Users can create their own video generations'
  ) THEN
    CREATE POLICY "Users can create their own video generations" 
    ON public.video_generations FOR INSERT 
    WITH CHECK (user_id = COALESCE(auth.uid()::text, 'anonymous'));
  END IF;

  -- Check and create UPDATE policy
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE tablename = 'video_generations' 
    AND policyname = 'Users can update their own video generations'
  ) THEN
    CREATE POLICY "Users can update their own video generations" 
    ON public.video_generations FOR UPDATE 
    USING (user_id = COALESCE(auth.uid()::text, 'anonymous'));
  END IF;
END $$;

-- Add comments for documentation
COMMENT ON TABLE public.effect_templates IS 'Stores AI video effect templates with prompts for fal.ai';
COMMENT ON TABLE public.video_generations IS 'Tracks user video generation requests and results';
COMMENT ON COLUMN public.effect_templates.prompt IS 'The prompt text to be sent to fal.ai for this effect';
COMMENT ON COLUMN public.video_generations.selected_effects IS 'JSON array of effect_template IDs selected by the user';
COMMENT ON COLUMN public.video_generations.combined_prompt IS 'The final combined prompt from all selected effects';
</file>

<file path="supabase/migrations/003_20250130_migrate_creations_to_effect_templates.sql">
-- Migration: Transfer data from creations to effect_templates
-- Created: 2025-01-30

-- First, insert the creations data into effect_templates
-- We'll map product_id to preview_media_id
INSERT INTO public.effect_templates (name, category_id, prompt, preview_media_id, display_order, is_active)
SELECT 
  c.title as name,
  c.category_id,
  c.prompt,
  c.product_id as preview_media_id,
  ROW_NUMBER() OVER (PARTITION BY c.category_id ORDER BY c.created_at) as display_order,
  true as is_active
FROM public.creations c
WHERE c.title IS NOT NULL
ON CONFLICT (name, category_id) DO UPDATE SET
  prompt = EXCLUDED.prompt,
  preview_media_id = EXCLUDED.preview_media_id,
  display_order = EXCLUDED.display_order;

-- Log the migration for verification
DO $$
DECLARE
  migrated_count integer;
BEGIN
  SELECT COUNT(*) INTO migrated_count
  FROM public.effect_templates
  WHERE preview_media_id IN (SELECT product_id FROM public.creations);
  
  RAISE NOTICE 'Migrated % records from creations to effect_templates', migrated_count;
END $$;

-- Note: We're not dropping the creations table yet to ensure data safety
-- After verifying the migration, you can drop it with:
-- DROP TABLE IF EXISTS public.creations CASCADE;
</file>

<file path="supabase/migrations/004_20250130_drop_creations_table.sql">
-- Drop creations table after migrating data to effect_templates
-- Created: 2025-01-30

-- First, verify that data has been migrated
DO $$
DECLARE
  creation_count integer;
  effect_template_count integer;
BEGIN
  SELECT COUNT(*) INTO creation_count FROM public.creations;
  SELECT COUNT(*) INTO effect_template_count 
  FROM public.effect_templates 
  WHERE preview_media_id IN (SELECT product_id FROM public.creations);
  
  IF creation_count > 0 AND effect_template_count = 0 THEN
    RAISE EXCEPTION 'Data has not been migrated from creations to effect_templates. Run 20250130_migrate_creations_to_effect_templates.sql first.';
  END IF;
END $$;

-- Drop RLS policies for creations table
DROP POLICY IF EXISTS "Creations are viewable by everyone" ON public.creations;

-- Drop the creations table
DROP TABLE IF EXISTS public.creations CASCADE;

-- Verification
DO $$
BEGIN
  RAISE NOTICE 'Successfully dropped creations table';
END $$;
</file>

<file path="supabase/migrations/005_20250131_fix_video_generations_table.sql">
-- Fix video_generations table structure
-- This migration ensures the table has all required columns

-- First, check if the table exists
DO $$ 
BEGIN
  -- If table doesn't exist, create it
  IF NOT EXISTS (SELECT FROM pg_tables WHERE schemaname = 'public' AND tablename = 'video_generations') THEN
    CREATE TABLE public.video_generations (
      id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
      user_id text NOT NULL DEFAULT 'anonymous',
      status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
      input_image_url text NOT NULL,
      output_video_url text,
      prompt text NOT NULL,
      selected_effects jsonb DEFAULT '[]'::jsonb,
      model_type text NOT NULL DEFAULT 'seedance' CHECK (model_type IN ('seedance', 'hailo')),
      error_message text,
      created_at timestamp with time zone DEFAULT now() NOT NULL,
      updated_at timestamp with time zone DEFAULT now() NOT NULL
    );

    -- Create indexes
    CREATE INDEX idx_video_generations_user_id ON public.video_generations(user_id);
    CREATE INDEX idx_video_generations_status ON public.video_generations(status);
    CREATE INDEX idx_video_generations_created_at ON public.video_generations(created_at DESC);

    -- Enable RLS
    ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

    -- Create RLS policies
    CREATE POLICY "Users can view their own video generations" 
    ON public.video_generations FOR SELECT 
    USING (true); -- Allow all reads for MVP

    CREATE POLICY "Users can create their own video generations" 
    ON public.video_generations FOR INSERT 
    WITH CHECK (true); -- Allow all inserts for MVP

    CREATE POLICY "Users can update their own video generations" 
    ON public.video_generations FOR UPDATE 
    USING (true); -- Allow all updates for MVP
  ELSE
    -- Table exists, check and add missing columns
    
    -- Check and add input_image_url column
    IF NOT EXISTS (SELECT FROM information_schema.columns 
                   WHERE table_schema = 'public' 
                   AND table_name = 'video_generations' 
                   AND column_name = 'input_image_url') THEN
      ALTER TABLE public.video_generations ADD COLUMN input_image_url text;
      
      -- If there's an image_url column, migrate data and drop it
      IF EXISTS (SELECT FROM information_schema.columns 
                 WHERE table_schema = 'public' 
                 AND table_name = 'video_generations' 
                 AND column_name = 'image_url') THEN
        UPDATE public.video_generations SET input_image_url = image_url WHERE input_image_url IS NULL;
        ALTER TABLE public.video_generations DROP COLUMN image_url;
      END IF;
      
      -- Make it NOT NULL after migration
      ALTER TABLE public.video_generations ALTER COLUMN input_image_url SET NOT NULL;
    END IF;

    -- Check and add prompt column
    IF NOT EXISTS (SELECT FROM information_schema.columns 
                   WHERE table_schema = 'public' 
                   AND table_name = 'video_generations' 
                   AND column_name = 'prompt') THEN
      ALTER TABLE public.video_generations ADD COLUMN prompt text;
      
      -- If there's a combined_prompt column, migrate data
      IF EXISTS (SELECT FROM information_schema.columns 
                 WHERE table_schema = 'public' 
                 AND table_name = 'video_generations' 
                 AND column_name = 'combined_prompt') THEN
        UPDATE public.video_generations SET prompt = combined_prompt WHERE prompt IS NULL;
      END IF;
      
      -- Make it NOT NULL after migration
      ALTER TABLE public.video_generations ALTER COLUMN prompt SET NOT NULL;
    END IF;

    -- Check and add output_video_url column
    IF NOT EXISTS (SELECT FROM information_schema.columns 
                   WHERE table_schema = 'public' 
                   AND table_name = 'video_generations' 
                   AND column_name = 'output_video_url') THEN
      ALTER TABLE public.video_generations ADD COLUMN output_video_url text;
      
      -- If there's a video_url column, migrate data
      IF EXISTS (SELECT FROM information_schema.columns 
                 WHERE table_schema = 'public' 
                 AND table_name = 'video_generations' 
                 AND column_name = 'video_url') THEN
        UPDATE public.video_generations SET output_video_url = video_url;
        ALTER TABLE public.video_generations DROP COLUMN video_url;
      END IF;
    END IF;

    -- Check and add other columns if missing
    IF NOT EXISTS (SELECT FROM information_schema.columns 
                   WHERE table_schema = 'public' 
                   AND table_name = 'video_generations' 
                   AND column_name = 'selected_effects') THEN
      ALTER TABLE public.video_generations ADD COLUMN selected_effects jsonb DEFAULT '[]'::jsonb;
    END IF;

    IF NOT EXISTS (SELECT FROM information_schema.columns 
                   WHERE table_schema = 'public' 
                   AND table_name = 'video_generations' 
                   AND column_name = 'error_message') THEN
      ALTER TABLE public.video_generations ADD COLUMN error_message text;
    END IF;

    IF NOT EXISTS (SELECT FROM information_schema.columns 
                   WHERE table_schema = 'public' 
                   AND table_name = 'video_generations' 
                   AND column_name = 'updated_at') THEN
      ALTER TABLE public.video_generations ADD COLUMN updated_at timestamp with time zone DEFAULT now() NOT NULL;
    END IF;
  END IF;
END $$;

-- Create or replace the updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ language 'plpgsql';

DROP TRIGGER IF EXISTS update_video_generations_updated_at ON public.video_generations;
CREATE TRIGGER update_video_generations_updated_at BEFORE UPDATE ON public.video_generations 
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
</file>

<file path="supabase/migrations/006_20250131_fix_rls_policies.sql">
-- Fix RLS policies for MVP to allow anonymous access
-- This migration updates existing restrictive policies

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can create their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update their own video generations" ON public.video_generations;

-- Create new permissive policies for MVP
CREATE POLICY "Allow all video generation reads" 
ON public.video_generations FOR SELECT 
USING (true);

CREATE POLICY "Allow all video generation inserts" 
ON public.video_generations FOR INSERT 
WITH CHECK (true);

CREATE POLICY "Allow all video generation updates" 
ON public.video_generations FOR UPDATE 
USING (true);

-- Also ensure RLS is enabled (it should already be)
ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

-- Add comment explaining MVP approach
COMMENT ON POLICY "Allow all video generation reads" ON public.video_generations IS 'MVP: Allow all reads without authentication';
COMMENT ON POLICY "Allow all video generation inserts" ON public.video_generations IS 'MVP: Allow all inserts without authentication';
COMMENT ON POLICY "Allow all video generation updates" ON public.video_generations IS 'MVP: Allow all updates without authentication';
</file>

<file path="supabase/migrations/007_20250131_disable_rls_mvp.sql">
-- Temporarily disable RLS for MVP
-- This allows all operations without authentication checks

-- Disable RLS on video_generations table
ALTER TABLE public.video_generations DISABLE ROW LEVEL SECURITY;

-- Add comment explaining this is temporary for MVP
COMMENT ON TABLE public.video_generations IS 'Video generation tracking table. RLS disabled for MVP phase.';

-- Note: Re-enable RLS after implementing proper authentication
-- ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;
</file>

<file path="supabase/migrations/008_20250131_create_storage_bucket.sql">
-- Create storage bucket for user uploads
INSERT INTO storage.buckets (id, name, public)
VALUES ('user-uploads', 'user-uploads', true)
ON CONFLICT (id) DO NOTHING;

-- Allow public access to the bucket
CREATE POLICY "Public Access" ON storage.objects
FOR SELECT USING (bucket_id = 'user-uploads');

-- Allow authenticated users to upload
CREATE POLICY "Allow uploads" ON storage.objects
FOR INSERT WITH CHECK (bucket_id = 'user-uploads');

-- Allow authenticated users to update their own files
CREATE POLICY "Allow updates" ON storage.objects
FOR UPDATE USING (bucket_id = 'user-uploads');

-- Allow authenticated users to delete their own files
CREATE POLICY "Allow deletes" ON storage.objects
FOR DELETE USING (bucket_id = 'user-uploads');
</file>

<file path="supabase/migrations/009_20250131_add_job_tracking_fields.sql">
-- Add job tracking fields to video_generations table
ALTER TABLE public.video_generations 
ADD COLUMN IF NOT EXISTS job_id text UNIQUE,
ADD COLUMN IF NOT EXISTS webhook_status text CHECK (webhook_status IN ('pending', 'delivered', 'failed')),
ADD COLUMN IF NOT EXISTS webhook_delivered_at timestamp with time zone,
ADD COLUMN IF NOT EXISTS fal_request_id text;

-- Create index for job_id for fast lookups
CREATE INDEX IF NOT EXISTS idx_video_generations_job_id ON public.video_generations(job_id);

-- Create index for fal_request_id
CREATE INDEX IF NOT EXISTS idx_video_generations_fal_request_id ON public.video_generations(fal_request_id);

-- Add comment
COMMENT ON COLUMN public.video_generations.job_id IS 'Unique job ID for tracking async video generation';
COMMENT ON COLUMN public.video_generations.webhook_status IS 'Status of webhook delivery from fal.ai';
COMMENT ON COLUMN public.video_generations.fal_request_id IS 'Request ID returned by fal.ai for tracking';
</file>

<file path="supabase/migrations/010_20250131_create_video_generation_logs.sql">
-- Create video_generation_logs table for tracking generation process
CREATE TABLE IF NOT EXISTS public.video_generation_logs (
  id bigint GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  job_id text NOT NULL,
  level text NOT NULL CHECK (level IN ('info', 'warning', 'error')),
  message text NOT NULL,
  metadata jsonb DEFAULT '{}'::jsonb,
  timestamp timestamp with time zone DEFAULT now() NOT NULL,
  created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- Create indexes for efficient querying
CREATE INDEX idx_video_generation_logs_job_id ON public.video_generation_logs(job_id);
CREATE INDEX idx_video_generation_logs_timestamp ON public.video_generation_logs(timestamp DESC);
CREATE INDEX idx_video_generation_logs_level ON public.video_generation_logs(level);

-- Add comment
COMMENT ON TABLE public.video_generation_logs IS 'Logs for video generation process tracking';

-- Disable RLS for MVP (enable later with proper policies)
ALTER TABLE public.video_generation_logs DISABLE ROW LEVEL SECURITY;
EOF < /dev/null
</file>

<file path="supabase/migrations/011_20250131_update_rls_for_webhooks.sql">
-- RLS 정책 업데이트: webhook이 video_generations 테이블을 업데이트할 수 있도록 허용

-- 기존 정책 삭제 (있다면)
DROP POLICY IF EXISTS "Users can view their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can create their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update their own video generations" ON public.video_generations;

-- 새로운 RLS 정책 생성

-- 1. 사용자는 자신의 비디오 생성 기록을 볼 수 있음
CREATE POLICY "Users can view own generations"
ON public.video_generations FOR SELECT
USING (
  auth.uid()::text = user_id OR
  user_id = 'anonymous'
);

-- 2. 인증된 사용자는 비디오 생성을 만들 수 있음
CREATE POLICY "Authenticated users can create generations"
ON public.video_generations FOR INSERT
WITH CHECK (
  auth.uid()::text = user_id OR
  user_id = 'anonymous'
);

-- 3. 모든 사용자가 job_id로 업데이트 가능 (webhook 지원)
-- job_id가 있는 레코드는 webhook에서 업데이트 가능
CREATE POLICY "Anyone can update by job_id"
ON public.video_generations FOR UPDATE
USING (job_id IS NOT NULL)
WITH CHECK (job_id IS NOT NULL);

-- 4. 사용자는 자신의 레코드를 삭제할 수 있음
CREATE POLICY "Users can delete own generations"
ON public.video_generations FOR DELETE
USING (
  auth.uid()::text = user_id
);
</file>

<file path="supabase/migrations/012_20250131_update_rls_strict_policies.sql">
-- 엄격한 RLS 정책 설정 (Service Role 사용을 전제로 함)

-- 기존 정책 모두 삭제
DROP POLICY IF EXISTS "Users can view their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can create their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can view own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Authenticated users can create generations" ON public.video_generations;
DROP POLICY IF EXISTS "Anyone can update by job_id" ON public.video_generations;
DROP POLICY IF EXISTS "Users can delete own generations" ON public.video_generations;

-- 새로운 엄격한 RLS 정책

-- 1. SELECT: 사용자는 자신의 레코드만 조회 가능
CREATE POLICY "Users can only view own generations"
ON public.video_generations FOR SELECT
USING (auth.uid()::text = user_id);

-- 2. INSERT: 인증된 사용자만 자신의 user_id로 생성 가능
CREATE POLICY "Users can only create own generations"
ON public.video_generations FOR INSERT
WITH CHECK (auth.uid()::text = user_id);

-- 3. UPDATE: 일반 사용자는 업데이트 불가 (Service Role만 가능)
-- 정책 없음 = 일반 사용자 업데이트 차단

-- 4. DELETE: 사용자는 자신의 레코드만 삭제 가능
CREATE POLICY "Users can only delete own generations"
ON public.video_generations FOR DELETE
USING (auth.uid()::text = user_id);

-- RLS가 활성화되어 있는지 확인
ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

-- 설명 추가
COMMENT ON TABLE public.video_generations IS 
'Video generation tracking. RLS enabled. Updates only via Service Role for security.';

-- video_generation_logs 테이블도 보호 (있다면)
DO $$ 
BEGIN
  IF EXISTS (
    SELECT FROM pg_tables 
    WHERE schemaname = 'public' 
    AND tablename = 'video_generation_logs'
  ) THEN
    -- RLS 활성화
    ALTER TABLE public.video_generation_logs ENABLE ROW LEVEL SECURITY;
    
    -- 정책: Service Role만 접근 가능 (정책 없음 = 접근 차단)
    -- 로그는 시스템 전용이므로 일반 사용자 접근 차단
  END IF;
END $$;
</file>

<file path="supabase/migrations/013_20250201_update_video_generations_user_id_to_uuid.sql">
-- Update video_generations table to use UUID for user_id and link with auth.users

-- Step 1: Drop all existing RLS policies that depend on user_id
DROP POLICY IF EXISTS "Users can view own videos" ON public.video_generations;
DROP POLICY IF EXISTS "Users can insert own videos" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update own videos" ON public.video_generations;
DROP POLICY IF EXISTS "Users can only view own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can only create own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can only delete own generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can view their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can create their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Service role full access" ON public.video_generations;

-- Drop any other policies that might exist
DO $$ 
DECLARE
    drop_commands text;
BEGIN
    -- Drop all policies on video_generations table
    SELECT string_agg('DROP POLICY IF EXISTS "' || policyname || '" ON public.video_generations;', ' ')
    INTO drop_commands
    FROM pg_policies 
    WHERE schemaname = 'public' AND tablename = 'video_generations';
    
    IF drop_commands IS NOT NULL THEN
        EXECUTE drop_commands;
    END IF;
END $$;

-- Step 2: Add new UUID column for user_id
ALTER TABLE public.video_generations 
ADD COLUMN user_uuid uuid;

-- Step 3: Check if there are existing records
DO $$
DECLARE
    record_count integer;
BEGIN
    SELECT COUNT(*) INTO record_count FROM public.video_generations;
    IF record_count > 0 THEN
        RAISE NOTICE 'Warning: % existing records will be deleted as they cannot be mapped to auth users', record_count;
    END IF;
END $$;

-- Step 4: Delete all existing records (since we can't map anonymous to auth users)
DELETE FROM public.video_generations;

-- Step 5: Drop the old user_id column
ALTER TABLE public.video_generations 
DROP COLUMN user_id;

-- Step 6: Rename user_uuid to user_id
ALTER TABLE public.video_generations 
RENAME COLUMN user_uuid TO user_id;

-- Step 7: Make user_id NOT NULL since anonymous is not allowed
ALTER TABLE public.video_generations
ALTER COLUMN user_id SET NOT NULL;

-- Step 8: Add foreign key constraint to auth.users
ALTER TABLE public.video_generations
ADD CONSTRAINT video_generations_user_id_fkey 
FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Step 9: Create index for better query performance
CREATE INDEX idx_video_generations_user_id ON public.video_generations(user_id);

-- Step 10: Update RLS policies for video_generations
-- Enable RLS
ALTER TABLE public.video_generations ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if any
DROP POLICY IF EXISTS "Users can view their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can create their own video generations" ON public.video_generations;
DROP POLICY IF EXISTS "Users can update their own video generations" ON public.video_generations;

-- Create new RLS policies
-- Policy: Users can view their own video generations
CREATE POLICY "Users can view their own video generations" 
ON public.video_generations FOR SELECT 
USING (
  auth.uid() = user_id
);

-- Policy: Users can create video generations
CREATE POLICY "Users can create their own video generations" 
ON public.video_generations FOR INSERT 
WITH CHECK (
  auth.uid() = user_id AND auth.uid() IS NOT NULL
);

-- Policy: Users can update their own video generations
CREATE POLICY "Users can update their own video generations" 
ON public.video_generations FOR UPDATE 
USING (
  auth.uid() = user_id
) 
WITH CHECK (
  auth.uid() = user_id
);

-- Policy: Users can delete their own video generations
CREATE POLICY "Users can delete their own video generations" 
ON public.video_generations FOR DELETE 
USING (
  auth.uid() = user_id
);

-- Policy: Service role can do everything (for webhooks and backend operations)
CREATE POLICY "Service role full access" 
ON public.video_generations 
FOR ALL 
USING (
  auth.role() = 'service_role'
);

-- Add comment for documentation
COMMENT ON COLUMN public.video_generations.user_id IS 'References auth.users(id). Required - anonymous users not allowed.';
</file>

<file path="supabase/migrations/014_20250204_add_favorite_to_video_generations.sql">
-- Add favorite functionality to video_generations table
-- Created: 2025-02-04

-- Add is_favorite column to video_generations table
ALTER TABLE public.video_generations 
ADD COLUMN IF NOT EXISTS is_favorite boolean DEFAULT false;

-- Create index for faster queries on favorite videos
CREATE INDEX IF NOT EXISTS idx_video_generations_is_favorite 
ON public.video_generations(is_favorite) 
WHERE is_favorite = true;

-- Create composite index for user's favorite videos
CREATE INDEX IF NOT EXISTS idx_video_generations_user_favorite 
ON public.video_generations(user_id, is_favorite, created_at DESC) 
WHERE is_favorite = true;

-- Add comment for documentation
COMMENT ON COLUMN public.video_generations.is_favorite IS 'Whether the user has marked this video as a favorite';
</file>

<file path="supabase/migrations/015_20250113_create_sound_generations.sql">
-- Create sound_generations table for AI sound generation tracking
CREATE TABLE IF NOT EXISTS sound_generations (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  job_id TEXT UNIQUE,
  prompt TEXT NOT NULL,
  title TEXT,
  duration_seconds NUMERIC NOT NULL CHECK (duration_seconds >= 1 AND duration_seconds <= 22),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  output_audio_url TEXT,
  error_message TEXT,
  webhook_status TEXT CHECK (webhook_status IN ('pending', 'delivered', 'failed')),
  webhook_delivered_at TIMESTAMPTZ,
  fal_request_id TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for better query performance
CREATE INDEX idx_sound_generations_user_id ON sound_generations(user_id);
CREATE INDEX idx_sound_generations_job_id ON sound_generations(job_id);
CREATE INDEX idx_sound_generations_status ON sound_generations(status);
CREATE INDEX idx_sound_generations_created_at ON sound_generations(created_at DESC);

-- Enable RLS
ALTER TABLE sound_generations ENABLE ROW LEVEL SECURITY;

-- Create RLS policies
CREATE POLICY "Users can view their own sound generations"
  ON sound_generations FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own sound generations"
  ON sound_generations FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Only service role can update (for webhook handling)
CREATE POLICY "Service role can update all sound generations"
  ON sound_generations FOR UPDATE
  USING (auth.role() = 'service_role');

-- Add comment to the table
COMMENT ON TABLE sound_generations IS 'Tracks AI sound generation jobs using fal.ai ElevenLabs API';
COMMENT ON COLUMN sound_generations.job_id IS 'Unique job ID for tracking async sound generation';
COMMENT ON COLUMN sound_generations.prompt IS 'User input describing the sound effect to generate';
COMMENT ON COLUMN sound_generations.duration_seconds IS 'Duration of the sound effect in seconds (1-22)';
COMMENT ON COLUMN sound_generations.webhook_status IS 'Status of webhook delivery from fal.ai';
COMMENT ON COLUMN sound_generations.fal_request_id IS 'Request ID returned by fal.ai for tracking';
</file>

<file path="supabase/migrations/016_create_video_renders_table.sql">
-- video_renders 테이블 생성
CREATE TABLE IF NOT EXISTS video_renders (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  project_name text NOT NULL,
  render_id text NOT NULL UNIQUE,
  status text DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')),
  aspect_ratio text CHECK (aspect_ratio IN ('9:16', '1:1', '16:9')),
  duration_frames integer,
  output_url text,
  thumbnail_url text,
  video_clips jsonb, -- 렌더링에 사용된 클립 정보 저장
  text_clips jsonb,  -- 텍스트 효과 정보 저장
  sound_clips jsonb, -- 사운드 정보 저장
  created_at timestamp with time zone DEFAULT now(),
  completed_at timestamp with time zone
);

-- 인덱스 생성
CREATE INDEX IF NOT EXISTS idx_video_renders_user_id ON video_renders(user_id);
CREATE INDEX IF NOT EXISTS idx_video_renders_render_id ON video_renders(render_id);
CREATE INDEX IF NOT EXISTS idx_video_renders_status ON video_renders(status);
CREATE INDEX IF NOT EXISTS idx_video_renders_created_at ON video_renders(created_at DESC);

-- RLS (Row Level Security) 정책
ALTER TABLE video_renders ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신의 렌더링만 볼 수 있음
CREATE POLICY "Users can view own renders" ON video_renders
  FOR SELECT USING (auth.uid() = user_id);

-- 사용자는 자신의 렌더링만 생성할 수 있음
CREATE POLICY "Users can create own renders" ON video_renders
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 사용자는 자신의 렌더링만 업데이트할 수 있음
CREATE POLICY "Users can update own renders" ON video_renders
  FOR UPDATE USING (auth.uid() = user_id);

-- 사용자는 자신의 렌더링만 삭제할 수 있음
CREATE POLICY "Users can delete own renders" ON video_renders
  FOR DELETE USING (auth.uid() = user_id);

-- 코멘트 추가
COMMENT ON TABLE video_renders IS '비디오 렌더링 작업 기록';
COMMENT ON COLUMN video_renders.user_id IS '렌더링을 요청한 사용자 ID';
COMMENT ON COLUMN video_renders.project_name IS '프로젝트 이름 (사용자가 지정)';
COMMENT ON COLUMN video_renders.render_id IS 'Remotion Lambda 렌더링 ID';
COMMENT ON COLUMN video_renders.status IS '렌더링 상태: processing, completed, failed';
COMMENT ON COLUMN video_renders.aspect_ratio IS '비디오 화면 비율';
COMMENT ON COLUMN video_renders.duration_frames IS '총 프레임 수';
COMMENT ON COLUMN video_renders.output_url IS '완성된 MP4 파일 S3 URL';
COMMENT ON COLUMN video_renders.thumbnail_url IS '썸네일 이미지 URL';
COMMENT ON COLUMN video_renders.video_clips IS '사용된 비디오 클립 정보 (JSON)';
COMMENT ON COLUMN video_renders.text_clips IS '사용된 텍스트 효과 정보 (JSON)';
COMMENT ON COLUMN video_renders.sound_clips IS '사용된 사운드 정보 (JSON)';
</file>

<file path="supabase/migrations/017_add_content_hash_to_video_renders.sql">
-- video_renders 테이블에 content_hash 컬럼 추가
ALTER TABLE video_renders 
ADD COLUMN IF NOT EXISTS content_hash text;

-- content_hash에 인덱스 추가 (빠른 조회를 위해)
CREATE INDEX IF NOT EXISTS idx_video_renders_content_hash 
ON video_renders(content_hash);

-- content_hash와 status 복합 인덱스 (자주 함께 조회되므로)
CREATE INDEX IF NOT EXISTS idx_video_renders_content_hash_status 
ON video_renders(content_hash, status);

-- 코멘트 추가
COMMENT ON COLUMN video_renders.content_hash IS '콘텐츠 해시값 (중복 렌더링 방지용)';
</file>

<file path="supabase/migrations/018_20250114_add_sound_generation_grouping.sql">
-- Add columns for grouping sound generations
ALTER TABLE sound_generations 
ADD COLUMN generation_group_id TEXT,
ADD COLUMN variation_number INTEGER CHECK (variation_number >= 1 AND variation_number <= 4);

-- Add index for group_id to improve query performance
CREATE INDEX idx_sound_generations_group_id ON sound_generations(generation_group_id);

-- Add composite index for user_id and generation_group_id
CREATE INDEX idx_sound_generations_user_group ON sound_generations(user_id, generation_group_id);

-- Add comment for new columns
COMMENT ON COLUMN sound_generations.generation_group_id IS 'Groups multiple variations generated from the same prompt';
COMMENT ON COLUMN sound_generations.variation_number IS 'Variation number within a group (1-4)';
</file>

<file path="supabase/migrations/019_20250814_create_project_saves_table_v2.sql">
-- project_saves 테이블 생성 (BIGINT ID 사용)
CREATE TABLE IF NOT EXISTS project_saves (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  project_name text NOT NULL,
  latest_render_id text,
  content_snapshot jsonb NOT NULL,
  content_hash text NOT NULL,
  version integer DEFAULT 1 NOT NULL,
  is_latest boolean DEFAULT true NOT NULL,
  created_at timestamp with time zone DEFAULT now(),
  updated_at timestamp with time zone DEFAULT now()
);

-- 인덱스 생성
CREATE INDEX IF NOT EXISTS idx_project_saves_user_id ON project_saves(user_id);
CREATE INDEX IF NOT EXISTS idx_project_saves_project_name ON project_saves(project_name);
CREATE INDEX IF NOT EXISTS idx_project_saves_is_latest ON project_saves(is_latest);
CREATE INDEX IF NOT EXISTS idx_project_saves_content_hash ON project_saves(content_hash);
CREATE INDEX IF NOT EXISTS idx_project_saves_user_project_latest ON project_saves(user_id, project_name, is_latest);

-- RLS (Row Level Security) 정책 활성화
ALTER TABLE project_saves ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신의 프로젝트만 볼 수 있음
CREATE POLICY "Users can view own project saves" ON project_saves
  FOR SELECT USING (auth.uid() = user_id);

-- 사용자는 자신의 프로젝트만 생성할 수 있음
CREATE POLICY "Users can create own project saves" ON project_saves
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 사용자는 자신의 프로젝트만 업데이트할 수 있음
CREATE POLICY "Users can update own project saves" ON project_saves
  FOR UPDATE USING (auth.uid() = user_id);

-- 사용자는 자신의 프로젝트만 삭제할 수 있음
CREATE POLICY "Users can delete own project saves" ON project_saves
  FOR DELETE USING (auth.uid() = user_id);

-- Service role은 모든 작업 가능 (서버 사이드 작업용)
CREATE POLICY "Service role full access" ON project_saves
  FOR ALL USING (auth.role() = 'service_role');

-- 코멘트 추가
COMMENT ON TABLE project_saves IS '비디오 프로젝트 저장 기록';
COMMENT ON COLUMN project_saves.id IS '프로젝트 저장 고유 ID (자동 증가)';
COMMENT ON COLUMN project_saves.user_id IS '프로젝트를 저장한 사용자 ID';
COMMENT ON COLUMN project_saves.project_name IS '프로젝트 이름 (사용자가 지정)';
COMMENT ON COLUMN project_saves.latest_render_id IS '최신 렌더링 ID (video_renders.render_id 참조)';
COMMENT ON COLUMN project_saves.content_snapshot IS '프로젝트 컨텐츠 스냅샷 (클립, 설정 등 JSON)';
COMMENT ON COLUMN project_saves.content_hash IS '컨텐츠 해시 (변경사항 감지용)';
COMMENT ON COLUMN project_saves.version IS '프로젝트 버전 번호';
COMMENT ON COLUMN project_saves.is_latest IS '최신 버전 여부';
COMMENT ON COLUMN project_saves.created_at IS '생성 시간';
COMMENT ON COLUMN project_saves.updated_at IS '업데이트 시간';

-- updated_at 자동 업데이트 트리거 함수
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- updated_at 트리거 생성
DROP TRIGGER IF EXISTS update_project_saves_updated_at ON project_saves;
CREATE TRIGGER update_project_saves_updated_at BEFORE UPDATE
    ON project_saves FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();
</file>

<file path="supabase/migrations/020_20250814_update_video_renders_table.sql">
-- 기존 video_renders 테이블 삭제 및 재생성 (BIGINT ID 사용)
-- 주의: 이 마이그레이션은 기존 데이터를 삭제합니다. 프로덕션에서는 데이터 백업 필수!

-- 기존 테이블 삭제
DROP TABLE IF EXISTS video_renders CASCADE;

-- video_renders 테이블 재생성 (BIGINT ID 사용)
CREATE TABLE IF NOT EXISTS video_renders (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  project_name text NOT NULL,
  render_id text NOT NULL UNIQUE,
  status text DEFAULT 'processing' CHECK (status IN ('processing', 'completed', 'failed')),
  aspect_ratio text CHECK (aspect_ratio IN ('9:16', '1:1', '16:9')),
  duration_frames integer,
  output_url text,
  thumbnail_url text,
  video_clips jsonb,
  text_clips jsonb,
  sound_clips jsonb,
  content_hash text,
  project_save_id BIGINT REFERENCES project_saves(id) ON DELETE SET NULL,
  created_at timestamp with time zone DEFAULT now(),
  completed_at timestamp with time zone
);

-- 인덱스 생성
CREATE INDEX IF NOT EXISTS idx_video_renders_user_id ON video_renders(user_id);
CREATE INDEX IF NOT EXISTS idx_video_renders_render_id ON video_renders(render_id);
CREATE INDEX IF NOT EXISTS idx_video_renders_status ON video_renders(status);
CREATE INDEX IF NOT EXISTS idx_video_renders_created_at ON video_renders(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_video_renders_content_hash ON video_renders(content_hash);
CREATE INDEX IF NOT EXISTS idx_video_renders_content_hash_status ON video_renders(content_hash, status);
CREATE INDEX IF NOT EXISTS idx_video_renders_project_save_id ON video_renders(project_save_id);

-- RLS (Row Level Security) 정책
ALTER TABLE video_renders ENABLE ROW LEVEL SECURITY;

-- 사용자는 자신의 렌더링만 볼 수 있음
CREATE POLICY "Users can view own renders" ON video_renders
  FOR SELECT USING (auth.uid() = user_id);

-- 사용자는 자신의 렌더링만 생성할 수 있음
CREATE POLICY "Users can create own renders" ON video_renders
  FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 사용자는 자신의 렌더링만 업데이트할 수 있음
CREATE POLICY "Users can update own renders" ON video_renders
  FOR UPDATE USING (auth.uid() = user_id);

-- 사용자는 자신의 렌더링만 삭제할 수 있음
CREATE POLICY "Users can delete own renders" ON video_renders
  FOR DELETE USING (auth.uid() = user_id);

-- Service role은 모든 작업 가능 (서버 사이드 작업용)
CREATE POLICY "Service role full access" ON video_renders
  FOR ALL USING (auth.role() = 'service_role');

-- 코멘트 추가
COMMENT ON TABLE video_renders IS '비디오 렌더링 작업 기록';
COMMENT ON COLUMN video_renders.id IS '렌더링 고유 ID (자동 증가)';
COMMENT ON COLUMN video_renders.user_id IS '렌더링을 요청한 사용자 ID';
COMMENT ON COLUMN video_renders.project_name IS '프로젝트 이름 (사용자가 지정)';
COMMENT ON COLUMN video_renders.render_id IS 'Remotion Lambda 렌더링 ID';
COMMENT ON COLUMN video_renders.status IS '렌더링 상태: processing, completed, failed';
COMMENT ON COLUMN video_renders.aspect_ratio IS '비디오 화면 비율';
COMMENT ON COLUMN video_renders.duration_frames IS '총 프레임 수';
COMMENT ON COLUMN video_renders.output_url IS '완성된 MP4 파일 S3 URL';
COMMENT ON COLUMN video_renders.thumbnail_url IS '썸네일 이미지 URL';
COMMENT ON COLUMN video_renders.video_clips IS '사용된 비디오 클립 정보 (JSON)';
COMMENT ON COLUMN video_renders.text_clips IS '사용된 텍스트 효과 정보 (JSON)';
COMMENT ON COLUMN video_renders.sound_clips IS '사용된 사운드 정보 (JSON)';
COMMENT ON COLUMN video_renders.content_hash IS '콘텐츠 해시값 (중복 렌더링 방지용)';
COMMENT ON COLUMN video_renders.project_save_id IS '연관된 프로젝트 저장 ID (project_saves.id 참조)';
</file>

<file path="supabase/migrations/021_add_generation_type_to_sound_generations.sql">
-- Add generation_type column to sound_generations table
ALTER TABLE sound_generations 
ADD COLUMN IF NOT EXISTS generation_type text DEFAULT 'sound_effect';

-- Add CHECK constraint for generation_type values
ALTER TABLE sound_generations 
ADD CONSTRAINT sound_generations_generation_type_check 
CHECK (generation_type IN ('sound_effect', 'music', 'from_video'));

-- Drop the old duration constraint
ALTER TABLE sound_generations 
DROP CONSTRAINT IF EXISTS sound_generations_duration_seconds_check;

-- Add new constraint that allows 32 seconds for music type
ALTER TABLE sound_generations 
ADD CONSTRAINT sound_generations_duration_seconds_type_check 
CHECK (
  (generation_type = 'music' AND duration_seconds = 32) OR
  (generation_type IN ('sound_effect', 'from_video') AND duration_seconds >= 1 AND duration_seconds <= 22)
);

-- Update existing records to have the correct generation_type
UPDATE sound_generations 
SET generation_type = 'sound_effect' 
WHERE generation_type IS NULL;
</file>

<file path="supabase/migrations/021_add_project_saves_foreign_key.sql">
-- Migration: Add foreign key constraint to project_saves.latest_render_id
-- Created: 2025-01-19
-- Description: Adds foreign key relationship between project_saves and video_renders tables

-- Step 1: Clean up any orphaned render_ids that don't exist in video_renders
-- This ensures existing data won't violate the foreign key constraint
UPDATE project_saves 
SET latest_render_id = NULL 
WHERE latest_render_id IS NOT NULL 
  AND latest_render_id NOT IN (
    SELECT render_id 
    FROM video_renders 
    WHERE render_id IS NOT NULL
  );

-- Log how many records were cleaned up (optional)
DO $$
DECLARE
  cleaned_count INTEGER;
BEGIN
  GET DIAGNOSTICS cleaned_count = ROW_COUNT;
  IF cleaned_count > 0 THEN
    RAISE NOTICE 'Cleaned up % orphaned render_id references', cleaned_count;
  END IF;
END $$;

-- Step 2: Add the foreign key constraint
-- Use IF NOT EXISTS to make the migration idempotent
DO $$
BEGIN
  -- Check if the foreign key constraint already exists
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints 
    WHERE constraint_name = 'project_saves_latest_render_id_fkey'
      AND table_name = 'project_saves'
  ) THEN
    -- Add foreign key constraint with ON DELETE SET NULL
    -- This ensures that if a render is deleted, the reference is set to NULL
    ALTER TABLE project_saves 
    ADD CONSTRAINT project_saves_latest_render_id_fkey 
    FOREIGN KEY (latest_render_id) 
    REFERENCES video_renders(render_id) 
    ON DELETE SET NULL
    ON UPDATE CASCADE;
    
    RAISE NOTICE 'Foreign key constraint project_saves_latest_render_id_fkey added successfully';
  ELSE
    RAISE NOTICE 'Foreign key constraint project_saves_latest_render_id_fkey already exists';
  END IF;
END $$;

-- Step 3: Create index on latest_render_id for better join performance (if not exists)
CREATE INDEX IF NOT EXISTS idx_project_saves_latest_render_id 
ON project_saves(latest_render_id) 
WHERE latest_render_id IS NOT NULL;

-- Step 4: Add comment to document the relationship
COMMENT ON CONSTRAINT project_saves_latest_render_id_fkey ON project_saves 
IS 'Foreign key ensuring latest_render_id references a valid render in video_renders table';

-- Step 5: Verify the constraint was created successfully
DO $$
BEGIN
  IF EXISTS (
    SELECT 1
    FROM information_schema.table_constraints 
    WHERE constraint_name = 'project_saves_latest_render_id_fkey'
      AND table_name = 'project_saves'
  ) THEN
    RAISE NOTICE 'Migration completed successfully: Foreign key constraint is active';
  ELSE
    RAISE EXCEPTION 'Migration failed: Foreign key constraint was not created';
  END IF;
END $$;

-- Additional safety check: Ensure render_id in video_renders is unique
-- This should already be the case, but let's verify
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints 
    WHERE constraint_type = 'UNIQUE'
      AND table_name = 'video_renders'
      AND constraint_name LIKE '%render_id%'
  ) THEN
    -- If no unique constraint exists, check if there are duplicates
    IF EXISTS (
      SELECT render_id, COUNT(*)
      FROM video_renders
      WHERE render_id IS NOT NULL
      GROUP BY render_id
      HAVING COUNT(*) > 1
    ) THEN
      RAISE WARNING 'Duplicate render_ids found in video_renders table. Please clean up before adding unique constraint.';
    ELSE
      -- Add unique constraint if no duplicates exist
      ALTER TABLE video_renders 
      ADD CONSTRAINT video_renders_render_id_unique 
      UNIQUE (render_id);
      
      RAISE NOTICE 'Added unique constraint on video_renders.render_id';
    END IF;
  END IF;
END $$;
</file>

<file path="supabase/migrations/022_simplify_project_saves.sql">
-- Migration: Simplify project_saves table structure
-- Created: 2025-01-19
-- Description: Remove versioning, add latest_video_url, add unique constraint

-- Step 1: Add latest_video_url column if it doesn't exist
ALTER TABLE project_saves 
ADD COLUMN IF NOT EXISTS latest_video_url TEXT;

-- Step 2: Add unique constraint for user_id + project_name
-- This ensures one project per name per user
DO $$
BEGIN
  -- Check if constraint already exists
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints 
    WHERE constraint_name = 'unique_project_per_user'
      AND table_name = 'project_saves'
  ) THEN
    -- Before adding constraint, handle any duplicates
    -- Keep only the latest version for each project
    DELETE FROM project_saves p1
    WHERE EXISTS (
      SELECT 1 
      FROM project_saves p2 
      WHERE p2.user_id = p1.user_id 
        AND p2.project_name = p1.project_name
        AND p2.id > p1.id
    );
    
    -- Now add the unique constraint
    ALTER TABLE project_saves 
    ADD CONSTRAINT unique_project_per_user 
    UNIQUE (user_id, project_name);
    
    RAISE NOTICE 'Added unique constraint: unique_project_per_user';
  ELSE
    RAISE NOTICE 'Unique constraint unique_project_per_user already exists';
  END IF;
END $$;

-- Step 3: Drop version-related columns (if they exist)
-- These are no longer needed with the simplified approach
DO $$
BEGIN
  -- Drop version column if exists
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'project_saves' 
      AND column_name = 'version'
  ) THEN
    ALTER TABLE project_saves DROP COLUMN version;
    RAISE NOTICE 'Dropped column: version';
  END IF;
  
  -- Drop is_latest column if exists
  IF EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'project_saves' 
      AND column_name = 'is_latest'
  ) THEN
    ALTER TABLE project_saves DROP COLUMN is_latest;
    RAISE NOTICE 'Dropped column: is_latest';
  END IF;
END $$;

-- Step 4: Create index on latest_video_url for faster queries
CREATE INDEX IF NOT EXISTS idx_project_saves_latest_video_url 
ON project_saves(latest_video_url) 
WHERE latest_video_url IS NOT NULL;

-- Step 5: Create composite index for faster lookups
CREATE INDEX IF NOT EXISTS idx_project_saves_user_project 
ON project_saves(user_id, project_name);

-- Step 6: Update comments
COMMENT ON COLUMN project_saves.latest_video_url IS 'URL of the latest rendered video stored in Supabase Storage';
COMMENT ON TABLE project_saves IS 'Stores the current state of video projects (single record per project)';

-- Step 7: Migrate existing data (if needed)
-- If there are multiple versions of the same project, keep only the latest
DO $$
DECLARE
  duplicate_count INTEGER;
BEGIN
  -- Count duplicates before cleanup
  SELECT COUNT(*) INTO duplicate_count
  FROM (
    SELECT user_id, project_name, COUNT(*) as cnt
    FROM project_saves
    GROUP BY user_id, project_name
    HAVING COUNT(*) > 1
  ) duplicates;
  
  IF duplicate_count > 0 THEN
    RAISE NOTICE 'Found % duplicate project(s). Keeping only the latest version of each.', duplicate_count;
    
    -- Keep only the record with the highest ID (most recent) for each project
    DELETE FROM project_saves p1
    WHERE EXISTS (
      SELECT 1 
      FROM project_saves p2 
      WHERE p2.user_id = p1.user_id 
        AND p2.project_name = p1.project_name
        AND p2.id > p1.id
    );
  END IF;
END $$;

-- Step 8: Verify the migration
DO $$
DECLARE
  has_latest_video_url BOOLEAN;
  has_unique_constraint BOOLEAN;
  has_version_column BOOLEAN;
  has_is_latest_column BOOLEAN;
BEGIN
  -- Check if latest_video_url exists
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'project_saves' 
      AND column_name = 'latest_video_url'
  ) INTO has_latest_video_url;
  
  -- Check if unique constraint exists
  SELECT EXISTS (
    SELECT 1 FROM information_schema.table_constraints 
    WHERE constraint_name = 'unique_project_per_user'
      AND table_name = 'project_saves'
  ) INTO has_unique_constraint;
  
  -- Check if old columns are removed
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'project_saves' 
      AND column_name = 'version'
  ) INTO has_version_column;
  
  SELECT EXISTS (
    SELECT 1 FROM information_schema.columns 
    WHERE table_name = 'project_saves' 
      AND column_name = 'is_latest'
  ) INTO has_is_latest_column;
  
  -- Report results
  IF has_latest_video_url AND has_unique_constraint 
     AND NOT has_version_column AND NOT has_is_latest_column THEN
    RAISE NOTICE 'Migration completed successfully!';
    RAISE NOTICE '✓ latest_video_url column added';
    RAISE NOTICE '✓ unique_project_per_user constraint added';
    RAISE NOTICE '✓ version column removed';
    RAISE NOTICE '✓ is_latest column removed';
  ELSE
    RAISE WARNING 'Migration may not have completed fully. Please check:';
    IF NOT has_latest_video_url THEN
      RAISE WARNING '✗ latest_video_url column missing';
    END IF;
    IF NOT has_unique_constraint THEN
      RAISE WARNING '✗ unique_project_per_user constraint missing';
    END IF;
    IF has_version_column THEN
      RAISE WARNING '✗ version column still exists';
    END IF;
    IF has_is_latest_column THEN
      RAISE WARNING '✗ is_latest column still exists';
    END IF;
  END IF;
END $$;
</file>

<file path="supabase/migrations/023_20250320_user_uploaded_videos.sql">
-- Create user_uploaded_videos table
CREATE TABLE IF NOT EXISTS public.user_uploaded_videos (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    storage_path TEXT NOT NULL,
    file_size BIGINT NOT NULL,
    duration FLOAT,
    aspect_ratio TEXT,
    thumbnail_url TEXT,
    metadata JSONB DEFAULT '{}',
    uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better performance
CREATE INDEX IF NOT EXISTS idx_user_uploaded_videos_user_id ON public.user_uploaded_videos(user_id);
CREATE INDEX IF NOT EXISTS idx_user_uploaded_videos_uploaded_at ON public.user_uploaded_videos(uploaded_at DESC);
CREATE INDEX IF NOT EXISTS idx_user_uploaded_videos_is_deleted ON public.user_uploaded_videos(is_deleted);

-- DISABLE RLS for MVP (security handled at API level)
-- This follows the same pattern as other tables in the project
ALTER TABLE public.user_uploaded_videos DISABLE ROW LEVEL SECURITY;

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Only create trigger if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_trigger 
        WHERE tgname = 'set_updated_at' 
        AND tgrelid = 'public.user_uploaded_videos'::regclass
    ) THEN
        CREATE TRIGGER set_updated_at
            BEFORE UPDATE ON public.user_uploaded_videos
            FOR EACH ROW
            EXECUTE FUNCTION public.handle_updated_at();
    END IF;
END;
$$;

-- Grant permissions
GRANT ALL ON public.user_uploaded_videos TO authenticated;
GRANT ALL ON public.user_uploaded_videos TO service_role;
GRANT USAGE, SELECT ON SEQUENCE public.user_uploaded_videos_id_seq TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.user_uploaded_videos_id_seq TO service_role;

-- Add comments for documentation
COMMENT ON TABLE public.user_uploaded_videos IS 'Stores user-uploaded video files metadata';
COMMENT ON COLUMN public.user_uploaded_videos.user_id IS 'Reference to the user who uploaded the video';
COMMENT ON COLUMN public.user_uploaded_videos.file_name IS 'Original file name of the uploaded video';
COMMENT ON COLUMN public.user_uploaded_videos.storage_path IS 'Path to the file in Supabase Storage';
COMMENT ON COLUMN public.user_uploaded_videos.file_size IS 'File size in bytes';
COMMENT ON COLUMN public.user_uploaded_videos.duration IS 'Video duration in seconds';
COMMENT ON COLUMN public.user_uploaded_videos.aspect_ratio IS 'Video aspect ratio (e.g., 16:9, 9:16, 1:1)';
COMMENT ON COLUMN public.user_uploaded_videos.thumbnail_url IS 'URL to video thumbnail if generated';
COMMENT ON COLUMN public.user_uploaded_videos.metadata IS 'Additional metadata in JSON format';
COMMENT ON COLUMN public.user_uploaded_videos.is_deleted IS 'Soft delete flag';
</file>

<file path="supabase/migrations/024_20250320_storage_policies_user_uploads.sql">
-- Storage configuration for videos bucket - MVP approach
-- Note: The videos bucket already exists and is used for AI-generated videos
-- For MVP, we're not adding specific RLS policies for user uploads
-- All security is handled at the API Route level using Service Client
-- This follows the same pattern as the rest of the application

-- The videos bucket structure:
-- videos/
--   ├── ai-generations/     (existing AI-generated videos)
--   │   └── {job_id}/
--   │       └── output.mp4
--   └── user-uploads/       (new user uploaded videos)
--       └── {user_id}/
--           └── {timestamp}_{filename}.mp4

-- No additional storage policies needed for MVP
-- The existing public read policy for the videos bucket is sufficient
-- All upload/update/delete operations are handled through API routes with Service Client

-- If you need to add RLS policies in the future, use these templates:
-- INSERT policy: ((storage.foldername(name))[1] = 'user-uploads') AND ((storage.foldername(name))[2] = auth.uid()::text)
-- UPDATE policy: ((storage.foldername(name))[1] = 'user-uploads') AND ((storage.foldername(name))[2] = auth.uid()::text)
-- DELETE policy: ((storage.foldername(name))[1] = 'user-uploads') AND ((storage.foldername(name))[2] = auth.uid()::text)
</file>

<file path="supabase/migrations/025_add_thumbnail_to_project_saves.sql">
-- Add thumbnail_url column to project_saves table
-- 프로젝트의 대표 썸네일 이미지 URL을 저장하기 위한 컬럼 추가

ALTER TABLE project_saves 
ADD COLUMN IF NOT EXISTS thumbnail_url TEXT;

-- 컬럼에 대한 설명 추가
COMMENT ON COLUMN project_saves.thumbnail_url IS 'Thumbnail URL for the project (typically from the first video clip)';

-- 인덱스 추가 (썸네일이 있는 프로젝트를 빠르게 조회하기 위함)
CREATE INDEX IF NOT EXISTS idx_project_saves_thumbnail 
ON project_saves(thumbnail_url) 
WHERE thumbnail_url IS NOT NULL;
</file>

<file path="supabase/migrations/025_create_user_uploaded_music.sql">
-- Create user_uploaded_music table for storing user-uploaded music files
CREATE TABLE IF NOT EXISTS public.user_uploaded_music (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    file_name TEXT NOT NULL,
    storage_path TEXT NOT NULL,
    file_size BIGINT NOT NULL,
    duration FLOAT,
    metadata JSONB DEFAULT '{}',
    uploaded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Create indexes for better query performance
CREATE INDEX idx_user_uploaded_music_user_id ON public.user_uploaded_music(user_id);
CREATE INDEX idx_user_uploaded_music_uploaded_at ON public.user_uploaded_music(uploaded_at DESC);
CREATE INDEX idx_user_uploaded_music_is_deleted ON public.user_uploaded_music(is_deleted);
CREATE INDEX idx_user_uploaded_music_genre ON public.user_uploaded_music(genre);

-- DISABLE RLS for MVP (security handled at API level)
ALTER TABLE public.user_uploaded_music DISABLE ROW LEVEL SECURITY;

-- Create updated_at trigger
CREATE OR REPLACE FUNCTION public.handle_music_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_music_updated_at
    BEFORE UPDATE ON public.user_uploaded_music
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_music_updated_at();

-- Grant permissions
GRANT ALL ON public.user_uploaded_music TO authenticated;
GRANT USAGE, SELECT ON SEQUENCE public.user_uploaded_music_id_seq TO authenticated;

-- Add comment for documentation
COMMENT ON TABLE public.user_uploaded_music IS 'Stores metadata for user-uploaded music files in Storage';
COMMENT ON COLUMN public.user_uploaded_music.storage_path IS 'Path in user-upload bucket: music/{user_id}/{timestamp}_{filename}';
COMMENT ON COLUMN public.user_uploaded_music.bpm IS 'Beats per minute for tempo matching';
COMMENT ON COLUMN public.user_uploaded_music.metadata IS 'Additional metadata: mime_type, original_name, bitrate, sample_rate, etc';
</file>

<file path="supabase/migrations/20240119_create_image_brush_history.sql">
-- Create image_brush_history table for tracking AI image editing history
-- Note: RLS is DISABLED - Access is controlled through Next.js API Routes only
CREATE TABLE IF NOT EXISTS public.image_brush_history (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  original_image TEXT, -- Reference to original image (first 100 chars of base64)
  mask_image TEXT, -- Reference to mask image (first 100 chars of base64)
  prompt TEXT NOT NULL, -- User prompt for generation
  result_url TEXT NOT NULL, -- URL of the generated image in Supabase Storage
  mode TEXT CHECK (mode IN ('flux', 'i2i')) DEFAULT 'flux', -- Processing mode
  processing_time INTEGER, -- Processing time in milliseconds
  metadata JSONB DEFAULT '{}', -- Additional metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create indexes for better query performance
CREATE INDEX idx_image_brush_history_user_id ON public.image_brush_history(user_id);
CREATE INDEX idx_image_brush_history_created_at ON public.image_brush_history(created_at DESC);

-- IMPORTANT: RLS is intentionally DISABLED
-- This table should only be accessed through server-side API routes using Service Role Key
-- Direct client access is not allowed for security reasons
ALTER TABLE public.image_brush_history DISABLE ROW LEVEL SECURITY;

-- Add updated_at trigger
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_image_brush_history_updated_at
  BEFORE UPDATE ON public.image_brush_history
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Add comment to table
COMMENT ON TABLE public.image_brush_history IS 'Stores history of AI image brush (inpainting) operations';
COMMENT ON COLUMN public.image_brush_history.original_image IS 'Reference to original image (truncated base64 for logging)';
COMMENT ON COLUMN public.image_brush_history.mask_image IS 'Reference to mask image (truncated base64 for logging)';
COMMENT ON COLUMN public.image_brush_history.prompt IS 'User prompt used for AI generation';
COMMENT ON COLUMN public.image_brush_history.result_url IS 'Public URL of the generated image';
COMMENT ON COLUMN public.image_brush_history.mode IS 'Processing mode: flux (FLUX Fill) or i2i (Image to Image)';
COMMENT ON COLUMN public.image_brush_history.processing_time IS 'Time taken to process in milliseconds';
</file>

<file path="supabase/migrations/20240120_update_image_brush_history_urls.sql">
-- Update image_brush_history table to store URLs instead of base64 references
-- This migration adds new columns for storing image URLs and migrates existing data

-- Add new URL columns
ALTER TABLE public.image_brush_history 
ADD COLUMN IF NOT EXISTS original_image_url TEXT,
ADD COLUMN IF NOT EXISTS mask_image_url TEXT;

-- Update column comments
COMMENT ON COLUMN public.image_brush_history.original_image_url IS 'Public URL of the original image stored in Supabase Storage';
COMMENT ON COLUMN public.image_brush_history.mask_image_url IS 'Public URL of the mask image stored in Supabase Storage';

-- Keep old columns for backward compatibility but mark as deprecated
COMMENT ON COLUMN public.image_brush_history.original_image IS 'DEPRECATED: Use original_image_url instead';
COMMENT ON COLUMN public.image_brush_history.mask_image IS 'DEPRECATED: Use mask_image_url instead';

-- Note: In production, you may want to:
-- 1. Migrate existing data from base64 to URLs
-- 2. Drop the old columns after migration is complete
-- 3. Add NOT NULL constraints to new URL columns if required
</file>

<file path="types/image-brush.ts">
/**
 * Image Brush 기능 관련 타입 정의
 */

/**
 * Image Brush 요청 타입
 */
export interface ImageBrushRequest {
  /** Base64 인코딩된 원본 이미지 */
  image: string;
  /** Base64 인코딩된 마스크 이미지 (흰색이 마스크 영역) */
  mask: string;
  /** AI 생성을 위한 프롬프트 */
  prompt: string;
  /** 처리 모드 - flux: FLUX Fill API, i2i: RunPod I2I */
  mode: 'flux' | 'i2i';
  /** 사용자 ID */
  userId?: string;
}

/**
 * Image Brush 응답 타입
 */
export interface ImageBrushResponse {
  /** 처리 성공 여부 */
  success: boolean;
  /** 처리된 이미지 URL (Supabase Storage) */
  imageUrl?: string;
  /** 원본 이미지 URL (디버깅용) */
  originalImageUrl?: string;
  /** 마스크 이미지 URL (디버깅용) */
  maskImageUrl?: string;
  /** 에러 메시지 */
  error?: string;
  /** 처리 시간 (ms) */
  processingTime?: number;
}

/**
 * 브러시 설정 타입
 */
export interface BrushSettings {
  /** 브러시 크기 (5 ~ 100px) */
  size: number;
  /** 브러시 불투명도 (0.1 ~ 1.0) */
  opacity: number;
  /** 브러시 경도 (0 ~ 1, 0은 부드러움, 1은 딱딱함) */
  hardness: number;
}

/**
 * 브러시 도구 타입
 */
export type BrushTool = 'brush' | 'eraser' | 'clear';

/**
 * Image Brush 히스토리 항목
 */
export interface ImageBrushHistoryItem {
  /** 히스토리 항목 ID */
  id: string;
  /** 원본 이미지 URL */
  original: string;
  /** 브러시 처리된 이미지 URL */
  brushed: string;
  /** 사용된 프롬프트 */
  prompt: string;
  /** 생성 타임스탬프 */
  timestamp: number;
  /** 처리 모드 */
  mode: 'flux' | 'i2i';
}

/**
 * Image Brush 모달 상태
 */
export interface ImageBrushModalState {
  /** 모달 열림 상태 */
  isOpen: boolean;
  /** 처리 중 상태 */
  isProcessing: boolean;
  /** 현재 선택된 도구 */
  currentTool: BrushTool;
  /** 브러시 설정 */
  brushSettings: BrushSettings;
  /** 입력된 프롬프트 */
  prompt: string;
  /** 처리 모드 */
  mode: 'flux' | 'i2i';
  /** 진행률 (0 ~ 100) */
  progress: number;
  /** 에러 메시지 */
  error: string | null;
}

/**
 * Canvas 마우스 이벤트 타입
 */
export interface CanvasMouseEvent {
  /** X 좌표 (Canvas 기준) */
  x: number;
  /** Y 좌표 (Canvas 기준) */
  y: number;
  /** 마우스 버튼 눌림 상태 */
  isDrawing: boolean;
}

/**
 * Image Brush 작업 결과
 */
export interface ImageBrushResult {
  /** 원본 이미지 URL */
  originalImage: string;
  /** 마스크 이미지 (Base64) */
  maskImage: string;
  /** 결과 이미지 URL */
  resultImage: string;
  /** 사용된 프롬프트 */
  prompt: string;
  /** 처리 시간 */
  processingTime: number;
  /** 생성 시각 */
  createdAt: Date;
}
</file>

<file path="types/library-modal.ts">
import { LibraryItem } from './video-editor';

/**
 * LibraryModal 설정 인터페이스
 * 모달의 동작 모드와 기능을 정의합니다.
 */
export interface LibraryModalConfig {
  /** 모달 동작 모드 */
  mode: 'selection' | 'view';
  
  /** 선택 모드 설정 */
  selection?: {
    enabled: boolean;
    maxItems: number;
    onSelect: (items: LibraryItem[]) => void;
  };
  
  /** 즐겨찾기 설정 */
  favorites?: {
    enabled: boolean;
    favoriteIds: Set<string>;
    onToggle: (videoId: string) => void;
  };
  
  /** 다운로드 설정 */
  download?: {
    enabled: boolean;
  };
  
  /** 날짜 필터 설정 */
  dateFilter?: {
    enabled: boolean;
  };
  
  /** UI 테마 설정 */
  theme?: {
    primaryColor: string;
    buttonStyle: 'primary' | 'success';
    selectionColor?: string;
  };
}

/**
 * LibraryModalBase Props
 */
export interface LibraryModalBaseProps {
  isOpen: boolean;
  onClose: () => void;
  config: LibraryModalConfig;
}

/**
 * Library 카테고리 타입
 */
export type LibraryCategory = 'clips' | 'projects' | 'uploads';

/**
 * Library 데이터 카운트
 */
export interface LibraryCounts {
  clips: number;
  projects: number;
  uploads: number;
}
</file>

<file path="fix-lambda-permission.sh">
#!/bin/bash

# Lambda 함수에 모든 AWS 서비스가 호출할 수 있도록 권한 추가
echo "Lambda 함수에 권한 추가 중..."

aws lambda add-permission \
  --function-name remotion-render-4-0-332-mem2048mb-disk2048mb-900sec \
  --statement-id AllowAllAWSServices \
  --action lambda:InvokeFunction \
  --principal "*" \
  --region us-east-1

echo "권한 추가 완료!"
echo ""
echo "Lambda 함수 정책 확인:"
aws lambda get-policy \
  --function-name remotion-render-4-0-332-mem2048mb-disk2048mb-900sec \
  --region us-east-1 | jq '.Policy' | jq '.'
</file>

<file path="lambda-invoke-policy.json">
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "AllowLambdaInvoke",
      "Effect": "Allow",
      "Action": [
        "lambda:InvokeFunction",
        "lambda:InvokeAsync",
        "lambda:GetFunction",
        "lambda:GetFunctionConfiguration"
      ],
      "Resource": [
        "arn:aws:lambda:us-east-1:367515020958:function:remotion-render-*",
        "arn:aws:lambda:us-east-1:367515020958:function:voguedrop-render"
      ]
    },
    {
      "Sid": "AllowS3Access",
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject",
        "s3:ListBucket",
        "s3:GetBucketLocation",
        "s3:PutObjectAcl"
      ],
      "Resource": [
        "arn:aws:s3:::remotionlambda-*/*",
        "arn:aws:s3:::remotionlambda-*",
        "arn:aws:s3:::voguedrop-renders/*",
        "arn:aws:s3:::voguedrop-renders"
      ]
    },
    {
      "Sid": "AllowCloudWatchLogs",
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents",
        "logs:DescribeLogStreams"
      ],
      "Resource": [
        "arn:aws:logs:us-east-1:367515020958:*"
      ]
    },
    {
      "Sid": "AllowSTSAssumeRole",
      "Effect": "Allow",
      "Action": [
        "sts:AssumeRole"
      ],
      "Resource": "*",
      "Condition": {
        "StringEquals": {
          "sts:ExternalId": "remotion"
        }
      }
    }
  ]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", "supabase/functions/**/*"]
}
</file>

<file path="vercel-lambda-fix.md">
# Vercel 배포 후 Lambda 권한 에러 해결 가이드

## 🔴 문제 상황
- **로컬 환경**: 정상 작동 ✅
- **Vercel 배포 후**: Lambda 권한 에러 발생 ❌

```
User: arn:aws:sts::367515020958:assumed-role/cloudwatch_logs_events_putter/...
is not authorized to perform: lambda:InvokeFunction
on resource: arn:aws:lambda:us-east-1:367515020958:function:remotion-render-4-0-332-mem2048mb-disk2048mb-900sec
```

## 🎯 해결 방법

### 1. Vercel 환경 변수 확인 및 설정

Vercel 대시보드에서 다음 환경 변수가 정확히 설정되어 있는지 확인:

1. **Vercel 대시보드 접속**
   - https://vercel.com/dashboard
   - 프로젝트 선택 → Settings → Environment Variables

2. **필수 환경 변수 설정**
   ```bash
   # AWS 설정
   AWS_ACCESS_KEY_ID=your-access-key
   AWS_SECRET_ACCESS_KEY=your-secret-key
   AWS_REGION=us-east-1
   
   # Lambda 설정
   LAMBDA_FUNCTION_NAME=remotion-render-4-0-332-mem2048mb-disk2048mb-900sec
   LAMBDA_RENDER_ENDPOINT=direct
   
   # S3 및 Remotion 설정
   AWS_S3_BUCKET_NAME=remotionlambda-useast1-54qz3bnxt2
   REMOTION_SERVE_URL=https://remotionlambda-useast1-54qz3bnxt2.s3.us-east-1.amazonaws.com/sites/voguedrop/index.html
   ```

3. **환경 변수 저장 후 재배포**
   - Save 버튼 클릭
   - Deployments 탭 → 최신 배포 선택 → Redeploy

### 2. AWS IAM 권한 설정

#### 방법 A: AWS 콘솔에서 직접 설정

1. **AWS 콘솔 로그인**
   - https://console.aws.amazon.com/

2. **IAM 사용자 권한 확인**
   - IAM → Users → 사용자 선택
   - Permissions 탭 → Add permissions → Attach policies directly

3. **필요한 정책 추가**
   - `AWSLambda_FullAccess`
   - `AmazonS3FullAccess`
   - 또는 아래 커스텀 정책 생성

#### 방법 B: AWS CLI로 권한 설정

1. **커스텀 정책 생성**
   ```bash
   # lambda-invoke-policy.json 파일이 이미 생성되어 있음
   
   # IAM 정책 생성
   aws iam create-policy \
     --policy-name VogueDropLambdaInvokePolicy \
     --policy-document file://lambda-invoke-policy.json
   ```

2. **정책 ARN 확인**
   ```bash
   # 생성된 정책 ARN 복사 (예: arn:aws:iam::367515020958:policy/VogueDropLambdaInvokePolicy)
   ```

3. **IAM 사용자에 정책 연결**
   ```bash
   # Vercel에서 사용하는 IAM 사용자에 정책 연결
   aws iam attach-user-policy \
     --user-name your-iam-user-name \
     --policy-arn arn:aws:iam::367515020958:policy/VogueDropLambdaInvokePolicy
   ```

### 3. Lambda 함수 권한 확인

```bash
# Lambda 함수 정책 확인
aws lambda get-policy \
  --function-name remotion-render-4-0-332-mem2048mb-disk2048mb-900sec \
  --region us-east-1

# 필요시 권한 추가
aws lambda add-permission \
  --function-name remotion-render-4-0-332-mem2048mb-disk2048mb-900sec \
  --statement-id AllowVercelInvoke \
  --action lambda:InvokeFunction \
  --principal "*" \
  --region us-east-1
```

### 4. Vercel Functions 설정 확인

`vercel.json` 파일 확인/생성:

```json
{
  "functions": {
    "app/api/video/render/route.ts": {
      "maxDuration": 60
    }
  },
  "env": {
    "AWS_LAMBDA_FUNCTION_TIMEOUT": "900"
  }
}
```

### 5. 디버깅을 위한 로그 추가

API route에 임시로 환경 변수 확인 코드 추가:

```typescript
// app/api/video/render/route.ts 상단에 추가
console.log('Environment check:', {
  hasAwsKey: !!process.env.AWS_ACCESS_KEY_ID,
  hasAwsSecret: !!process.env.AWS_SECRET_ACCESS_KEY,
  functionName: process.env.LAMBDA_FUNCTION_NAME,
  region: process.env.AWS_REGION,
  serveUrl: process.env.REMOTION_SERVE_URL?.substring(0, 50) + '...'
});
```

## 🔍 확인 사항 체크리스트

- [ ] Vercel 환경 변수가 모두 설정되어 있는가?
- [ ] AWS Access Key가 올바른가?
- [ ] Lambda 함수 이름이 정확한가?
- [ ] IAM 사용자에 Lambda:InvokeFunction 권한이 있는가?
- [ ] S3 버킷에 접근 권한이 있는가?
- [ ] Vercel 재배포를 했는가?

## 📊 테스트 방법

1. **Vercel Functions 로그 확인**
   ```bash
   vercel logs --follow
   ```

2. **AWS CloudWatch 로그 확인**
   ```bash
   aws logs tail /aws/lambda/remotion-render-4-0-332-mem2048mb-disk2048mb-900sec --follow
   ```

3. **직접 Lambda 테스트**
   ```bash
   aws lambda invoke \
     --function-name remotion-render-4-0-332-mem2048mb-disk2048mb-900sec \
     --payload '{"test": true}' \
     response.json
   ```

## 🆘 추가 도움

문제가 계속되면 다음을 확인:
1. AWS 계정 ID가 367515020958이 맞는지 확인
2. us-east-1 리전이 올바른지 확인
3. Remotion Lambda 함수가 정상적으로 배포되었는지 확인

## 📝 참고사항

- Vercel은 서버리스 환경이므로 AWS Credentials를 환경 변수로 전달해야 함
- Lambda 함수 이름이 Remotion 버전에 따라 달라질 수 있음 (remotion-render-4-0-332-...)
- 권한 변경 후 즉시 적용되지 않을 수 있으므로 몇 분 기다려야 할 수 있음
</file>

<file path="app/api/sound/generate-from-video/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { createServiceClient } from '@/lib/supabase/service';
import { nanoid } from 'nanoid';
import { extractJobIdPrefix } from '@/lib/sound/utils';

interface GenerateFromVideoRequest {
  video_job_id: string;
  duration_seconds?: number;
}

export async function POST(request: NextRequest) {
  const isMockMode = process.env.NEXT_PUBLIC_MOCK_MODE === 'true';
  
  try {
    // 1. 사용자 인증 확인
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }
    
    // 2. 요청 데이터 검증
    const body: GenerateFromVideoRequest = await request.json();
    const { video_job_id, duration_seconds } = body;
    
    if (!video_job_id) {
      return NextResponse.json(
        { error: '비디오를 선택해주세요.' },
        { status: 400 }
      );
    }
    
    const finalDuration = duration_seconds || 8;
    if (finalDuration < 1 || finalDuration > 22) {
      return NextResponse.json(
        { error: '길이는 1초에서 22초 사이여야 합니다.' },
        { status: 400 }
      );
    }
    
    // 3. 서비스 클라이언트로 민감한 정보 조회 (보안: 서버에서만 접근)
    const serviceSupabase = createServiceClient();
    
    console.log('Fetching video generation for job_id:', video_job_id, 'user_id:', user.id);
    
    // video_generations 테이블에서 프롬프트와 효과 정보 조회
    const { data: videoGeneration, error: fetchError } = await serviceSupabase
      .from('video_generations')
      .select('prompt, selected_effects, job_id')
      .eq('job_id', video_job_id)
      .eq('user_id', user.id) // 본인 영상만 조회 가능
      .single();
    
    if (fetchError || !videoGeneration) {
      console.error('Failed to fetch video generation:', {
        error: fetchError,
        job_id: video_job_id,
        user_id: user.id
      });
      return NextResponse.json(
        { error: `비디오 정보를 찾을 수 없습니다. (job_id: ${video_job_id})` },
        { status: 404 }
      );
    }
    
    console.log('Found video generation, prompt length:', videoGeneration.prompt?.length);
    
    // job_id에서 앞 5자리 추출하여 타이틀로 사용
    const titlePrefix = extractJobIdPrefix(video_job_id);
    
    // 4. 실제 비디오 프롬프트를 그대로 음악 생성에 사용 (450자 제한)
    let musicPrompt = videoGeneration.prompt;
    
    // 프롬프트가 450자를 넘으면 트림
    if (musicPrompt.length > 450) {
      // 447자로 자르고 '...' 추가 (총 450자)
      const truncated = musicPrompt.substring(0, 447);
      // 마지막 단어를 자르지 않도록 마지막 공백 위치 찾기
      const lastSpaceIndex = truncated.lastIndexOf(' ');
      
      // 공백이 있고 너무 많이 잘리지 않는다면 공백 위치에서 자르기
      if (lastSpaceIndex > 350) {
        musicPrompt = truncated.substring(0, lastSpaceIndex) + '...';
      } else {
        // 공백이 없거나 너무 많이 잘리면 그냥 447자에서 자르기
        musicPrompt = truncated + '...';
      }
      
      console.log('Trimmed video prompt from', videoGeneration.prompt.length, 'to', musicPrompt.length, 'characters');
    }
    
    // 5. Group ID 생성 (4개의 variation)
    const groupId = `group_${nanoid()}`;
    const jobIds: string[] = [];
    
    // 6. 4개의 variation DB 레코드 생성
    const insertPromises = [];
    for (let i = 1; i <= 4; i++) {
      const jobId = `job_${nanoid()}`;
      jobIds.push(jobId);
      
      insertPromises.push(
        serviceSupabase
          .from('sound_generations')
          .insert({
            job_id: jobId,
            user_id: user.id,
            prompt: musicPrompt, // 변환된 음악 프롬프트 사용 (서버에서만 보관)
            title: `${titlePrefix} - Soundtrack ${i}`, // job_id 앞 5자리로 타이틀 생성
            duration_seconds: finalDuration,
            status: 'pending',
            webhook_status: 'pending',
            generation_group_id: groupId,
            variation_number: i,
            generation_type: 'from_video' // 비디오 기반 생성 타입
          })
          .select('id, job_id, status')
          .single()
      );
    }
    
    const insertResults = await Promise.all(insertPromises);
    
    // 에러 체크
    const failedInserts = insertResults.filter(result => result.error);
    if (failedInserts.length > 0) {
      console.error('Failed to create sound generation records:', failedInserts);
      return NextResponse.json(
        { error: '사운드 생성 요청을 저장하는데 실패했습니다.' },
        { status: 500 }
      );
    }
    
    // 7. Mock 모드 처리
    if (isMockMode) {
      console.log('Mock mode enabled - generating video-based sounds');
      
      // 모든 job을 processing으로 업데이트
      for (const jobId of jobIds) {
        await serviceSupabase
          .from('sound_generations')
          .update({
            status: 'processing',
            fal_request_id: `mock_${jobId}`,
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
      }
      
      // Mock webhook 시뮬레이션
      const webhookBaseUrl = process.env.NEXT_PUBLIC_SITE_URL || 
                            `https://${request.headers.get('host')}`;
      
      jobIds.forEach((jobId, index) => {
        setTimeout(async () => {
          try {
            const webhookUrl = `${webhookBaseUrl}/api/webhooks/fal-ai?jobId=${jobId}&type=sound`;
            await fetch(webhookUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Webhook-Secret': process.env.WEBHOOK_SECRET || 'test-secret'
              },
              body: JSON.stringify({
                request_id: `mock_${jobId}`,
                gateway_request_id: 'mock-gateway-id',
                status: 'OK',
                payload: {
                  audio: {
                    url: `https://v3.fal.media/files/example/mock_video_soundtrack_v${index + 1}.mp3`
                  }
                }
              })
            });
          } catch (error) {
            console.error(`Mock webhook error for job ${jobId}:`, error);
          }
        }, 3000 + (index * 1000));
      });
      
      return NextResponse.json({
        success: true,
        groupId: groupId, // 클라이언트 호환성을 위해 유지
        jobIds,
        status: 'processing',
        message: '비디오 기반 사운드트랙 생성이 시작되었습니다.'
      });
    }
    
    // 8. 실제 fal.ai API 호출
    const endpoint = "fal-ai/elevenlabs/sound-effects";
    const webhookBaseUrl = process.env.NEXT_PUBLIC_SITE_URL || 
                          `https://${request.headers.get('host')}`;
    
    const requestPayload = {
      text: musicPrompt,
      duration_seconds: finalDuration,
      prompt_influence: 0.3
    };
    
    // 4개의 API 호출을 병렬로 실행
    const apiPromises = jobIds.map(async (jobId) => {
      const webhookUrl = `${webhookBaseUrl}/api/webhooks/fal-ai?jobId=${jobId}&type=sound`;
      const queueUrl = `https://queue.fal.run/${endpoint}?fal_webhook=${encodeURIComponent(webhookUrl)}`;
      
      try {
        const response = await fetch(queueUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Key ${process.env.FAL_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestPayload)
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error(`fal.ai API error for job ${jobId}:`, errorData);
          
          await serviceSupabase
            .from('sound_generations')
            .update({
              status: 'failed',
              error_message: errorData.detail || 'fal.ai API 호출 실패',
              updated_at: new Date().toISOString()
            })
            .eq('job_id', jobId);
          
          return { success: false, jobId, error: errorData.detail };
        }
        
        const result = await response.json();
        
        await serviceSupabase
          .from('sound_generations')
          .update({
            fal_request_id: result.request_id,
            status: 'processing',
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        return { success: true, jobId, requestId: result.request_id };
      } catch (error) {
        console.error(`Error calling fal.ai for job ${jobId}:`, error);
        
        await serviceSupabase
          .from('sound_generations')
          .update({
            status: 'failed',
            error_message: 'API 호출 중 오류 발생',
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        return { success: false, jobId, error: 'API 호출 중 오류 발생' };
      }
    });
    
    const apiResults = await Promise.all(apiPromises);
    const successfulJobs = apiResults.filter(r => r.success);
    
    if (successfulJobs.length === 0) {
      return NextResponse.json(
        { error: '모든 사운드 생성 요청이 실패했습니다.' },
        { status: 500 }
      );
    }
    
    // 9. 클라이언트에 응답 (프롬프트 정보 제외)
    return NextResponse.json({
      success: true,
      groupId: groupId, // 클라이언트 호환성을 위해 유지 (실제로는 DB에 저장하지 않음)
      jobIds,
      successfulJobIds: successfulJobs.map(j => j.jobId),
      status: 'processing',
      message: `비디오 기반 ${successfulJobs.length}개의 사운드트랙 생성이 시작되었습니다.`
    });
    
  } catch (error) {
    console.error('Video-based sound generation error:', error);
    
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '서버 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/canvas/_components/CanvasControls.tsx">
import { Wand2, Download, ChevronDown, Loader2, Brush } from "lucide-react"
import { Button } from "@/components/ui/button"
import type { GeneratedVideo } from "@/types/canvas"

interface CanvasControlsProps {
  selectedResolution: string
  selectedSize: string
  onPromptModalOpen?: () => void
  onGenerateClick?: () => void
  canGenerate?: boolean
  selectedDuration?: string
  onDurationChange?: (duration: string) => void
  onDownloadClick?: () => void
  activeVideo?: GeneratedVideo | null
  isDownloading?: boolean
  onImageBrushOpen?: () => void
  hasUploadedImage?: boolean
}

export function CanvasControls({
  onPromptModalOpen,
  onGenerateClick,
  canGenerate = false,
  selectedDuration = "6",
  onDurationChange,
  onDownloadClick,
  activeVideo,
  isDownloading = false,
  onImageBrushOpen,
  hasUploadedImage = false,
}: CanvasControlsProps) {
  return (
    <div className="flex items-center gap-2 bg-surface-secondary p-2 rounded-lg border border-border">
      <Button
        className="flex items-center gap-2 px-4 py-2 bg-primary text-primary-foreground text-sm font-medium rounded-button hover:bg-primary/90 disabled:bg-primary/50 disabled:cursor-not-allowed transition-colors"
        onClick={onGenerateClick || onPromptModalOpen}
        disabled={!canGenerate}
      >
        <Wand2 className="w-4 h-4" />
        <span>Generate</span>
      </Button>

      <div className="relative">
        <select 
          className="appearance-none bg-primary text-primary-foreground text-sm font-medium rounded-button px-4 py-2 pr-8 hover:bg-primary/90 transition-colors cursor-pointer"
          value={selectedDuration}
          onChange={(e) => onDurationChange?.(e.target.value)}
        >
          <option value="6">6s</option>
          <option value="10">10s</option>
        </select>
        <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none">
          <ChevronDown className="w-4 h-4 text-primary-foreground" />
        </div>
      </div>

      <div className="w-px h-6 bg-border"></div>

      <Button
        className="flex items-center gap-2 px-3 h-10 bg-surface-secondary hover:bg-surface-tertiary text-text-secondary hover:text-text-primary rounded-button text-sm transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
        onClick={onImageBrushOpen}
        disabled={!hasUploadedImage}
        variant="ghost"
        title={!hasUploadedImage ? "Upload an image first" : "Edit image with AI brush"}
      >
        <Brush className="w-4 h-4" />
        <span>Image Brush</span>
      </Button>

      <button 
        className="w-10 h-10 flex items-center justify-center text-text-secondary hover:text-text-primary rounded-button disabled:opacity-50 disabled:cursor-not-allowed"
        onClick={onDownloadClick}
        disabled={!activeVideo || isDownloading}
        title={!activeVideo ? "Select a video to download" : "Download video"}
      >
        {isDownloading ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <Download className="w-4 h-4" />
        )}
      </button>
    </div>
  )
}
</file>

<file path="app/canvas/_components/CanvasLayout.tsx">
'use client'

import React from 'react'
import { Header } from '@/components/layout/Header'
import { LeftPanel } from './LeftPanel'
import { Canvas } from './Canvas'
import { CanvasModals } from './CanvasModals'
import { useCanvas, useSlotManager, useVideoGeneration } from '../_context/CanvasContext'
import { useBeforeUnload } from '../_hooks/useBeforeUnload'
import type { GeneratedVideo } from '@/types/canvas'

/**
 * Canvas 페이지의 메인 레이아웃 컴포넌트
 * Context를 활용하여 모든 상태와 로직을 통합 관리
 */
export function CanvasLayout(): React.ReactElement {
  const {
    modals,
    settings,
    favorites,
    effects,
    currentGeneratingImage,
    setCurrentGeneratingImage,
    selectedVideoId,
    setSelectedVideoId,
    isDownloading,
    handleDownload,
  } = useCanvas()

  // 슬롯 관리와 비디오 생성은 직접 사용
  const slotManager = useSlotManager()
  const videoGeneration = useVideoGeneration({
    getCurrentImage: () => currentGeneratingImage,
    selectedEffects: effects.selectedEffects,
    promptText: settings.promptText,
    selectedDuration: settings.selectedDuration,
    slotManager: {
      slotStates: slotManager.slotStates,
      findAvailableSlotForGeneration: slotManager.findAvailableSlotForGeneration,
      setSlotToImage: slotManager.setSlotToImage,
      markSlotGenerating: slotManager.markSlotGenerating,
      placeVideoInSlot: slotManager.placeVideoInSlot,
      resetSlot: slotManager.resetSlot,
    },
    onVideoCompleted: (video: GeneratedVideo) => {
      if (!selectedVideoId) {
        setSelectedVideoId(video.id)
      }
    },
  })

  // 페이지 이탈 방지
  useBeforeUnload(
    videoGeneration.isGenerating,
    'Video generation is in progress. Leaving the page will cancel the generation.'
  )

  // 이벤트 핸들러들
  const handleVideoSelect = (video: GeneratedVideo): void => {
    const placed = slotManager.handleVideoToggle(video, videoGeneration.isSlotGenerating)
    if (!placed) {
      videoGeneration.setGenerationError('생성 중인 작업이 완료되길 기다려주세요.')
      return
    }
    setSelectedVideoId(video.id)
  }

  const handleRemoveContent = (index: number, type: 'image' | 'video'): void => {
    slotManager.handleRemoveContent(index)
    if (index === 0 && type === 'image') {
      setCurrentGeneratingImage(null)
    }
  }

  const handleImageUpload = (imageUrl: string): void => {
    setCurrentGeneratingImage(imageUrl)
    slotManager.handleImageUpload(imageUrl, videoGeneration.isSlotGenerating)
  }

  const handleImageRemove = (): void => {
    const prevImageUrl = currentGeneratingImage
    setCurrentGeneratingImage(null)
    if (prevImageUrl) {
      slotManager.removeImageByUrlIfEmpty(prevImageUrl)
    }
  }

  const handleToggleFavorite = async (videoId: string): Promise<void> => {
    try {
      await favorites.toggleFavorite(videoId)
      slotManager.updateVideoFavoriteFlag(videoId, favorites.isFavorite(videoId))
    } catch (error) {
      // 에러는 useFavoritesManager에서 처리됨
      console.error('Failed to toggle favorite:', error)
    }
  }

  return (
    <div className="min-h-screen flex flex-col bg-background text-foreground">
      <Header
        onLibraryClick={() => modals.openModal('library')}
        activePage="clip"
        onEditClick={() => modals.openModal('projectTitle')}
      />

      <div className="flex flex-1">
        <LeftPanel
          isPrompterOpen={settings.isPrompterOpen}
          onPrompterToggle={() =>
            settings.updateSettings({ isPrompterOpen: !settings.isPrompterOpen })
          }
          promptText={settings.promptText}
          onPromptChange={(text: string) => settings.updateSettings({ promptText: text })}
          uploadedImage={currentGeneratingImage}
          onImageUpload={handleImageUpload}
          onImageRemove={handleImageRemove}
          generationError={videoGeneration.generationError}
          onEffectModalOpen={() => modals.openModal('effect')}
          selectedEffects={effects.selectedEffects}
          onEffectRemove={effects.removeEffect}
        />

        <Canvas
          selectedResolution={settings.selectedResolution}
          selectedSize={settings.selectedSize}
          onPromptModalOpen={() => modals.openModal('prompt')}
          showControls={true}
          slotContents={slotManager.slotContents}
          slotStates={slotManager.slotStates}
          onVideoSelect={handleVideoSelect}
          onGenerateClick={videoGeneration.generateVideo}
          isGenerating={videoGeneration.isGenerating}
          canGenerate={videoGeneration.canGenerate}
          selectedDuration={settings.selectedDuration}
          onDurationChange={(duration: string) =>
            settings.updateSettings({ selectedDuration: duration })
          }
          generatingProgress={videoGeneration.generatingProgress}
          generatingJobIds={videoGeneration.generatingJobIds}
          onRemoveContent={handleRemoveContent}
          onSlotSelect={slotManager.handleSlotSelect}
          selectedSlotIndex={slotManager.selectedSlotIndex}
          activeVideo={slotManager.activeVideo}
          onDownloadClick={handleDownload}
          isDownloading={isDownloading}
          favoriteVideos={favorites.favoriteIds}
          onToggleFavorite={handleToggleFavorite}
          onImageBrushOpen={() => modals.openModal('imageBrush')}
          hasUploadedImage={!!currentGeneratingImage}
        />
      </div>

      <CanvasModals />
    </div>
  )
}
</file>

<file path="app/canvas/_components/ImageBrushModal.tsx">
'use client'

import { useState, useRef, useEffect, useCallback } from 'react'
import Image from 'next/image'
import { X, Brush, Eraser, RotateCcw, Loader2, Sliders, ArrowRight } from 'lucide-react'
import type { ImageBrushModalState, BrushTool, CanvasMouseEvent } from '@/types/image-brush'

interface ImageBrushModalProps {
  isOpen: boolean
  onClose: () => void
  imageUrl: string
  onComplete: (brushedImageUrl: string) => void
}

export function ImageBrushModal({
  isOpen,
  onClose,
  imageUrl,
  onComplete
}: ImageBrushModalProps) {
  // Canvas refs
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const maskCanvasRef = useRef<HTMLCanvasElement>(null)
  const imageRef = useRef<HTMLImageElement | null>(null)
  
  // State
  const [state, setState] = useState<ImageBrushModalState>({
    isOpen,
    isProcessing: false,
    currentTool: 'brush',
    brushSettings: {
      size: 40,
      opacity: 1,
      hardness: 0.8
    },
    prompt: '',
    mode: 'flux',
    progress: 0,
    error: null
  })
  
  const [resultImage, setResultImage] = useState<string | null>(null)
  const [isDrawing, setIsDrawing] = useState(false)
  const [lastPos, setLastPos] = useState<{ x: number; y: number } | null>(null)

  // Load image and initialize canvas
  useEffect(() => {
    if (!isOpen || !imageUrl) return

    const img = new window.Image()
    img.crossOrigin = 'anonymous'
    img.onload = () => {
      imageRef.current = img
      
      // Set canvas size (max 1024px)
      const maxSize = 1024
      let width = img.width
      let height = img.height
      
      if (width > maxSize || height > maxSize) {
        const ratio = Math.min(maxSize / width, maxSize / height)
        width *= ratio
        height *= ratio
      }
      
      
      // Draw image on main canvas
      if (canvasRef.current) {
        const ctx = canvasRef.current.getContext('2d')
        if (ctx) {
          canvasRef.current.width = width
          canvasRef.current.height = height
          ctx.drawImage(img, 0, 0, width, height)
        }
      }
      
      // Initialize mask canvas
      if (maskCanvasRef.current) {
        maskCanvasRef.current.width = width
        maskCanvasRef.current.height = height
        const maskCtx = maskCanvasRef.current.getContext('2d')
        if (maskCtx) {
          maskCtx.fillStyle = 'black'
          maskCtx.fillRect(0, 0, width, height)
        }
      }
    }
    
    img.src = imageUrl
  }, [isOpen, imageUrl])

  // 마우스 위치 계산
  const getMousePos = useCallback((e: React.MouseEvent<HTMLCanvasElement>): CanvasMouseEvent => {
    const canvas = canvasRef.current
    if (!canvas) return { x: 0, y: 0, isDrawing: false }
    
    const rect = canvas.getBoundingClientRect()
    const scaleX = canvas.width / rect.width
    const scaleY = canvas.height / rect.height
    
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY,
      isDrawing
    }
  }, [isDrawing])

  // 미리보기 업데이트 (마스크 오버레이)
  const updatePreview = useCallback(() => {
    const canvas = canvasRef.current
    const maskCanvas = maskCanvasRef.current
    if (!canvas || !maskCanvas || !imageRef.current) return
    
    const ctx = canvas.getContext('2d')
    if (!ctx) return
    
    // Redraw original image
    ctx.clearRect(0, 0, canvas.width, canvas.height)
    ctx.drawImage(imageRef.current, 0, 0, canvas.width, canvas.height)
    
    // 마스크 오버레이 (반투명 빨간색)
    ctx.globalAlpha = 0.5
    ctx.fillStyle = 'red'
    
    const maskCtx = maskCanvas.getContext('2d')
    if (maskCtx) {
      const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height)
      const tempCanvas = document.createElement('canvas')
      tempCanvas.width = maskCanvas.width
      tempCanvas.height = maskCanvas.height
      const tempCtx = tempCanvas.getContext('2d')
      
      if (tempCtx) {
        const overlayData = tempCtx.createImageData(maskCanvas.width, maskCanvas.height)
        
        for (let i = 0; i < maskData.data.length; i += 4) {
          if (maskData.data[i] > 0) { // 흰색 부분만
            overlayData.data[i] = 255     // R
            overlayData.data[i + 1] = 0   // G
            overlayData.data[i + 2] = 0   // B
            overlayData.data[i + 3] = 128 // A (반투명)
          }
        }
        
        tempCtx.putImageData(overlayData, 0, 0)
        ctx.drawImage(tempCanvas, 0, 0)
      }
    }
    
    ctx.globalAlpha = 1
  }, [])

  // 마스크 그리기 - 연속적인 선 그리기
  const drawMask = useCallback((x: number, y: number, isNewStroke: boolean = false) => {
    const maskCanvas = maskCanvasRef.current
    if (!maskCanvas) return
    
    const ctx = maskCanvas.getContext('2d')
    if (!ctx) return
    
    const { size } = state.brushSettings
    
    // Set stroke properties based on tool
    if (state.currentTool === 'brush') {
      ctx.globalCompositeOperation = 'source-over'
      ctx.strokeStyle = 'white'
      ctx.fillStyle = 'white'
    } else if (state.currentTool === 'eraser') {
      ctx.globalCompositeOperation = 'source-over'
      ctx.strokeStyle = 'black'
      ctx.fillStyle = 'black'
    }
    
    ctx.lineWidth = size
    ctx.lineCap = 'round'
    ctx.lineJoin = 'round'
    
    // Draw continuous line from last position
    if (lastPos && !isNewStroke) {
      ctx.beginPath()
      ctx.moveTo(lastPos.x, lastPos.y)
      ctx.lineTo(x, y)
      ctx.stroke()
    }
    
    // Always draw a circle at current position for better coverage
    ctx.beginPath()
    ctx.arc(x, y, size / 2, 0, Math.PI * 2)
    ctx.fill()
    
    // Update last position
    setLastPos({ x, y })
    
    // 미리보기 업데이트
    updatePreview()
  }, [state.brushSettings, state.currentTool, lastPos, updatePreview])

  // 마우스 이벤트 핸들러
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    setIsDrawing(true)
    const pos = getMousePos(e)
    drawMask(pos.x, pos.y, true) // isNewStroke = true
  }

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing) return
    const pos = getMousePos(e)
    drawMask(pos.x, pos.y, false) // isNewStroke = false
  }

  const handleMouseUp = () => {
    setIsDrawing(false)
    setLastPos(null) // Reset last position when stroke ends
  }

  const handleMouseLeave = () => {
    setIsDrawing(false)
    setLastPos(null) // Reset last position when mouse leaves
  }

  // Tool selection
  const selectTool = (tool: BrushTool) => {
    if (tool === 'clear') {
      // Reset mask
      const maskCanvas = maskCanvasRef.current
      if (maskCanvas) {
        const ctx = maskCanvas.getContext('2d')
        if (ctx) {
          ctx.fillStyle = 'black'
          ctx.fillRect(0, 0, maskCanvas.width, maskCanvas.height)
          updatePreview()
        }
      }
    } else {
      setState(prev => ({ ...prev, currentTool: tool }))
    }
  }

  // Change brush size
  const handleBrushSizeChange = (value: number[]) => {
    setState(prev => ({
      ...prev,
      brushSettings: {
        ...prev.brushSettings,
        size: value[0]
      }
    }))
  }

  // AI processing request
  const handleGenerate = async () => {
    if (!state.prompt.trim()) {
      setState(prev => ({ ...prev, error: 'Please enter a prompt.' }))
      return
    }

    setState(prev => ({ 
      ...prev, 
      isProcessing: true, 
      error: null,
      progress: 0 
    }))

    try {
      // Convert image and mask to Base64
      const canvas = canvasRef.current
      const maskCanvas = maskCanvasRef.current
      
      if (!canvas || !maskCanvas || !imageRef.current) {
        throw new Error('Failed to initialize canvas.')
      }

      // Original image Base64 (without mask overlay)
      const tempCanvas = document.createElement('canvas')
      tempCanvas.width = canvas.width
      tempCanvas.height = canvas.height
      const tempCtx = tempCanvas.getContext('2d')
      if (tempCtx) {
        tempCtx.drawImage(imageRef.current, 0, 0, canvas.width, canvas.height)
      }
      const imageBase64 = tempCanvas.toDataURL('image/png')

      // 마스크 Base64
      const maskBase64 = maskCanvas.toDataURL('image/png')

      // 진행률 시뮬레이션
      const progressInterval = setInterval(() => {
        setState(prev => ({ 
          ...prev, 
          progress: Math.min(prev.progress + 10, 90) 
        }))
      }, 500)

      // API 호출
      const response = await fetch('/api/canvas/image-brush', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          image: imageBase64,
          mask: maskBase64,
          prompt: state.prompt,
          mode: state.mode
        })
      })

      if (!response.ok) {
        clearInterval(progressInterval)
        const errorData = await response.json()
        throw new Error(errorData.error || 'An error occurred during processing.')
      }

      const result = await response.json()
      clearInterval(progressInterval)
      
      // Debug: Log all returned URLs
      console.log('Image Brush Result:', {
        resultUrl: result.imageUrl,
        originalUrl: result.originalImageUrl,
        maskUrl: result.maskImageUrl
      })
      
      setState(prev => ({ 
        ...prev, 
        progress: 100,
        isProcessing: false 
      }))
      
      // Update result image
      if (result.imageUrl) {
        setResultImage(result.imageUrl)
      }

    } catch (error) {
      console.error('Image brush error:', error)
      setState(prev => ({ 
        ...prev, 
        error: error instanceof Error ? error.message : 'An error occurred during processing.',
        isProcessing: false,
        progress: 0
      }))
    }
  }
  
  // Apply result and close modal
  const handleApplyResult = () => {
    if (resultImage) {
      onComplete(resultImage)
      onClose()
    }
  }
  
  // Reset everything
  const handleReset = () => {
    setResultImage(null)
    setState(prev => ({ ...prev, progress: 0, error: null }))
    // Reset mask
    const maskCanvas = maskCanvasRef.current
    if (maskCanvas) {
      const ctx = maskCanvas.getContext('2d')
      if (ctx) {
        ctx.fillStyle = 'black'
        ctx.fillRect(0, 0, maskCanvas.width, maskCanvas.height)
        updatePreview()
      }
    }
  }

  if (!isOpen) return null

  return (
    <>
      <style jsx>{`
        input[type="range"]::-webkit-slider-thumb {
          appearance: none;
          width: 16px;
          height: 16px;
          background: #38f47cf9;
          cursor: pointer;
          border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
          width: 16px;
          height: 16px;
          background: #38f47cf9;
          cursor: pointer;
          border: none;
          border-radius: 50%;
        }
      `}</style>
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
      {/* Main Modal with integrated Before/After */}
      <div className="bg-gray-800 rounded-xl w-full max-w-[1400px] max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-6 pb-2 border-b border-gray-700">
          <h2 className="text-xl font-medium text-white">Image Brush - AI Image Editor</h2>
          <button
            className="text-gray-400 hover:text-gray-300 transition-colors"
            onClick={onClose}
            disabled={state.isProcessing}
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Main Content */}
        <div className="flex flex-1 overflow-hidden">
          {/* Before/After Container */}
          <div className="flex-1 flex">
            {/* Before Section */}
            <div className="flex-1 flex flex-col border-r border-gray-700">
              <div className="px-4 py-2 bg-gray-700 border-b border-gray-600">
                <h3 className="text-sm font-medium text-gray-300 text-center">Before (Edit Mask)</h3>
              </div>
              <div className="flex-1 p-4 flex items-center justify-center bg-gray-900/50">
                <div className="relative">
                  <canvas
                    ref={canvasRef}
                    className="border border-gray-600 rounded cursor-crosshair"
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseLeave}
                    style={{
                      maxWidth: '100%',
                      maxHeight: 'calc(90vh - 250px)'
                    }}
                  />
                  <canvas
                    ref={maskCanvasRef}
                    className="hidden"
                  />
                </div>
              </div>
            </div>

            {/* Arrow Indicator */}
            <div className="flex items-center justify-center px-2 bg-gray-900/30">
              <ArrowRight className="w-6 h-6 text-gray-400" />
            </div>

            {/* After Section */}
            <div className="flex-1 flex flex-col">
              <div className="px-4 py-2 bg-gray-700 border-b border-gray-600">
                <h3 className="text-sm font-medium text-gray-300 text-center">After (AI Result)</h3>
              </div>
              <div className="flex-1 p-4 flex items-center justify-center bg-gray-900/50">
                {resultImage ? (
                  <div className="relative max-w-full max-h-[calc(90vh-250px)]">
                    <Image 
                      src={resultImage} 
                      alt="AI Generated Result" 
                      width={512}
                      height={512}
                      className="object-contain rounded border border-gray-600"
                      style={{
                        maxWidth: '100%',
                        maxHeight: 'calc(90vh - 250px)',
                        width: 'auto',
                        height: 'auto'
                      }}
                      unoptimized // AI 생성 이미지는 최적화 스킵
                    />
                  </div>
                ) : (
                  <div className="flex flex-col items-center justify-center text-gray-400">
                    <div className="w-32 h-32 rounded-lg border-2 border-dashed border-gray-600 flex items-center justify-center mb-3">
                      <Loader2 className="w-8 h-8 opacity-50" />
                    </div>
                    <p className="text-sm">AI result will appear here</p>
                    <p className="text-xs mt-1 opacity-70">Draw mask and generate to see results</p>
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Tools Panel */}
          <div className="w-80 p-4 bg-gray-800 border-l border-gray-700 flex flex-col gap-4">
            {/* Tool Selection */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-gray-400">Tools</h3>
              <div className="flex gap-2">
                <button
                  className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center ${
                    state.currentTool === 'brush' 
                      ? 'text-black hover:opacity-90' 
                      : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                  }`}
                  style={state.currentTool === 'brush' ? { backgroundColor: '#38f47cf9' } : {}}
                  onClick={() => selectTool('brush')}
                  disabled={state.isProcessing}
                >
                  <Brush className="w-4 h-4 mr-1" />
                  Brush
                </button>
                <button
                  className={`px-3 py-1.5 rounded-lg text-sm font-medium transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center ${
                    state.currentTool === 'eraser' 
                      ? 'text-black hover:opacity-90' 
                      : 'bg-gray-700 text-gray-300 hover:bg-gray-600'
                  }`}
                  style={state.currentTool === 'eraser' ? { backgroundColor: '#38f47cf9' } : {}}
                  onClick={() => selectTool('eraser')}
                  disabled={state.isProcessing}
                >
                  <Eraser className="w-4 h-4 mr-1" />
                  Eraser
                </button>
                <button
                  className="px-3 py-1.5 bg-gray-700 text-gray-300 rounded-lg text-sm font-medium hover:bg-gray-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
                  onClick={() => selectTool('clear')}
                  disabled={state.isProcessing}
                >
                  <RotateCcw className="w-4 h-4 mr-1" />
                  Clear
                </button>
              </div>
            </div>

            {/* Brush Settings */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-gray-400">Brush Size</h3>
              <div className="flex items-center gap-3">
                <Sliders className="w-4 h-4 text-gray-400" />
                <input
                  type="range"
                  value={state.brushSettings.size}
                  onChange={(e) => handleBrushSizeChange([parseInt(e.target.value)])}
                  min={5}
                  max={100}
                  step={5}
                  disabled={state.isProcessing}
                  className="flex-1 h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer slider"
                  style={{
                    background: `linear-gradient(to right, #38f47cf9 0%, #38f47cf9 ${((state.brushSettings.size - 5) / 95) * 100}%, #374151 ${((state.brushSettings.size - 5) / 95) * 100}%, #374151 100%)`
                  }}
                />
                <span className="text-sm text-gray-400 w-10 text-right">
                  {state.brushSettings.size}px
                </span>
              </div>
            </div>

            {/* Prompt Input */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-gray-400">Prompt</h3>
              <textarea
                className="w-full h-24 px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-sm resize-none focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-colors"
                placeholder="Describe how to modify the masked area.\nExample: expand t-shirt part, add floral pattern"
                value={state.prompt}
                onChange={(e) => setState(prev => ({ ...prev, prompt: e.target.value }))}
                disabled={state.isProcessing}
              />
            </div>

            {/* Mode Selection */}
            <div className="space-y-2">
              <h3 className="text-sm font-medium text-gray-400">Processing Mode</h3>
              <select
                className="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white text-sm focus:outline-none focus:ring-2 focus:ring-emerald-500 transition-colors"
                value={state.mode}
                onChange={(e) => setState(prev => ({ ...prev, mode: e.target.value as 'flux' | 'i2i' }))}
                disabled={state.isProcessing}
              >
                <option value="flux">FLUX Fill (Prompt-based)</option>
                <option value="i2i">I2I Transform (Style Transfer)</option>
              </select>
            </div>

            {/* Error Message */}
            {state.error && (
              <div className="p-3 bg-red-900/20 border border-red-800 rounded-lg text-sm text-red-400">
                {state.error}
              </div>
            )}

            {/* Progress Bar */}
            {state.isProcessing && (
              <div className="space-y-2">
                <div className="flex items-center justify-between text-sm text-gray-400">
                  <span>Processing...</span>
                  <span>{state.progress}%</span>
                </div>
                <div className="w-full bg-gray-700 rounded-full h-2">
                  <div 
                    className="h-2 rounded-full transition-all duration-300"
                    style={{ width: `${state.progress}%`, backgroundColor: '#38f47cf9' }}
                  />
                </div>
              </div>
            )}

            {/* Action Buttons */}
            <div className="space-y-2">
              {/* Generate Button */}
              <button
                className="w-full px-4 py-2.5 text-black rounded-lg font-medium hover:opacity-90 transition-all disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center"
                style={{ backgroundColor: '#38f47cf9' }}
                onClick={handleGenerate}
                disabled={state.isProcessing || !state.prompt.trim()}
              >
                {state.isProcessing ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Processing...
                  </>
                ) : (
                  'Generate with AI'
                )}
              </button>

              {/* Apply/Reset Buttons (show when result exists) */}
              {resultImage && (
                <div className="flex gap-2">
                  <button
                    onClick={handleApplyResult}
                    className="flex-1 px-4 py-2 text-black rounded-lg font-medium hover:opacity-90 transition-all"
                    style={{ backgroundColor: '#38f47cf9' }}
                  >
                    Apply Result
                  </button>
                  <button
                    onClick={handleReset}
                    className="flex-1 px-4 py-2 bg-gray-700 text-gray-300 rounded-lg font-medium hover:bg-gray-600 transition-colors"
                  >
                    Reset
                  </button>
                </div>
              )}
            </div>

            {/* Instructions */}
            <div className="text-xs text-gray-500 space-y-1 mt-auto">
              <p>• Mark the areas to modify with the brush</p>
              <p>• Red areas indicate where AI will make changes</p>
              <p>• English prompts provide more accurate results</p>
            </div>
          </div>
        </div>
      </div>
    </div>
    </>
  )
}
</file>

<file path="app/canvas/_hooks/useModalManager.ts">
'use client'

import { useState, useCallback } from 'react'
import type { ModalName, ModalState, ModalManagerReturn } from '../_types'

const initialModalState: ModalState = {
  library: false,
  effect: false,
  prompt: false,
  camera: false,
  model: false,
  projectTitle: false,
  imageBrush: false,
}

/**
 * Canvas 페이지의 모든 모달 상태를 통합 관리하는 훅
 * 6개의 개별 useState를 하나로 통합하여 Props drilling 해결
 */
export function useModalManager(): ModalManagerReturn {
  const [modals, setModals] = useState<ModalState>(initialModalState)

  const toggleModal = useCallback((modalName: ModalName): void => {
    setModals((prev) => ({
      ...prev,
      [modalName]: !prev[modalName],
    }))
  }, [])

  const openModal = useCallback((modalName: ModalName): void => {
    setModals((prev) => ({
      ...prev,
      [modalName]: true,
    }))
  }, [])

  const closeModal = useCallback((modalName: ModalName): void => {
    setModals((prev) => ({
      ...prev,
      [modalName]: false,
    }))
  }, [])

  const closeAllModals = useCallback((): void => {
    setModals(initialModalState)
  }, [])

  return {
    modals,
    toggleModal,
    openModal,
    closeModal,
    closeAllModals,
  }
}
</file>

<file path="app/canvas/_types/index.ts">
// Canvas 페이지 전용 타입 정의
import type { GeneratedVideo } from '@/types/canvas'
import type { EffectTemplateWithMedia } from '@/types/database'

// 모달 관련 타입
export type ModalName = 'library' | 'effect' | 'prompt' | 'camera' | 'model' | 'projectTitle' | 'imageBrush'

export interface ModalState {
  library: boolean
  effect: boolean
  prompt: boolean
  camera: boolean
  model: boolean
  projectTitle: boolean
  imageBrush: boolean
}

export interface ModalManagerReturn {
  modals: ModalState
  toggleModal: (modalName: ModalName) => void
  openModal: (modalName: ModalName) => void
  closeModal: (modalName: ModalName) => void
  closeAllModals: () => void
}

// Canvas 설정 타입
export interface CanvasSettings {
  promptText: string
  negativePrompt: string
  selectedResolution: string
  selectedSize: string
  selectedModelId: string
  selectedDuration: string
  isPrompterOpen: boolean
}

export interface CanvasSettingsReturn extends CanvasSettings {
  updateSettings: (settings: Partial<CanvasSettings>) => void
  resetSettings: () => void
}

// 즐겨찾기 관련 타입
export interface FavoritesManagerReturn {
  favoriteIds: Set<string>
  isLoading: boolean
  error: string | null
  toggleFavorite: (videoId: string) => Promise<void>
  isFavorite: (videoId: string) => boolean
  refreshFavorites: () => Promise<void>
}

// 효과 관리 타입
export interface EffectsManagerReturn {
  selectedEffects: EffectTemplateWithMedia[]
  canAddMore: boolean
  addEffect: (effect: EffectTemplateWithMedia) => void
  removeEffect: (effectId: number) => void
  toggleEffect: (effect: EffectTemplateWithMedia) => void
  clearEffects: () => void
  maxEffects: number
}

// Canvas Context 타입
export interface CanvasContextValue {
  // 모달 관리
  modals: ModalManagerReturn
  
  // 설정 관리
  settings: CanvasSettingsReturn
  
  // 즐겨찾기 관리
  favorites: FavoritesManagerReturn
  
  // 효과 관리
  effects: EffectsManagerReturn
  
  // 현재 생성 이미지
  currentGeneratingImage: string | null
  setCurrentGeneratingImage: (imageUrl: string | null) => void
  
  // 선택된 비디오
  selectedVideoId: string | null
  setSelectedVideoId: (videoId: string | null) => void
  
  // 다운로드 상태
  isDownloading: boolean
  handleDownload: () => Promise<void>
}

// API 응답 타입
export interface FavoritesApiResponse {
  favoriteIds?: string[]
  error?: string
}

export interface ToggleFavoriteRequest {
  videoId: string
  isFavorite: boolean
}

export interface ToggleFavoriteResponse {
  success: boolean
  error?: string
}

// 이벤트 핸들러 타입
export type ImageUploadHandler = (imageUrl: string) => void
export type VideoSelectHandler = (video: GeneratedVideo) => void
export type EffectSelectHandler = (effect: EffectTemplateWithMedia) => void
export type SlotSelectHandler = (index: number) => void
export type ContentRemoveHandler = (index: number, type: 'image' | 'video') => void

// Props 타입 정의 (컴포넌트별)
// Context를 사용하므로 props가 필요없지만, 추후 확장을 위해 타입은 유지
</file>

<file path="app/video-editor/_components/BufferingSpinner.tsx">
import React from 'react';
import { AbsoluteFill } from 'remotion';

interface BufferingSpinnerProps {
  message?: string;
  submessage?: string;
  isOverlay?: boolean;
  overlayOpacity?: 'light' | 'medium' | 'dark';
}

export function BufferingSpinner({ 
  message = 'Loading', 
  submessage = 'Please wait...',
  isOverlay = false,
  overlayOpacity = 'dark'
}: BufferingSpinnerProps) {
  if (isOverlay) {
    // Overlay style with configurable opacity
    const bgClass = overlayOpacity === 'light' ? 'bg-black/30' : 
                    overlayOpacity === 'medium' ? 'bg-black/50' : 
                    'bg-black';
    
    return (
      <div className={`absolute inset-0 flex items-center justify-center ${bgClass} rounded-lg z-50`}>
        <div className="flex flex-col items-center gap-4">
          <div className="relative">
            <div className="w-16 h-16 border-4 border-gray-600 rounded-full"></div>
            <div className="absolute top-0 left-0 w-16 h-16 border-4 border-[#38f47cf9] rounded-full border-t-transparent animate-spin"></div>
          </div>
          <p className="text-white text-lg font-medium">{message}</p>
          <p className="text-gray-400 text-sm">{submessage}</p>
        </div>
      </div>
    );
  }

  // Remotion Player의 renderPoster에서 사용할 스타일
  return (
    <AbsoluteFill style={{ 
      justifyContent: 'center', 
      alignItems: 'center',
      backgroundColor: 'black'
    }}>
      <div className="flex flex-col items-center gap-4">
        <div className="relative">
          <div className="w-16 h-16 border-4 border-gray-600 rounded-full"></div>
          <div className="absolute top-0 left-0 w-16 h-16 border-4 border-[#38f47cf9] rounded-full border-t-transparent animate-spin"></div>
        </div>
        <p className="text-white text-lg font-medium">{message}</p>
        {submessage && <p className="text-gray-400 text-sm">{submessage}</p>}
      </div>
    </AbsoluteFill>
  );
}
</file>

<file path="app/video-editor/_components/ContextMenu.tsx">
'use client';

import { useEffect, useRef } from 'react';
import { createPortal } from 'react-dom';

interface ContextMenuItem {
  label: string;
  icon: string;
  action: () => void;
  disabled?: boolean;
}

interface ContextMenuProps {
  x: number;
  y: number;
  items: ContextMenuItem[];
  onClose: () => void;
}

export default function ContextMenu({ x, y, items, onClose }: ContextMenuProps) {
  const menuRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        onClose();
      }
    };

    const handleEscape = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    document.addEventListener('keydown', handleEscape);

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscape);
    };
  }, [onClose]);

  // 메뉴가 화면 밖으로 나가지 않도록 위치 조정
  useEffect(() => {
    if (menuRef.current) {
      const rect = menuRef.current.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      let adjustedX = x;
      let adjustedY = y;

      // 우측 경계 체크
      if (rect.right > viewportWidth) {
        adjustedX = x - rect.width;
      }

      // 하단 경계 체크
      if (rect.bottom > viewportHeight) {
        adjustedY = y - rect.height;
      }

      // 좌측 경계 체크
      if (adjustedX < 0) {
        adjustedX = 0;
      }

      // 상단 경계 체크
      if (adjustedY < 0) {
        adjustedY = 0;
      }

      menuRef.current.style.left = `${adjustedX}px`;
      menuRef.current.style.top = `${adjustedY}px`;
    }
  }, [x, y]);

  const menuContent = (
    <div
      ref={menuRef}
      className="fixed bg-gray-800 border border-gray-700 rounded-lg shadow-xl py-2 z-[9999] min-w-[180px]"
      style={{ left: x, top: y }}
    >
      {items.map((item, index) => (
        <button
          key={index}
          onClick={() => {
            if (!item.disabled) {
              item.action();
              onClose();
            }
          }}
          disabled={item.disabled}
          className={`
            w-full px-4 py-2 text-left flex items-center gap-3 transition-colors
            ${item.disabled 
              ? 'text-gray-500 cursor-not-allowed' 
              : 'text-gray-200 hover:bg-gray-700 hover:text-white'
            }
          `}
        >
          <i className={`${item.icon} text-sm`}></i>
          <span className="text-sm">{item.label}</span>
        </button>
      ))}
    </div>
  );

  // Portal을 사용하여 document.body에 직접 렌더링
  if (typeof document !== 'undefined') {
    return createPortal(menuContent, document.body);
  }

  return null;
}
</file>

<file path="app/video-editor/_components/VideoClipSelector.tsx">
'use client';

import Image from 'next/image';
import { VideoClip } from '@/types/video-editor';

interface VideoClipSelectorProps {
  clips: VideoClip[];
  selectedClipId: string | null;
  onSelectClip: (clipId: string | null) => void;
  disabled?: boolean;
}

export function VideoClipSelector({ 
  clips, 
  selectedClipId, 
  onSelectClip,
  disabled = false 
}: VideoClipSelectorProps) {
  
  // Helper function to check if a clip is AI-generated
  const isAIGeneratedClip = (clip: VideoClip): boolean => {
    // Check sourceType first (most reliable)
    if (clip.sourceType) {
      return clip.sourceType === 'clip';
    }
    
    // Fallback: check if clip ID contains job_id pattern
    return clip.id.includes('job_') || clip.id.startsWith('clip-job_');
  };
  
  // Filter clips to separate selectable and non-selectable
  const selectableClips = clips.filter(isAIGeneratedClip);
  const hasNonAIClips = clips.some(clip => !isAIGeneratedClip(clip));
  
  if (clips.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        <i className="ri-video-line text-3xl mb-2 opacity-50"></i>
        <p className="text-sm">No video clips in timeline</p>
        <p className="text-xs text-gray-600 mt-1">
          Add video clips to your timeline first
        </p>
      </div>
    );
  }
  
  if (selectableClips.length === 0) {
    return (
      <div className="text-center py-8 text-gray-500">
        <i className="ri-information-line text-3xl mb-2 opacity-50"></i>
        <p className="text-sm">No AI-generated clips available</p>
        <p className="text-xs text-gray-600 mt-1">
          Only AI-generated clips can be used to create matching soundtracks.
        </p>
        <p className="text-xs text-gray-600 mt-1">
          Add clips from the Canvas AI Studio to generate music.
        </p>
      </div>
    );
  }
  
  return (
    <div className="space-y-3">
      <div className="text-sm text-gray-400 mb-2">
        Select an AI-generated video clip to create matching soundtrack:
        {hasNonAIClips && (
          <span className="text-xs text-gray-500 ml-2">
            (Non-AI clips cannot generate music)
          </span>
        )}
      </div>
      
      <div className="grid grid-cols-3 gap-3 max-h-[300px] overflow-y-auto">
        {clips.map((clip, index) => {
          const isAIClip = isAIGeneratedClip(clip);
          const isSelectable = isAIClip && !disabled;
          
          return (
            <div
              key={clip.id}
              onClick={() => isSelectable && onSelectClip(clip.id)}
              className={`
                relative cursor-pointer rounded-lg overflow-hidden
                border-2 transition-all
                ${selectedClipId === clip.id 
                  ? 'border-primary ring-2 ring-primary/30' 
                  : isAIClip 
                    ? 'border-gray-700 hover:border-gray-600'
                    : 'border-gray-800 cursor-not-allowed'
                }
                ${!isSelectable ? 'opacity-60' : ''}
              `}
            >
              {/* 썸네일 */}
              <div className="aspect-video bg-gray-800 relative">
                {clip.thumbnail ? (
                  <Image
                    src={clip.thumbnail}
                    alt={`Clip ${index + 1}`}
                    fill
                    className="object-cover"
                    sizes="(max-width: 800px) 33vw"
                  />
                ) : (
                  <div className="w-full h-full flex items-center justify-center">
                    <i className="ri-video-fill text-2xl text-gray-600"></i>
                  </div>
                )}
                
                {/* Non-AI clip overlay */}
                {!isAIClip && (
                  <div className="absolute inset-0 bg-gray-900/80 flex items-center justify-center backdrop-blur-sm">
                    <div className="text-center px-2">
                      <i className="ri-lock-line text-xl text-gray-400 mb-1"></i>
                      <div className="text-xs text-gray-400 font-medium">
                        Not AI clip
                      </div>
                      <div className="text-xs text-gray-500 mt-0.5">
                        Only AI clips
                      </div>
                    </div>
                  </div>
                )}
                
                {/* 선택 인디케이터 */}
                {selectedClipId === clip.id && isAIClip && (
                  <div className="absolute inset-0 bg-primary/20 flex items-center justify-center">
                    <div className="bg-primary rounded-full p-1">
                      <i className="ri-check-line text-black text-lg"></i>
                    </div>
                  </div>
                )}
              </div>
              
              {/* 클립 정보 */}
              <div className="p-2 bg-gray-900">
                <div className="flex items-center gap-1">
                  {/* Source type badge */}
                  <div className={`
                    inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium
                    ${isAIClip 
                      ? 'bg-primary/20 text-primary' 
                      : clip.sourceType === 'upload'
                        ? 'bg-blue-500/20 text-blue-400'
                        : 'bg-purple-500/20 text-purple-400'
                    }
                  `}>
                    {isAIClip ? 'AI' : clip.sourceType === 'upload' ? 'Upload' : 'Project'}
                  </div>
                  <div className="text-xs font-medium truncate flex-1">
                    {clip.title || `Clip ${index + 1}`}
                  </div>
                </div>
                <div className="text-xs text-gray-500 mt-0.5">
                  {formatDuration(clip.duration)}
                </div>
              </div>
              
              {/* 라디오 버튼 (AI 클립만 표시) */}
              {isAIClip && (
                <div className="absolute top-2 right-2">
                  <input
                    type="radio"
                    name="video-clip-selection"
                    checked={selectedClipId === clip.id}
                    onChange={() => onSelectClip(clip.id)}
                    disabled={!isSelectable}
                    className="w-4 h-4 text-primary bg-gray-700 border-gray-600 focus:ring-primary focus:ring-offset-0"
                    onClick={(e) => e.stopPropagation()}
                  />
                </div>
              )}
            </div>
          );
        })}
      </div>
      
      {selectedClipId && (
        <div className="mt-3 p-3 bg-gray-700/50 rounded-lg">
          <div className="flex items-center gap-2 text-sm">
            <i className="ri-information-line text-primary"></i>
            <span className="text-gray-300">
              AI soundtrack will be generated based on the selected video&apos;s visual content
            </span>
          </div>
        </div>
      )}
    </div>
  );
}

// 시간 포맷 헬퍼 함수
function formatDuration(durationInPixels: number, pixelsPerSecond: number = 40): string {
  const seconds = Math.floor(durationInPixels / pixelsPerSecond);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  
  if (minutes > 0) {
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }
  return `${seconds}s`;
}
</file>

<file path="app/video-editor/_constants/index.ts">
// 화면 비율 설정
export const ASPECT_RATIOS = {
  MOBILE: {
    value: '9:16' as const,
    width: 360,
    height: 640,
    displayRatio: '9 / 16',
    label: 'Mobile (9:16)'  },
  SQUARE: {
    value: '1:1' as const,
    width: 640,
    height: 640,
    displayRatio: '1 / 1',
    label: 'Square (1:1)'  },
  WIDE: {
    value: '16:9' as const,
    width: 640,
    height: 360,
    displayRatio: '16 / 9',
    label: 'Wide (16:9)'
  }
} as const;

export type AspectRatioType = keyof typeof ASPECT_RATIOS;
export type AspectRatioValue = typeof ASPECT_RATIOS[AspectRatioType]['value'];

// 타임라인 설정
export const TIMELINE_CONFIG = {
  DEFAULT_HEIGHT: 300,
  MIN_HEIGHT: 150,
  MAX_HEIGHT: 300,
  PIXELS_PER_SECOND: 40,
  FPS: 30
} as const;

// 캐러셀 설정
export const CAROUSEL_CONFIG = {
  ITEM_WIDTH: 350,
  ITEM_HEIGHT: 400,
  ITEM_GAP: 20
} as const;

// 스타일 설정
export const STYLES = {
  PRIMARY_COLOR: '#38f47cf9',
  BORDER_COLOR: '#ef4444',
  BACKGROUND_COLOR: '#111'
} as const;
</file>

<file path="app/video-editor/_context/HistoryContext.tsx">
'use client';

import { createContext, useContext, useState, useCallback, useMemo, ReactNode } from 'react';
import { VideoClip, TextClip, SoundClip } from '@/types/video-editor';
import { useClips } from './ClipContext';

// 히스토리 상태 타입 (page.tsx에서 그대로)
interface HistoryState {
  timelineClips: VideoClip[];
  textClips: TextClip[];
  soundClips: SoundClip[];
}

interface HistoryContextType {
  // 히스토리 상태
  history: HistoryState[];
  historyIndex: number;
  canUndo: boolean;
  canRedo: boolean;
  
  // 히스토리 액션
  saveToHistory: () => void;
  handleUndo: () => void;
  handleRedo: () => void;
}

const HistoryContext = createContext<HistoryContextType | undefined>(undefined);

const MAX_HISTORY_SIZE = 50;

export function HistoryProvider({ children }: { children: ReactNode }) {
  // 히스토리 관리 (page.tsx에서 그대로)
  const [history, setHistory] = useState<HistoryState[]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);
  
  // ClipContext에서 클립 상태 가져오기
  const { 
    timelineClips, 
    textClips, 
    soundClips,
    setTimelineClips,
    setTextClips,
    setSoundClips,
  } = useClips();
  
  // 히스토리에 현재 상태 저장 (page.tsx의 saveToHistory 그대로)
  const saveToHistory = useCallback(() => {
    const newState: HistoryState = {
      timelineClips: [...timelineClips],
      textClips: [...textClips],
      soundClips: [...soundClips]
    };
    
    // 현재 인덱스가 히스토리 끝이 아닌 경우 (Undo 후 새 작업)
    // 현재 위치의 상태와 비교하여 다른 경우에만 저장
    if (historyIndex >= 0 && historyIndex < history.length) {
      const currentState = history[historyIndex];
      const isSameState = 
        JSON.stringify(currentState.timelineClips) === JSON.stringify(timelineClips) &&
        JSON.stringify(currentState.textClips) === JSON.stringify(textClips) &&
        JSON.stringify(currentState.soundClips) === JSON.stringify(soundClips);
      
      if (isSameState) {
        return; // 동일한 상태면 저장하지 않음
      }
    }
    
    // 현재 인덱스 이후의 히스토리 제거 (새로운 분기 생성)
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(newState);
    
    // 최대 50개 히스토리 유지
    if (newHistory.length > MAX_HISTORY_SIZE) {
      newHistory.shift();
    } else {
      setHistoryIndex(historyIndex + 1);
    }
    
    setHistory(newHistory);
  }, [history, historyIndex, timelineClips, textClips, soundClips]);
  
  // Undo 기능 (page.tsx의 handleUndo 그대로)
  const handleUndo = useCallback(() => {
    if (historyIndex > 0) {
      const previousState = history[historyIndex - 1];
      setTimelineClips(previousState.timelineClips);
      setTextClips(previousState.textClips);
      setSoundClips(previousState.soundClips);
      setHistoryIndex(historyIndex - 1);
    }
  }, [history, historyIndex, setTimelineClips, setTextClips, setSoundClips]);
  
  // Redo 기능 (page.tsx의 handleRedo 그대로)
  const handleRedo = useCallback(() => {
    if (historyIndex < history.length - 1) {
      const nextState = history[historyIndex + 1];
      setTimelineClips(nextState.timelineClips);
      setTextClips(nextState.textClips);
      setSoundClips(nextState.soundClips);
      setHistoryIndex(historyIndex + 1);
    }
  }, [history, historyIndex, setTimelineClips, setTextClips, setSoundClips]);
  
  // Undo/Redo 가능 여부
  const canUndo = useMemo(() => historyIndex > 0, [historyIndex]);
  const canRedo = useMemo(() => historyIndex < history.length - 1, [historyIndex, history.length]);
  
  // Context value를 useMemo로 최적화
  const value = useMemo(() => ({
    history,
    historyIndex,
    canUndo,
    canRedo,
    saveToHistory,
    handleUndo,
    handleRedo,
  }), [history, historyIndex, canUndo, canRedo, saveToHistory, handleUndo, handleRedo]);
  
  return (
    <HistoryContext.Provider value={value}>
      {children}
    </HistoryContext.Provider>
  );
}

export function useHistory() {
  const context = useContext(HistoryContext);
  if (!context) {
    throw new Error('useHistory must be used within HistoryProvider');
  }
  return context;
}
</file>

<file path="app/video-editor/_context/PlaybackContext.tsx">
'use client';

import { createContext, useContext, useState, useCallback, useRef, useMemo, ReactNode, useEffect } from 'react';
import { PlayerRef } from '@remotion/player';
import { useClips } from './ClipContext';
import { calculateTimelineDuration } from '../_utils/timeline-helpers';

interface PlaybackContextType {
  // 재생 상태
  isPlaying: boolean;
  currentTime: number;
  totalDuration: number;
  playerRef: React.MutableRefObject<PlayerRef | null>;
  prevFrameRef: React.MutableRefObject<number>;
  
  // 재생 제어 함수
  handlePlayPause: () => void;
  handleSeek: (time: number) => void;
  setIsPlaying: React.Dispatch<React.SetStateAction<boolean>>;
  setCurrentTime: React.Dispatch<React.SetStateAction<number>>;
}

const PlaybackContext = createContext<PlaybackContextType | undefined>(undefined);

const PIXELS_PER_SECOND = 40;

export function PlaybackProvider({ children }: { children: ReactNode }) {
  // 재생 상태 관리 (page.tsx에서 그대로)
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [totalDuration, setTotalDuration] = useState(0);
  const playerRef = useRef<PlayerRef | null>(null);
  const prevFrameRef = useRef<number>(0);
  // 마지막으로 seek한 프레임을 저장하여 중복 업데이트 방지
  const lastSeekFrameRef = useRef<number>(-1);
  
  // isPlaying을 ref로도 저장하여 useCallback 의존성 문제 해결
  const isPlayingRef = useRef(isPlaying);
  useEffect(() => {
    isPlayingRef.current = isPlaying;
  }, [isPlaying]);
  
  // ClipContext에서 클립 정보 가져오기
  const { timelineClips, textClips, soundClips } = useClips();
  
  // 재생/일시정지 토글 (page.tsx의 handlePlayPause 그대로)
  const handlePlayPause = useCallback(() => {
    if (playerRef.current) {
      if (isPlaying) {
        playerRef.current.pause();
      } else {
        // 총 길이 계산
        const videoEnd = timelineClips.length > 0 
          ? Math.max(...timelineClips.map(c => (c.position || 0) + c.duration))
          : 0;
        const textEnd = textClips.length > 0
          ? Math.max(...textClips.map(c => (c.position || 0) + c.duration))
          : 0;
        const soundEnd = soundClips.length > 0
          ? Math.max(...soundClips.map(c => (c.position || 0) + c.duration))
          : 0;
        
        const totalPx = Math.max(videoEnd, textEnd, soundEnd);
        const totalSeconds = totalPx / PIXELS_PER_SECOND;
        
        // 현재 위치가 끝이면 처음부터 재생
        if (currentTime >= totalSeconds - 0.1) {
          playerRef.current.seekTo(0);
          setCurrentTime(0);
        }
        
        playerRef.current.play();
      }
    }
    setIsPlaying(!isPlaying);
  }, [isPlaying, currentTime, timelineClips, textClips, soundClips]);
  
  // Seek 함수 - 재생 중일 때도 재생 상태 유지
  const handleSeek = useCallback((time: number) => {
    // 음수 방지 및 프레임 단위로 중복 호출 차단
    const clampedTime = Math.max(0, time);
    const targetFrame = Math.round(clampedTime * 30); // 30fps 기준

    // 동일 프레임으로의 반복 seek는 무시 (무한 업데이트 방지)
    if (lastSeekFrameRef.current === targetFrame) {
      return;
    }
    lastSeekFrameRef.current = targetFrame;

    setCurrentTime(prev_time => {
      // 같은 프레임(≈1/30초) 이내 변화면 상태 업데이트 생략
      if (Math.abs(prev_time - clampedTime) < 1 / 30) {
        return prev_time;
      }
      return clampedTime;
    });

    if (playerRef.current) {
      playerRef.current.seekTo(targetFrame);

      // ref를 사용하여 현재 재생 상태 확인 (의존성 없이)
      if (isPlayingRef.current) {
        // seekTo 후 약간의 딜레이를 주고 재생
        setTimeout(() => {
          if (playerRef.current && isPlayingRef.current) {
            playerRef.current.play();
          }
        }, 10);
      }
    }
  }, []);
  
  // Player 상태 폴링으로 시간 업데이트 및 재생 완료 감지 (page.tsx에서 그대로)
  useEffect(() => {
    if (!isPlaying || !playerRef.current) {
      prevFrameRef.current = 0;
      return;
    }
    
    // 총 프레임 계산
    const videoEnd = timelineClips.length > 0 
      ? Math.max(...timelineClips.map(c => (c.position || 0) + c.duration))
      : 0;
    const textEnd = textClips.length > 0
      ? Math.max(...textClips.map(c => (c.position || 0) + c.duration))
      : 0;
    const soundEnd = soundClips.length > 0
      ? Math.max(...soundClips.map(c => (c.position || 0) + c.duration))
      : 0;
    
    const totalPx = Math.max(videoEnd, textEnd, soundEnd);
    const totalSeconds = totalPx / 40; // 40px = 1초
    const totalFrames = Math.max(30, Math.round(totalSeconds * 30)); // 30fps
    
    const interval = setInterval(() => {
      if (playerRef.current) {
        const frame = playerRef.current.getCurrentFrame();
        const time = frame / 30; // 30fps 기준
        
        // Player가 끝에서 자동으로 0으로 리셋된 경우 감지
        if (prevFrameRef.current > totalFrames - 5 && frame < 10) {
          setIsPlaying(false);
          setCurrentTime(totalSeconds); // 끝 위치에 유지
          if (playerRef.current) {
            playerRef.current.pause();
          }
          prevFrameRef.current = 0;
          return;
        }
        
        // 재생이 완전히 끝에 도달한 경우
        if (frame >= totalFrames - 1) {
          setIsPlaying(false);
          setCurrentTime(totalSeconds); // 끝 위치에 유지
          if (playerRef.current) {
            playerRef.current.pause();
          }
          prevFrameRef.current = 0;
          return;
        }
        
        // 정상 재생 중
        prevFrameRef.current = frame;
        setCurrentTime(time);
      }
    }, 100); // 100ms마다 업데이트
    
    return () => clearInterval(interval);
  }, [isPlaying, timelineClips, textClips, soundClips]);
  
  // 전체 Duration 계산
  useEffect(() => {
    const duration = calculateTimelineDuration(
      timelineClips,
      textClips,
      soundClips,
      PIXELS_PER_SECOND
    );
    setTotalDuration(duration);
  }, [timelineClips, textClips, soundClips]);
  
  // Context value를 useMemo로 최적화
  const value = useMemo(() => ({
    isPlaying,
    currentTime,
    totalDuration,
    playerRef,
    prevFrameRef,
    handlePlayPause,
    handleSeek,
    setIsPlaying,
    setCurrentTime,
  }), [isPlaying, currentTime, totalDuration, handlePlayPause, handleSeek]);
  
  return (
    <PlaybackContext.Provider value={value}>
      {children}
    </PlaybackContext.Provider>
  );
}

export function usePlayback() {
  const context = useContext(PlaybackContext);
  if (!context) {
    throw new Error('usePlayback must be used within PlaybackProvider');
  }
  return context;
}
</file>

<file path="app/video-editor/_context/Providers.tsx">
'use client';

import { ReactNode, useEffect } from 'react';
import { ClipProvider } from './ClipContext';
import { PlaybackProvider } from './PlaybackContext';
import { HistoryProvider } from './HistoryContext';
import { ProjectProvider } from './ProjectContext';
import { useClips as useClipsContext } from './ClipContext';
import { useHistory as useHistoryContext } from './HistoryContext';

interface VideoEditorProvidersProps {
  children: ReactNode;
}

// ClipProvider와 HistoryProvider를 연결하는 중간 컴포넌트
function HistoryConnector({ children }: { children: ReactNode }) {
  const { saveToHistory } = useHistoryContext();
  const { setSaveToHistoryCallback } = useClipsContext();
  
  // ClipContext에 saveToHistory 콜백 연결
  useEffect(() => {
    if (setSaveToHistoryCallback) {
      setSaveToHistoryCallback(() => saveToHistory);
    }
  }, [saveToHistory, setSaveToHistoryCallback]);
  
  // 초기 히스토리 저장 (최초 1회)
  useEffect(() => {
    // 컴포넌트 마운트 시 현재 상태를 초기 히스토리로 저장
    saveToHistory();
  }, []); // eslint-disable-line react-hooks/exhaustive-deps
  
  return <>{children}</>;
}

/**
 * 모든 Video Editor Context를 통합하는 Provider
 * ClipProvider가 자체 상태를 관리하고, HistoryProvider가 이를 사용
 */
export function VideoEditorProviders({ children }: VideoEditorProvidersProps) {
  return (
    <ProjectProvider>
      <ClipProvider>
        <HistoryProvider>
          <PlaybackProvider>
            <HistoryConnector>
              {children}
            </HistoryConnector>
          </PlaybackProvider>
        </HistoryProvider>
      </ClipProvider>
    </ProjectProvider>
  );
}

// Context export for convenience
export { useClips } from './ClipContext';
export { usePlayback } from './PlaybackContext';
export { useHistory } from './HistoryContext';
export { useProject } from './ProjectContext';
</file>

<file path="app/video-editor/_hooks/useVideoPreloader.ts">
import { useEffect, useState } from 'react';

interface PreloadStatus {
  [url: string]: {
    loading: boolean;
    loaded: boolean;
    error: Error | null;
  };
}

export function useVideoPreloader(videoUrls: (string | undefined)[]) {
  const [preloadStatus, setPreloadStatus] = useState<PreloadStatus>({});

  useEffect(() => {
    const validUrls = videoUrls.filter((url): url is string => !!url);
    
    // 비디오가 없으면 종료
    if (validUrls.length === 0) {
      setPreloadStatus({});
      return;
    }
    
    // 각 URL에 대해 초기 상태 설정 (이미 로드된 것은 건드리지 않음)
    validUrls.forEach(url => {
      setPreloadStatus(prev => {
        if (prev[url]?.loaded) {
          return prev; // 이미 로드된 경우 변경 없음
        }
        return {
          ...prev,
          [url]: prev[url] || { loading: true, loaded: false, error: null }
        };
      });
    });

    const videoElements: HTMLVideoElement[] = [];

    // 각 비디오 프리로드
    validUrls.forEach(url => {
      // 이미 로드되었으면 스킵
      if (preloadStatus[url]?.loaded) {
        return;
      }

      const video = document.createElement('video');
      video.preload = 'auto';
      video.crossOrigin = 'anonymous';
      
      // 로드 성공 핸들러
      const handleCanPlay = () => {
        setPreloadStatus(prev => ({
          ...prev,
          [url]: { loading: false, loaded: true, error: null }
        }));
      };

      // 에러 핸들러
      const handleError = () => {
        console.error(`Failed to preload video: ${url}`);
        setPreloadStatus(prev => ({
          ...prev,
          [url]: { 
            loading: false, 
            loaded: false, 
            error: new Error(`Failed to load: ${url}`) 
          }
        }));
      };

      // 이벤트 리스너 추가
      video.addEventListener('canplay', handleCanPlay);
      video.addEventListener('error', handleError);
      
      // 비디오 소스 설정 (프리로딩 시작)
      video.src = url;
      videoElements.push(video);
    });

    // Cleanup 함수
    return () => {
      videoElements.forEach(video => {
        video.src = '';
        video.load();
      });
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [JSON.stringify(videoUrls)]); // URL 배열이 변경될 때만 재실행

  // 통계 계산
  const loadingCount = Object.values(preloadStatus).filter(s => s.loading).length;
  const loadedCount = Object.values(preloadStatus).filter(s => s.loaded).length;
  const totalCount = videoUrls.filter(url => !!url).length;
  const allLoaded = totalCount > 0 && loadedCount === totalCount;

  return {
    preloadStatus,
    allLoaded,
    loadingCount,
    loadedCount,
    totalCount
  };
}
</file>

<file path="components/modals/library/components/LibraryUpload.tsx">
'use client';

import { useState } from 'react';
import { Upload, Loader2 } from 'lucide-react';
import { UserUploadedVideo } from '@/types/video-editor';
import { extractVideoMetadata, extractVideoThumbnail } from '@/app/video-editor/_utils/video-metadata';
import { uploadVideo } from '@/lib/api/upload';

interface LibraryUploadProps {
  onUploadComplete: (video: UserUploadedVideo) => void;
}

export function LibraryUpload({ onUploadComplete }: LibraryUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    // 파일 크기 체크 (50MB for Edge Function)
    const MAX_SIZE = 50 * 1024 * 1024;
    if (file.size > MAX_SIZE) {
      setError(`File size exceeds 50MB limit (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
      setTimeout(() => setError(null), 5000);
      return;
    }
    
    setIsUploading(true);
    setUploadProgress(0);
    setError(null);
    
    try {
      // 비디오 메타데이터 추출
      setUploadProgress(10);
      let metadata;
      try {
        metadata = await extractVideoMetadata(file);
        console.log('Extracted video metadata:', metadata);
      } catch (metadataError) {
        console.warn('Failed to extract video metadata:', metadataError);
        metadata = null;
      }
      
      // 썸네일 추출
      setUploadProgress(20);
      let thumbnailBlob: Blob | null = null;
      try {
        thumbnailBlob = await extractVideoThumbnail(file);
        console.log('Extracted thumbnail:', thumbnailBlob);
      } catch (thumbnailError) {
        console.warn('Failed to extract thumbnail:', thumbnailError);
      }
      
      // Convert thumbnail blob to File if exists
      const thumbnailFile = thumbnailBlob 
        ? new File([thumbnailBlob], 'thumbnail.jpg', { type: 'image/jpeg' })
        : null;
      
      // Use Edge Function for upload
      const result = await uploadVideo({
        file,
        thumbnail: thumbnailFile,
        metadata: metadata ? {
          duration: metadata.duration,
          aspectRatio: metadata.aspectRatio,
          width: metadata.width,
          height: metadata.height
        } : undefined,
        onProgress: (progress) => {
          // Map progress from upload function (10-90) to UI progress (30-90)
          const mappedProgress = 30 + (progress * 0.6);
          setUploadProgress(Math.round(mappedProgress));
        }
      });
      
      if (!result.success) {
        throw new Error(result.error || 'Upload failed');
      }
      
      setUploadProgress(100);
      
      // Notify parent component
      if (result.video) {
        onUploadComplete(result.video);
      }
      
      // Reset after success
      setTimeout(() => {
        setUploadProgress(0);
        setIsUploading(false);
      }, 500);
      
      // Reset file input
      event.target.value = '';
      
    } catch (err) {
      console.error('Upload error:', err);
      setError(err instanceof Error ? err.message : 'Failed to upload video');
      setIsUploading(false);
      setUploadProgress(0);
    }
  };

  const inputId = `library-video-upload-${Date.now()}`;

  return (
    <>
      <button
        onClick={() => document.getElementById(inputId)?.click()}
        disabled={isUploading}
        className="w-full py-3 rounded-lg transition-colors flex items-center justify-center gap-2 text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed bg-[#38f47cf9] text-black hover:bg-[#38f47cf9]/80"
      >
        {isUploading ? (
          <>
            <Loader2 className="w-4 h-4 animate-spin" />
            <span>Uploading... {uploadProgress}%</span>
          </>
        ) : (
          <>
            <Upload className="w-4 h-4" />
            <span>Upload Video</span>
          </>
        )}
      </button>
      
      {isUploading && (
        <div className="mt-2">
          <div className="w-full bg-gray-700 rounded-full h-2">
            <div 
              className="bg-[#38f47cf9] h-2 rounded-full transition-all duration-300"
              style={{ 
                width: `${uploadProgress}%`
              }}
            />
          </div>
        </div>
      )}
      
      {error && (
        <div className="mt-2 p-2 bg-red-500/20 rounded text-xs text-red-400">
          {error}
        </div>
      )}
      
      <input
        id={inputId}
        type="file"
        accept="video/mp4,video/webm,video/quicktime,video/x-msvideo"
        onChange={handleFileUpload}
        className="hidden"
        disabled={isUploading}
      />
      
      <p className="text-xs text-gray-500 mt-2 text-center">
        Max file size: 20MB
      </p>
    </>
  );
}
</file>

<file path="constants/text-editor.ts">
// 텍스트 에디터와 Remotion 렌더링 간 일관성을 위한 공통 상수

// 텍스트 스타일 기본값
export const TEXT_DEFAULTS = {
  fontSize: 48, // 기본 폰트 크기 (px) - 호환성을 위해 유지
  fontSizeRatio: 0.044, // 컨테이너 너비의 4.4% (1080px에서 48px)
  fontFamily: 'sans-serif',
  fontWeight: 700, // 숫자로 통일 (bold = 700)
  color: 'white',
  maxWidthRatio: 0.8, // 컨테이너 너비의 80%
} as const;

// 텍스트 박스 패딩 (배경색이 있을 때만 적용)
export const TEXT_PADDING = {
  horizontal: 30, // 좌우 패딩 (px) - 호환성을 위해 유지
  vertical: 20,   // 상하 패딩 (px) - 호환성을 위해 유지
  horizontalRatio: 0.028, // 컨테이너 너비의 2.8% (1080px에서 30px)
  verticalRatio: 0.010,   // 컨테이너 높이의 1% (1920px에서 20px)
} as const;

// 위치 프리셋 값 (퍼센트)
export const TEXT_POSITION_PRESETS = {
  vertical: {
    top: 15,
    middle: 50,
    bottom: 85,
  },
  horizontal: {
    left: 10,
    center: 50,
    right: 90,
  },
} as const;

// 애니메이션 설정
export const TEXT_ANIMATION = {
  borderRadius: 8, // 텍스트 박스 모서리 둥글기 (px)
  lineHeight: 1.2,
} as const;

// 타임라인 설정
export const TIMELINE_CONFIG = {
  pixelsPerSecond: 40, // 40px = 1초
  fps: 30,             // 초당 프레임 수
} as const;

// 픽셀을 프레임으로 변환
export const pxToFrames = (px: number): number => {
  const seconds = px / TIMELINE_CONFIG.pixelsPerSecond;
  return Math.round(seconds * TIMELINE_CONFIG.fps);
};

// 프레임을 픽셀로 변환
export const framesToPx = (frames: number): number => {
  const seconds = frames / TIMELINE_CONFIG.fps;
  return Math.round(seconds * TIMELINE_CONFIG.pixelsPerSecond);
};

// 폰트 크기 프리셋 (비율 기반)
export const FONT_SIZE_PRESETS = {
  small: {
    label: 'Small',
    ratio: 0.033, // 컨테이너 너비의 3.3% (1080px에서 36px)
  },
  medium: {
    label: 'Medium',
    ratio: 0.044, // 컨테이너 너비의 4.4% (1080px에서 48px)
  },
  large: {
    label: 'Large',
    ratio: 0.066, // 컨테이너 너비의 6.6% (1080px에서 72px)
  },
  xlarge: {
    label: 'Extra Large',
    ratio: 0.088, // 컨테이너 너비의 8.8% (1080px에서 96px)
  },
} as const;

// 비율을 실제 픽셀로 변환
export const ratioToPixels = (ratio: number, containerSize: number): number => {
  return Math.round(ratio * containerSize);
};

// 픽셀을 비율로 변환
export const pixelsToRatio = (pixels: number, containerSize: number): number => {
  return pixels / containerSize;
};
</file>

<file path="docs/features/image_brush.md">
PROMPT FLUX FILL API (BFL)
프롬프트를 같이 보내주셔야합니다.
마스크 부분을 흰색으로 해주시면 됩니다.


import base64
import json
import time
from openai import OpenAI
import requests
import random
from io import BytesIO
from PIL import Image
import concurrent.futures
from datetime import datetime

# API 키 설정
BFL_TOKEN = ''

# FLUX API 엔드포인트
FLUX_URL = "https://api.us1.bfl.ai/v1/flux-pro-1.0-fill"
RESULT_URL = "https://api.us1.bfl.ai/v1/get_result"

# 이미지 경로
input_path = "input.png"
mask_path = "mask.png"


def save_image(result_data, filename):
    if not result_data:
        print(f"저장할 이미지 데이터가 없습니다: {filename}")
        return False

    # API 응답 구조에 따라 이미지 URL 추출
    image_url = result_data.get('sample')
    if not image_url:
        image_url = result_data.get('url') or result_data.get('image_url')

    if image_url:
        try:
            response = requests.get(image_url)
            response.raise_for_status()

            with open(filename, "wb") as f:
                f.write(response.content)

            return True
        except Exception as e:
            print(f"이미지 저장 실패 ({filename}): {e}")
            return False
    else:
        print(f"이미지 URL을 찾을 수 없습니다: {filename}")
        return False


def pil_to_b64(pil_img):
    buffered = BytesIO()
    pil_img.save(buffered, format="PNG")
    img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")
    return img_str


def generate_single_image(prompt, image_b64, mask_b64, seed):
    """단일 이미지 생성 함수"""

    # API 요청 생성
    gen_query = {
        "prompt": prompt,
        "seed": seed,
        "image": image_b64,
        "mask": mask_b64,
        "guaidance": 80,
        "output_format": "png",
        "safety_tolerance": 2,
        "prompt_upsampling": False,
    }

    headers = {
        "Content-Type": "application/json",
        "X-Key": BFL_TOKEN,
    }

    try:
        response = requests.post(FLUX_URL, headers=headers, json=gen_query)

        if response.status_code == 200:
            response_data = response.json()
            gen_id = response_data.get("id")
            print(f"생성 ID: {gen_id}")

            # 결과 확인
            result_headers = {"X-Key": BFL_TOKEN}
            result_query = {"id": gen_id}

            while True:
                result_response = requests.get(
                    RESULT_URL, headers=result_headers, params=result_query
                )

                if result_response.status_code == 200:
                    result = result_response.json()
                    status = result.get("status")

                    if status == "Ready":
                        print(f"생성 완료!")
                        return result.get("result")
                    elif status == "Pending":
                        print(f"처리 중... 대기 중...")
                        time.sleep(2)
                    elif status in ["Task not found", "Request Moderated", "Content Moderated", "Error"]:
                        print(f"오류 발생: {status}")
                        if status == "Error":
                            print(
                                f"상세 오류: {result.get('error', 'Unknown error')}")
                        return None
                else:
                    print(
                        f"결과 확인 실패: {result_response.status_code}")
                    return None
        else:
            print(f"생성 요청 실패: {response.status_code}")
            print(f"응답: {response.text}")
            return None

    except Exception as e:
        print(f"예외 발생: {e}")
        return None


# 메인 실행 부분
if __name__ == "__main__":

    try:
        # 입력 이미지 로드 및 base64 인코딩
        image = Image.open(input_path)
        image_b64 = pil_to_b64(image)
        mask = Image.open(mask_path)
        mask_b64 = pil_to_b64(mask)

        # 시드 생성
        seed = random.randint(0, 999999)

        # 유저 프롬프트
        prompt = "expand t-shirt part."

        # 이미지 생성
        result_data = generate_single_image(
            prompt,
            image_b64, mask_b64,
            seed
        )

        # 결과 저장
        if result_data:
            filename = "inpaint_flux.png"
            if save_image(result_data, filename):
                print(f"이미지 저장 성공: {filename}")
            else:
                print("이미지 저장 실패")
        else:
            print("이미지 생성 실패")

    except Exception as e:
        print(f"입력 이미지 로드 실패: {e}")

​
I2I RUNPOD FLUX FILL API (BFL)
RUNPOD_API_KEY = ""
RUNPOD_ENDPOINT_ID = "" #
POST RUNPOD_API_URL = f"https://api.runpod.ai/v2/{RUNPOD_ENDPOINT_ID}/run"
​
파라미터
json 파일 내 {seed} 에 해당하는 부분에 랜덤 숫자로 대체 ( 겹치지 않게 )
requrest_data image/mask 명 바뀌지 않게.
mask는 알파값이 0인 부분에 적용됨
request_data = {
    "input": {
        "workflow": json_data, # json 텍스트를 그대로 넣으면 됨.
        "images": [
            {
                "name": "input-1.png", # 인페인트될 옷 혹은 텍스처
                "image": base 64 encoded_string
            },
                        {
                "name": "input-2.png", # 인페인트 당할 레퍼런스
                "image": base 64 encoded_string
            },
                        {
                "name": "mask.png", # 인페인트 당할 레퍼런스 중 인페인트될 부분
                "image": base 64 encoded_string
            }
        ]
    }
}

​
code
import json
import base64
import requests
import time
import os
from datetime import datetime


# RunPod API 설정
RUNPOD_API_KEY = ""  # API 키
RUNPOD_ENDPOINT_ID = ""

if not RUNPOD_API_KEY or not RUNPOD_ENDPOINT_ID:
    print("환경 변수에 RUNPOD_API_KEY와 RUNPOD_ENDPOINT_ID를 설정해주세요.")
    exit(1)

RUNPOD_API_URL = f"https://api.runpod.ai/v2/{RUNPOD_ENDPOINT_ID}/run"
RUNPOD_STATUS_URL = f"https://api.runpod.ai/v2/{RUNPOD_ENDPOINT_ID}/status"


def safe_base64_decode(data):
    """
    안전한 base64 디코딩 함수
    """
    try:
        # base64 문자열에서 data URL prefix 제거 (있는 경우)
        if data.startswith('data:'):
            data = data.split(',', 1)[1]

        # base64 패딩 추가 (필요한 경우)
        missing_padding = len(data) % 4
        if missing_padding:
            data += '=' * (4 - missing_padding)

        return base64.b64decode(data)
    except Exception as e:
        print(f"Base64 디코딩 오류: {e}")
        return None


try:
    # 결과 저장 디렉토리 확인/생성
    os.makedirs("results", exist_ok=True)

    print("워크플로우와 이미지 파일 로드 중...")

    with open('input.json', 'r', encoding='utf-8') as file:
        workflow_data = json.load(file)

    # color.png와 texture.png 파일을 각각 Base64로 인코딩
    print("이미지 파일을 Base64로 인코딩 중...")

    with open('input-1.png', 'rb') as input_1_file:
        input_1_data = input_1_file.read()
        input_1_encoded = base64.b64encode(input_1_data).decode('utf-8')
    with open('input-2.png', 'rb') as input_2_file:
        input_2_data = input_2_file.read()
        input_2_encoded = base64.b64encode(input_2_data).decode('utf-8')

    with open('mask.png', 'rb') as mask_file:
        mask_data = mask_file.read()
        mask_encoded = base64.b64encode(mask_data).decode('utf-8')

    # 요청 데이터 구성
    request_data = {
        "input": {
            "workflow": workflow_data,  # json 텍스트를 그대로 넣으면 됨.
            "images": [
                {
                    "name": "input-1.png",  # 인페인트될 옷 혹은 텍스처
                    "image": input_1_encoded
                },
                {
                    "name": "input-2.png",  # 인페인트 당할 레퍼런스
                    "image": input_2_encoded
                },
                {
                    "name": "mask.png",  # 인페인트 당할 레퍼런스 중 인페인트될 부분
                    # mask 이미지를 base64로 인코딩해서 넣어야 함 (예시로 빈 문자열)
                    "image": mask_encoded
                },
            ]
        }
    }

    # API 요청 헤더
    headers = {
        "Authorization": f"Bearer {RUNPOD_API_KEY}",
        "Content-Type": "application/json"
    }

    print("RunPod API에 요청 전송 중...")
    response = requests.post(
        RUNPOD_API_URL, json=request_data, headers=headers)

    if response.status_code == 200:
        run_data = response.json()
        print(f"API 응답: {run_data}")
        job_id = run_data.get("id")

        if not job_id:
            print("작업 ID를 받지 못했습니다.")
            print(f"전체 응답: {run_data}")
            exit(1)

        print(f"작업이 시작되었습니다. 작업 ID: {job_id}")

        # 작업 상태 확인
        status_url = f"{RUNPOD_STATUS_URL}/{job_id}"

        print("작업 완료를 기다리는 중...")
        max_wait_time = 300  # 최대 5분 대기
        wait_time = 0

        while wait_time < max_wait_time:
            status_response = requests.get(status_url, headers=headers)

            if status_response.status_code == 200:
                status_data = status_response.json()
                status = status_data.get("status")

                print(f"작업 상태: {status} (대기 시간: {wait_time}초)")

                if status == "COMPLETED":
                    print(
                        f"작업 완료! 실행 시간: {status_data.get('executionTime')}ms")

                    # output 데이터 추출
                    output = status_data.get("output", {})
                    print(f"Output 데이터 타입: {type(output)}")
                    print(
                        f"Output 키들: {list(output.keys()) if isinstance(output, dict) else 'dict가 아님'}")

                    if output and isinstance(output, dict):
                        print("결과 이미지 저장 중...")

                        # rp_handler.py의 process_output_images 함수 반환 형식에 맞춰 처리
                        if "images" in output:
                            images_list = output["images"]
                            print(f"찾은 이미지 개수: {len(images_list)}")

                            for i, image_item in enumerate(images_list):
                                if isinstance(image_item, dict):
                                    image_data_b64 = image_item.get("data", "")
                                    original_path = image_item.get(
                                        "path", f"output_{i}.png")

                                    print(f"이미지 {i+1} 처리 중: {original_path}")
                                    print(
                                        f"Base64 데이터 길이: {len(image_data_b64) if image_data_b64 else 0}")

                                    if image_data_b64:
                                        # base64 디코딩
                                        image_data = safe_base64_decode(
                                            image_data_b64)

                                        if image_data:
                                            # 파일명 생성
                                            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

                                            # 원본 경로에서 파일명만 추출
                                            filename_only = os.path.basename(
                                                original_path)
                                            name_part, ext_part = os.path.splitext(
                                                filename_only)
                                            if not ext_part:
                                                ext_part = '.png'

                                            output_filename = f"results/{timestamp}_{name_part}_{i+1}{ext_part}"

                                            # 이미지 파일 저장
                                            with open(output_filename, 'wb') as f:
                                                f.write(image_data)
                                            print(
                                                f"✓ 이미지 저장됨: {output_filename}")
                                        else:
                                            print(f"✗ 이미지 {i+1} 디코딩 실패")
                                    else:
                                        print(f"✗ 이미지 {i+1}에 data가 없습니다.")

                        # 다른 형태의 output 처리 (하위 호환성)
                        else:
                            print("images 키를 찾을 수 없습니다. 다른 형태로 처리 시도...")

                            # 직접 base64 문자열들 찾기
                            saved_count = 0
                            for key, value in output.items():
                                # base64일 가능성이 있는 긴 문자열
                                if isinstance(value, str) and len(value) > 100:
                                    print(f"키 '{key}'에서 이미지 데이터 시도 중...")

                                    image_data = safe_base64_decode(value)
                                    # 최소 이미지 크기 확인
                                    if image_data and len(image_data) > 1000:
                                        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                                        output_filename = f"results/{timestamp}_{key}.png"

                                        with open(output_filename, 'wb') as f:
                                            f.write(image_data)
                                        print(f"✓ 이미지 저장됨: {output_filename}")
                                        saved_count += 1

                            if saved_count == 0:
                                print("저장할 수 있는 이미지를 찾지 못했습니다.")
                                print("Output 내용:")
                                for key, value in output.items():
                                    if isinstance(value, str):
                                        print(f"  {key}: {value[:100]}..." if len(
                                            value) > 100 else f"  {key}: {value}")
                                    else:
                                        print(
                                            f"  {key}: {type(value)} - {value}")

                        print("이미지 처리 완료!")

                    else:
                        print("유효한 output 데이터가 없습니다.")
                        print(f"Status data: {status_data}")

                    break

                elif status == "FAILED":
                    error_msg = status_data.get('error', '알 수 없는 오류')
                    print(f"작업 실패: {error_msg}")
                    print(f"전체 상태 데이터: {status_data}")
                    break

                elif status in ["IN_QUEUE", "IN_PROGRESS"]:
                    print(f"작업 진행 중... ({status})")
                    time.sleep(5)
                    wait_time += 5

                else:
                    print(f"알 수 없는 상태: {status}")
                    time.sleep(5)
                    wait_time += 5

            else:
                print(f"상태 확인 오류: {status_response.status_code}")
                print(f"응답: {status_response.text}")
                time.sleep(10)
                wait_time += 10

        else:
            print(f"최대 대기 시간({max_wait_time}초)을 초과했습니다.")

    else:
        print(f"RunPod API 요청 실패: {response.status_code}")
        print(f"응답 내용: {response.text}")

except FileNotFoundError as e:
    print(f"파일을 찾을 수 없습니다: {e}")
except json.JSONDecodeError as e:
    print(f"JSON 파싱 오류: {e}")
except Exception as e:
    print(f"예상치 못한 오류 발생: {str(e)}")
    import traceback
    traceback.print_exc()


##input json
{
  "10": {
    "inputs": {
      "vae_name": "ae.safetensors"
    },
    "class_type": "VAELoader",
    "_meta": {
      "title": "VAE 로드"
    }
  },
  "11": {
    "inputs": {
      "clip_name1": "clip_l.safetensors",
      "clip_name2": "t5xxl_fp16.safetensors",
      "type": "flux",
      "device": "default"
    },
    "class_type": "DualCLIPLoader",
    "_meta": {
      "title": "이중 CLIP 로드"
    }
  },
  "173": {
    "inputs": {
      "style_model_name": "flux-redux.safetensors"
    },
    "class_type": "StyleModelLoader",
    "_meta": {
      "title": "스타일 모델 로드"
    }
  },
  "422": {
    "inputs": {
      "image": "input-1.png",
      "upload": "image"
    },
    "class_type": "LoadImage",
    "_meta": {
      "title": "이미지 로드"
    }
  },
  "590": {
    "inputs": {
      "image": "input-2.png",
      "upload": "image"
    },
    "class_type": "LoadImage",
    "_meta": {
      "title": "이미지 로드"
    }
  },
  "645": {
    "inputs": {
      "width": 1024,
      "height": 0,
      "interpolation": "lanczos",
      "method": "keep proportion",
      "condition": "always",
      "multiple_of": 0,
      "image": ["590", 0]
    },
    "class_type": "ImageResize+",
    "_meta": {
      "title": "🔧 Image Resize"
    }
  },
  "646": {
    "inputs": {
      "width": ["645", 1],
      "height": ["645", 2],
      "interpolation": "lanczos",
      "method": "fill / crop",
      "condition": "always",
      "multiple_of": 0,
      "image": ["422", 0]
    },
    "class_type": "ImageResize+",
    "_meta": {
      "title": "🔧 Image Resize"
    }
  },
  "649": {
    "inputs": {
      "direction": "right",
      "match_image_size": true,
      "image1": ["646", 0],
      "image2": ["645", 0]
    },
    "class_type": "ImageConcanate",
    "_meta": {
      "title": "Image Concatenate"
    }
  },
  "651": {
    "inputs": {
      "width": ["645", 1],
      "height": ["645", 2],
      "red": 0,
      "green": 0,
      "blue": 0
    },
    "class_type": "Image Blank",
    "_meta": {
      "title": "Image Blank"
    }
  },
  "652": {
    "inputs": {
      "direction": "right",
      "match_image_size": true,
      "image1": ["651", 0],
      "image2": ["653", 0]
    },
    "class_type": "ImageConcanate",
    "_meta": {
      "title": "Image Concatenate"
    }
  },
  "653": {
    "inputs": {
      "mask": ["698", 0]
    },
    "class_type": "MaskToImage",
    "_meta": {
      "title": "마스크를 이미지로 변환"
    }
  },
  "655": {
    "inputs": {
      "channel": "red",
      "image": ["652", 0]
    },
    "class_type": "ImageToMask",
    "_meta": {
      "title": "이미지를 마스크로 변환"
    }
  },
  "658": {
    "inputs": {
      "text": "",
      "clip": ["11", 0]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIP 텍스트 인코딩 (프롬프트)"
    }
  },
  "659": {
    "inputs": {
      "conditioning": ["658", 0]
    },
    "class_type": "ConditioningZeroOut",
    "_meta": {
      "title": "조건 (0으로 출력)"
    }
  },
  "660": {
    "inputs": {
      "noise_mask": true,
      "positive": ["658", 0],
      "negative": ["659", 0],
      "vae": ["10", 0],
      "pixels": ["649", 0],
      "mask": ["679", 0]
    },
    "class_type": "InpaintModelConditioning",
    "_meta": {
      "title": "인페인팅 모델 조건 설정"
    }
  },
  "661": {
    "inputs": {
      "guidance": 30,
      "conditioning": ["667", 0]
    },
    "class_type": "FluxGuidance",
    "_meta": {
      "title": "FLUX 가이드"
    }
  },
  "662": {
    "inputs": {
      "crop": "center",
      "clip_vision": ["663", 0],
      "image": ["422", 0]
    },
    "class_type": "CLIPVisionEncode",
    "_meta": {
      "title": "CLIP_VISION 인코딩"
    }
  },
  "663": {
    "inputs": {
      "clip_name": "sigclip_vision_patch14_384.safetensors"
    },
    "class_type": "CLIPVisionLoader",
    "_meta": {
      "title": "CLIP_VISION 로드"
    }
  },
  "665": {
    "inputs": {
      "samples": ["689", 0],
      "vae": ["10", 0]
    },
    "class_type": "VAEDecode",
    "_meta": {
      "title": "VAE 디코드"
    }
  },
  "667": {
    "inputs": {
      "strength": 1,
      "strength_type": "multiply",
      "conditioning": ["660", 0],
      "style_model": ["173", 0],
      "clip_vision_output": ["662", 0]
    },
    "class_type": "StyleModelApply",
    "_meta": {
      "title": "스타일 모델 적용"
    }
  },
  "669": {
    "inputs": {
      "images": ["680", 0]
    },
    "class_type": "PreviewImage",
    "_meta": {
      "title": "이미지 미리보기"
    }
  },
  "679": {
    "inputs": {
      "expand": 5,
      "incremental_expandrate": 0,
      "tapered_corners": true,
      "flip_input": false,
      "blur_radius": 3,
      "lerp_alpha": 1,
      "decay_factor": 1,
      "fill_holes": false,
      "mask": ["655", 0]
    },
    "class_type": "GrowMaskWithBlur",
    "_meta": {
      "title": "Grow Mask With Blur"
    }
  },
  "680": {
    "inputs": {
      "width": ["645", 1],
      "height": ["645", 2],
      "position": "top-right",
      "x_offset": 0,
      "y_offset": 0,
      "image": ["665", 0]
    },
    "class_type": "ImageCrop+",
    "_meta": {
      "title": "🔧 Image Crop"
    }
  },
  "687": {
    "inputs": {
      "unet_name": "flux_fill_Q8.gguf"
    },
    "class_type": "UnetLoaderGGUF",
    "_meta": {
      "title": "Unet Loader (GGUF)"
    }
  },
  "688": {
    "inputs": {
      "model": ["687", 0]
    },
    "class_type": "DifferentialDiffusion",
    "_meta": {
      "title": "차등 확산"
    }
  },
  "689": {
    "inputs": {
      "seed": {⚠
Error: Parse error on line 284:
...": {      "seed": {seed},      "steps"
----------------------^
Expecting 'STRING', '}', got 'undefined'
seed},
      "steps": 28,
      "cfg": 1,
      "sampler_name": "euler",
      "scheduler": "beta",
      "denoise": 1,
      "model": ["688", 0],
      "positive": ["661", 0],
      "negative": ["660", 1],
      "latent_image": ["660", 2]
    },
    "class_type": "KSampler",
    "_meta": {
      "title": "KSampler"
    }
  },
  "698": {
    "inputs": {
      "image": "mask.png",
      "channel": "alpha",
      "upload": "image"
    },
    "class_type": "LoadImageMask",
    "_meta": {
      "title": "마스크 이미지 로드"
    }
  },
  "699": {
    "inputs": {
      "filename_prefix": "const",
      "images": ["680", 0]
    },
    "class_type": "SaveImage",
    "_meta": {
      "title": "이미지 저장"
    }
  }
}
</file>

<file path="docs/task/task_image_brush.md">
# Image Brush 기능 구현 기획서

## 개요
VogueDrop Canvas에서 업로드한 이미지를 AI로 편집할 수 있는 Image Brush 기능을 구현합니다. 사용자가 이미지의 특정 부분을 마스킹하고 프롬프트를 입력하면, AI가 해당 영역을 새로운 내용으로 채워줍니다.

## 핵심 기술
- **BFL FLUX Fill API**: 프롬프트 기반 이미지 인페인팅
- **RunPod I2I API**: 이미지 간 스타일 변환 (선택사항)
- **Supabase Edge Function**: 이미지 처리 및 AI API 호출
- **HTML Canvas API**: 마스크 그리기 인터페이스

## 기능 요구사항

### 1. 사용자 워크플로우
1. Canvas 페이지에서 이미지 업로드
2. "Image Brush" 버튼 클릭
3. 모달에서 마스크 영역 그리기
4. 프롬프트 입력 (예: "expand t-shirt part")
5. Generate 버튼 클릭
6. AI 처리 결과 확인 및 적용

### 2. 주요 기능
- **마스크 도구**
  - Brush: 마스크 영역 그리기
  - Eraser: 마스크 영역 지우기
  - Clear: 전체 마스크 초기화
  - 브러시 크기 조절 (5px ~ 100px)

- **AI 처리**
  - FLUX Fill: 마스크 영역을 프롬프트에 따라 재생성
  - I2I 변환: 이미지 스타일 변환 (선택사항)
  - 처리 진행률 표시
  - 실패 시 재시도 옵션

- **결과 관리**
  - 원본 이미지 보존
  - 편집된 이미지 저장
  - Canvas slot에 자동 적용
  - 히스토리 관리

## 기술 구현 상세

### 1. 프론트엔드 구조

#### 1.1 UI 컴포넌트 수정
```typescript
// app/canvas/_components/CanvasControls.tsx
// Resolution 버튼을 Image Brush 버튼으로 변경
<Button
  onClick={onImageBrushOpen}
  disabled={!uploadedImage}
  className="flex items-center gap-2"
>
  <Brush className="w-4 h-4" />
  <span>Image Brush</span>
</Button>
```

#### 1.2 Image Brush 모달 컴포넌트
```typescript
// app/canvas/_components/ImageBrushModal.tsx
interface ImageBrushModalProps {
  isOpen: boolean;
  onClose: () => void;
  imageUrl: string;
  onComplete: (brushedImageUrl: string) => void;
}

// 주요 상태
- canvasRef: HTMLCanvasElement 참조
- maskCanvas: 마스크 레이어
- brushSize: 브러시 크기
- currentTool: 'brush' | 'eraser'
- prompt: 사용자 입력 프롬프트
- isProcessing: 처리 중 상태
```

#### 1.3 Canvas 그리기 로직
```typescript
// 마스크 그리기 함수
const drawMask = (x: number, y: number) => {
  const ctx = maskCanvas.getContext('2d');
  ctx.globalCompositeOperation = currentTool === 'brush' 
    ? 'source-over' 
    : 'destination-out';
  ctx.fillStyle = 'white';
  ctx.beginPath();
  ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2);
  ctx.fill();
};

// 마스크를 이미지로 변환
const getMaskImage = (): string => {
  return maskCanvas.toDataURL('image/png');
};
```

### 2. 백엔드 구조

#### 2.1 Supabase Edge Function
```typescript
// supabase/functions/image-brush/index.ts
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.52.1';

interface ImageBrushRequest {
  image: string;      // Base64 인코딩된 원본 이미지
  mask: string;       // Base64 인코딩된 마스크 이미지
  prompt: string;     // 사용자 프롬프트
  mode: 'flux' | 'i2i';  // 처리 모드
  userId: string;
}

serve(async (req) => {
  // 1. 인증 확인
  // 2. 요청 데이터 파싱
  // 3. AI API 호출 (BFL 또는 RunPod)
  // 4. 결과 이미지 Supabase Storage 저장
  // 5. 응답 반환
});
```

#### 2.2 BFL FLUX Fill API 통합
```typescript
const callFluxFillAPI = async (
  image: string, 
  mask: string, 
  prompt: string
) => {
  const BFL_TOKEN = Deno.env.get('BFL_TOKEN');
  const FLUX_URL = "https://api.us1.bfl.ai/v1/flux-pro-1.0-fill";
  
  const requestData = {
    prompt: prompt,
    seed: Math.floor(Math.random() * 999999),
    image: image,
    mask: mask,
    guidance: 80,
    output_format: "png",
    safety_tolerance: 2,
    prompt_upsampling: false,
  };
  
  const response = await fetch(FLUX_URL, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Key': BFL_TOKEN,
    },
    body: JSON.stringify(requestData),
  });
  
  // 결과 폴링 및 이미지 다운로드
  return await pollForResult(response.json().id);
};
```

#### 2.3 RunPod I2I API 통합 (선택사항)
```typescript
const callRunPodAPI = async (
  input1: string,  // 인페인트될 텍스처
  input2: string,  // 레퍼런스 이미지
  mask: string     // 마스크
) => {
  const RUNPOD_API_KEY = Deno.env.get('RUNPOD_API_KEY');
  const RUNPOD_ENDPOINT_ID = Deno.env.get('RUNPOD_ENDPOINT_ID');
  
  const requestData = {
    input: {
      workflow: loadWorkflowJson(),
      images: [
        { name: "input-1.png", image: input1 },
        { name: "input-2.png", image: input2 },
        { name: "mask.png", image: mask }
      ]
    }
  };
  
  // RunPod API 호출 및 결과 폴링
};
```

### 3. API Route
```typescript
// app/api/canvas/image-brush/route.ts
export async function POST(request: NextRequest) {
  try {
    // 1. 인증 확인
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    // 2. Edge Function 호출
    const response = await fetch(
      `${process.env.NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL}/image-brush`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${session.access_token}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          image,
          mask,
          prompt,
          mode,
          userId: user.id,
        }),
      }
    );
    
    // 3. 응답 처리
    const result = await response.json();
    return NextResponse.json(result);
  } catch (error) {
    return NextResponse.json(
      { error: '처리 중 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
```

### 4. 타입 정의
```typescript
// types/image-brush.ts
export interface ImageBrushRequest {
  image: string;      // Base64 원본 이미지
  mask: string;       // Base64 마스크 이미지
  prompt: string;     // 사용자 프롬프트
  mode: 'flux' | 'i2i';
}

export interface ImageBrushResponse {
  success: boolean;
  imageUrl?: string;  // 처리된 이미지 URL
  error?: string;
}

export interface BrushSettings {
  size: number;       // 5 ~ 100
  opacity: number;    // 0.1 ~ 1.0
  hardness: number;   // 0 ~ 1
}

export type BrushTool = 'brush' | 'eraser' | 'clear';
```

### 5. Canvas Context 업데이트
```typescript
// app/canvas/_context/CanvasContext.tsx
interface CanvasState {
  // 기존 상태...
  brushedImage: string | null;
  imageBrushHistory: Array<{
    original: string;
    brushed: string;
    prompt: string;
    timestamp: number;
  }>;
}

// Image Brush 완료 핸들러
const handleImageBrushComplete = (brushedImageUrl: string) => {
  // 현재 활성 슬롯에 적용
  updateSlot(activeSlotId, { 
    imageUrl: brushedImageUrl,
    metadata: { brushed: true }
  });
  
  // 히스토리에 추가
  addToHistory({
    original: currentImage,
    brushed: brushedImageUrl,
    prompt,
    timestamp: Date.now()
  });
};
```

## 환경 변수 설정

### 1. 로컬 개발 (.env.local)
```env
# BFL API
BFL_TOKEN=your_bfl_api_token

# RunPod API (선택사항)
RUNPOD_API_KEY=your_runpod_api_key
RUNPOD_ENDPOINT_ID=your_endpoint_id

# Supabase Functions URL
NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL=https://your-project.supabase.co/functions/v1
```

### 2. Supabase Edge Function 환경 변수
```bash
# BFL API 토큰 설정
npx supabase@latest secrets set BFL_TOKEN=your_token --project-ref YOUR_PROJECT_REF

# RunPod API 설정 (선택사항)
npx supabase@latest secrets set RUNPOD_API_KEY=your_key --project-ref YOUR_PROJECT_REF
npx supabase@latest secrets set RUNPOD_ENDPOINT_ID=your_id --project-ref YOUR_PROJECT_REF
```

## 배포 전략

### 1. Supabase Edge Function 배포
```bash
# Edge Function 배포
cd /Users/srlee/Desktop/커서개발/3. 서비스/voguedrop
npx supabase@latest functions deploy image-brush --project-ref YOUR_PROJECT_REF

# 배포 확인
npx supabase@latest functions list --project-ref YOUR_PROJECT_REF
```

### 2. Vercel 배포
- 프론트엔드와 API Route는 기존 Vercel 배포 프로세스 사용
- Edge Function URL을 환경 변수로 설정

### 3. 모니터링
```bash
# Edge Function 로그 확인
npx supabase@latest functions logs image-brush --project-ref YOUR_PROJECT_REF --tail 100
```

## UX 고려사항

### 1. 모달 디자인
- **크기**: 최소 800x600px, 반응형 지원
- **레이아웃**: 좌측 캔버스, 우측 도구 패널
- **피드백**: 실시간 마스크 미리보기, 처리 진행률 표시

### 2. 사용성
- **단축키 지원**
  - B: Brush 도구
  - E: Eraser 도구
  - Ctrl+Z: 실행 취소
  - [, ]: 브러시 크기 조절

### 3. 성능 최적화
- 이미지 리사이징: 최대 1024x1024로 제한
- 디바운싱: 브러시 스트로크 최적화
- 캐싱: 처리된 이미지 로컬 캐싱

## 에러 처리

### 1. 프론트엔드
- 네트워크 오류: 재시도 옵션 제공
- API 한도 초과: 사용자에게 알림
- 이미지 로드 실패: 대체 이미지 표시

### 2. 백엔드
- API 키 만료: 관리자에게 알림
- 타임아웃: 60초 제한, 사용자에게 피드백
- 스토리지 오류: 롤백 처리

## 테스트 계획

### 1. 단위 테스트
- 마스크 그리기 함수
- Base64 변환 함수
- API 요청/응답 처리

### 2. 통합 테스트
- 전체 워크플로우 테스트
- Edge Function 호출 테스트
- 에러 시나리오 테스트

### 3. 사용자 테스트
- 다양한 이미지 크기 테스트
- 브라우저 호환성 테스트
- 성능 테스트 (대용량 이미지)

## 향후 개선사항

### Phase 2
- 브러시 모양 다양화 (원형, 사각형, 커스텀)
- 레이어 기능 추가
- 히스토리 기반 실행 취소/다시 실행

### Phase 3
- AI 자동 마스킹 (세그멘테이션)
- 배치 처리 지원
- 프리셋 저장/불러오기

## 참고 자료
- [BFL FLUX Fill API 문서](https://docs.bfl.ai/flux-fill)
- [RunPod API 문서](https://docs.runpod.io/api)
- [Supabase Edge Functions 문서](https://supabase.com/docs/guides/functions)
- [HTML Canvas API MDN](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)

## 구현 일정
- **1주차**: UI 컴포넌트 및 마스킹 도구 구현
- **2주차**: Edge Function 및 AI API 통합
- **3주차**: 테스트 및 버그 수정
- **4주차**: 배포 및 모니터링 설정
</file>

<file path="docs/edge-function-deployment.md">
# Supabase Edge Function 배포 가이드

## 개요
이 문서는 영상 업로드 크기 제한 문제를 해결하기 위해 Supabase Edge Function을 배포하는 방법을 설명합니다.

### 문제 해결
- **기존 문제**: Vercel의 4.5MB 요청 본문 크기 제한
- **해결책**: Supabase Edge Function 사용 (50MB까지 지원)

## 필수 사항

### 1. Supabase CLI 설치

⚠️ **중요**: npm global 설치는 지원되지 않습니다!
```bash
# ❌ 이렇게 하지 마세요
npm install -g supabase  # 에러 발생: "Installing Supabase CLI as a global module is not supported"
```

#### NPX 사용 (권장 - 설치 없이 실행)
```bash
# 설치 없이 직접 실행
npx supabase@latest --version

# 모든 명령어에 npx supabase@latest 사용
npx supabase@latest functions deploy upload-video --project-ref YOUR_PROJECT_REF
```

#### macOS (Homebrew 사용)
```bash
# Homebrew로 설치
brew install supabase/tap/supabase

# 설치 확인
supabase --version

# 주의: Command Line Tools 업데이트 필요 시
# Error: Your Command Line Tools (CLT) does not support macOS 15 발생 시
sudo rm -rf /Library/Developer/CommandLineTools
sudo xcode-select --install
```

#### Windows (Scoop 사용)
```bash
# Scoop 설치 후
scoop bucket add supabase https://github.com/supabase/scoop-bucket.git
scoop install supabase
```

#### Linux
```bash
# wget 사용
wget -qO- https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
sudo mv supabase /usr/local/bin/

# 또는 curl 사용
curl -L https://github.com/supabase/cli/releases/latest/download/supabase_linux_amd64.tar.gz | tar xvz
sudo mv supabase /usr/local/bin/
```

### 2. Supabase 액세스 토큰 생성 및 설정

터미널 환경에서는 브라우저 자동 로그인이 안 되므로 액세스 토큰이 필요합니다.

#### 토큰 생성
1. https://app.supabase.com/account/tokens 접속
2. "Generate new token" 클릭
3. 토큰 이름 입력 (예: "VogueDrop CLI")
4. 생성된 토큰 복사 (⚠️ 한 번만 표시됨!)

#### 토큰 설정
```bash
# 환경 변수로 설정 (권장)
export SUPABASE_ACCESS_TOKEN="your-token-here"

# 또는 .env.local에 추가
echo "SUPABASE_ACCESS_TOKEN=your-token-here" >> .env.local
```

### 3. 프로젝트 연결
```bash
# 프로젝트 루트 디렉토리에서 실행
cd "/Users/srlee/Desktop/커서개발/3. 서비스/voguedrop"  # 경로에 공백이 있으면 따옴표 필수!

# NPX로 실행 시
npx supabase@latest link --project-ref YOUR_PROJECT_REF
```

## Edge Function 배포

### 1. 함수 배포 (NPX 사용)
```bash
# 환경 변수 설정 필수!
export SUPABASE_ACCESS_TOKEN="your-token-here"

# upload-video 함수 배포
npx supabase@latest functions deploy upload-video --project-ref YOUR_PROJECT_REF

# 배포 확인
npx supabase@latest functions list --project-ref YOUR_PROJECT_REF

# 실제 사용 예시
cd "/Users/srlee/Desktop/커서개발/3. 서비스/voguedrop"
export SUPABASE_ACCESS_TOKEN=""
npx supabase@latest functions deploy upload-video --project-ref snqyygrpybwhihektxxy
```

### 2. 환경 변수 설정 (선택사항)
Edge Function은 자동으로 다음 환경 변수에 접근 가능합니다:
- `SUPABASE_URL`
- `SUPABASE_ANON_KEY`
- `SUPABASE_SERVICE_ROLE_KEY`

추가 환경 변수가 필요한 경우:
```bash
supabase secrets set KEY=VALUE --project-ref snqyygrpybwhihektxxy
```

## 로컬 테스트

### 1. 로컬 Edge Function 실행
```bash
# Edge Functions 서버 시작
supabase functions serve

# 특정 함수만 실행
supabase functions serve upload-video --env-file .env.local
```

### 2. 테스트 요청
```bash
# 로컬 테스트 (파일 업로드)
curl -X POST http://localhost:54321/functions/v1/upload-video \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -F "file=@test-video.mp4"
```

## 프로덕션 사용

### 1. 클라이언트 설정
`.env.local` 파일에 다음 환경 변수가 설정되어 있는지 확인:
```env
NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL=https://snqyygrpybwhihektxxy.supabase.co/functions/v1
```

### 2. 업로드 함수 호출
클라이언트 코드는 이미 수정되어 자동으로 Edge Function을 사용합니다:
- `lib/api/upload.ts`: 업로드 유틸리티 함수
- `components/modals/library/components/LibraryUpload.tsx`: UI 컴포넌트

### 3. CORS 설정
Edge Function은 자동으로 CORS 헤더를 처리합니다:
- `supabase/functions/_shared/cors.ts`: CORS 설정 파일

## 모니터링 및 디버깅

### 1. 함수 로그 확인
```bash
# 실시간 로그 스트리밍
supabase functions logs upload-video --project-ref snqyygrpybwhihektxxy

# 최근 로그 확인
supabase functions logs upload-video --project-ref snqyygrpybwhihektxxy --tail 100
```

### 2. 함수 상태 확인
Supabase 대시보드에서 확인:
1. https://app.supabase.com/project/snqyygrpybwhihektxxy
2. Edge Functions 섹션으로 이동
3. `upload-video` 함수 상태 확인

## 트러블슈팅 (실제 발생한 문제들)

### 🔴 문제 1: npm global 설치 실패
```bash
npm install -g supabase
# 에러: Installing Supabase CLI as a global module is not supported
```

**해결책**: NPX 사용 또는 Homebrew/Scoop으로 설치
```bash
npx supabase@latest --version  # NPX 사용 (권장)
# 또는
brew install supabase/tap/supabase  # macOS
```

### 🔴 문제 2: "로그인이 필요합니다" 에러
Edge Function이 작동하지만 인증이 실패하는 경우

**원인**: Edge Function에서 잘못된 방식으로 Supabase 클라이언트 생성
```typescript
// ❌ 잘못된 코드
const token = authHeader.replace('Bearer ', '');
const supabaseAuth = createClient(supabaseUrl, token);  // JWT를 키로 사용
```

**해결책**: anon key 사용 + Authorization 헤더
```typescript
// ✅ 올바른 코드
const supabaseAnon = Deno.env.get('SUPABASE_ANON_KEY') ?? '';
const supabaseAuth = createClient(supabaseUrl, supabaseAnon, {
  global: {
    headers: {
      Authorization: `Bearer ${token}`,  // JWT는 헤더로 전달
    },
  },
});
```

### 🔴 문제 3: 504 Gateway Timeout
대용량 파일 업로드 시 타임아웃 발생

**원인**: 
- Edge Function이 전체 파일을 메모리에 로드
- FormData 파싱 → ArrayBuffer 변환 → Storage 업로드 (3단계)
- 네트워크 속도가 느린 경우 60초 제한 초과

**해결책**:
1. 작은 파일(5-10MB)부터 테스트
2. 클라이언트 타임아웃 연장
```typescript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 120000); // 2분
```
3. 장기적으로는 Presigned URL 방식 고려

### 🔴 문제 4: 터미널에서 로그인 실패
```bash
npx supabase@latest login
# 에러: Cannot use automatic login flow inside non-TTY environments
```

**해결책**: 액세스 토큰 사용
1. https://app.supabase.com/account/tokens 에서 토큰 생성
2. 환경 변수 설정: `export SUPABASE_ACCESS_TOKEN="your-token"`

### 🔴 문제 5: CORS 에러
- `supabase/functions/_shared/cors.ts` 파일 확인
- OPTIONS 요청 처리 확인
```typescript
if (req.method === 'OPTIONS') {
  return new Response('ok', { headers: corsHeaders });
}
```

## 롤백

기존 Vercel API로 롤백이 필요한 경우:
1. `lib/api/upload.ts`에서 `uploadVideoToVercelAPI` 함수 사용
2. 파일 크기 제한을 4MB로 조정

## 성능 최적화

1. **청크 업로드**: 대용량 파일의 경우 청크 단위 업로드 고려
2. **압축**: 클라이언트 측 비디오 압축 구현
3. **CDN**: Supabase Storage CDN 활용

## 보안 고려사항

1. **인증**: 모든 요청에 유효한 JWT 토큰 필요
2. **파일 검증**: 서버 측에서 파일 타입 및 크기 검증
3. **Rate Limiting**: Supabase 대시보드에서 rate limit 설정

## 참고 자료

- [Supabase Edge Functions 문서](https://supabase.com/docs/guides/functions)
- [Supabase CLI 문서](https://supabase.com/docs/guides/cli)
- [Deno 런타임 문서](https://deno.land/manual)
</file>

<file path="lib/api/upload.ts">
import { createClient } from '@/lib/supabase/client';
import type { UserUploadedVideo } from '@/types/database';

interface UploadVideoOptions {
  file: File;
  thumbnail?: File | null;
  metadata?: {
    duration?: number;
    aspectRatio?: string;
    width?: number;
    height?: number;
  };
  onProgress?: (progress: number) => void;
}

interface UploadResponse {
  success: boolean;
  video?: UserUploadedVideo;
  error?: string;
}

/**
 * Upload video to Supabase Edge Function
 * Supports up to 50MB file uploads, bypassing Vercel's 4.5MB limit
 */
export async function uploadVideo({
  file,
  thumbnail,
  metadata,
  onProgress
}: UploadVideoOptions): Promise<UploadResponse> {
  try {
    // Get Supabase client and session
    const supabase = createClient();
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session?.access_token) {
      return {
        success: false,
        error: '로그인이 필요합니다.'
      };
    }

    // Validate file size (50MB limit for Edge Function)
    const MAX_SIZE = 50 * 1024 * 1024;
    if (file.size > MAX_SIZE) {
      return {
        success: false,
        error: `파일 크기는 50MB를 초과할 수 없습니다. (현재: ${(file.size / 1024 / 1024).toFixed(2)}MB)`
      };
    }

    // Create form data
    const formData = new FormData();
    formData.append('file', file);
    
    if (thumbnail) {
      formData.append('thumbnail', thumbnail);
    }
    
    if (metadata) {
      if (metadata.duration) {
        formData.append('duration', metadata.duration.toString());
      }
      if (metadata.aspectRatio) {
        formData.append('aspectRatio', metadata.aspectRatio);
      }
      if (metadata.width) {
        formData.append('width', metadata.width.toString());
      }
      if (metadata.height) {
        formData.append('height', metadata.height.toString());
      }
    }

    // Report initial progress
    onProgress?.(10);

    // Get Edge Function URL from environment
    const functionsUrl = process.env.NEXT_PUBLIC_SUPABASE_FUNCTIONS_URL || 
                        `${process.env.NEXT_PUBLIC_SUPABASE_URL}/functions/v1`;
    
    // Upload to Edge Function with timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 120000); // 2분 타임아웃
    
    const response = await fetch(`${functionsUrl}/upload-video`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${session.access_token}`,
      },
      body: formData,
      signal: controller.signal,
    }).finally(() => clearTimeout(timeoutId));

    // Report upload complete
    onProgress?.(90);

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Upload failed' }));
      return {
        success: false,
        error: errorData.error || `Upload failed with status ${response.status}`
      };
    }

    const data = await response.json();
    
    // Report complete
    onProgress?.(100);

    return {
      success: true,
      video: data.video
    };

  } catch (error) {
    console.error('Upload error:', error);
    
    // 타임아웃 에러 처리
    if (error instanceof Error && error.name === 'AbortError') {
      return {
        success: false,
        error: '업로드 시간이 초과되었습니다. 파일 크기를 줄이거나 네트워크 연결을 확인해주세요.'
      };
    }
    
    return {
      success: false,
      error: error instanceof Error ? error.message : '업로드 중 오류가 발생했습니다.'
    };
  }
}
</file>

<file path="lib/fal-ai.ts">
/**
 * fal.ai API 통합 모듈
 * 
 * 호출 흐름:
 * 1. /app/canvas/page.tsx → Generate 버튼 클릭
 * 2. /app/api/canvas/generate/route.ts → POST 요청 처리
 * 3. 이 파일의 generateVideo() 함수 호출
 * 4. fal.run() → fal.ai API 실제 호출 (54줄)
 */
import * as fal from "@fal-ai/serverless-client";

// 서버사이드 전용 설정
if (typeof window === 'undefined' && process.env.FAL_API_KEY) {
  fal.config({
    credentials: process.env.FAL_API_KEY
  });
}

export interface VideoGenerationParams {
  imageUrl: string;
  prompt: string;
  modelType?: 'seedance' | 'hailo';
  duration?: string;
  resolution?: string;
}

export interface VideoGenerationResult {
  videoUrl: string;
  generationId?: string;
}

/**
 * fal.ai를 사용하여 이미지에서 비디오를 생성합니다.
 */
export async function generateVideo({
  imageUrl,
  prompt,
  modelType = 'seedance',
  duration,
  resolution = '1080p'
}: VideoGenerationParams): Promise<VideoGenerationResult> {
  // 모델별 엔드포인트 설정
  const modelEndpoint = modelType === 'seedance' 
    ? "fal-ai/bytedance/seedance/v1/pro/image-to-video"
    : "fal-ai/minimax/hailuo-02/standard/image-to-video";

  // 프롬프트 길이 제한 제거 - 원본 그대로 사용
  const truncatedPrompt = prompt;

  // 모델별 입력 파라미터 구성
  const input = modelType === 'seedance' 
    ? {
        prompt: truncatedPrompt,
        resolution,
        duration: duration || "5",
        image_url: imageUrl
      }
    : {
        prompt: truncatedPrompt,
        image_url: imageUrl,
        duration: duration || "6",  // 사용자가 선택한 duration 사용
        prompt_optimizer: true
      };


  try {
    // ⭐️ fal.ai API 실제 호출 지점 (subscribe 방식)
    // 긴 처리 시간을 위한 비동기 큐 기반 처리
    
    const result = await fal.subscribe(modelEndpoint, {
      input,
      logs: true,
      onQueueUpdate: (update) => {
        // Status update handling
        if (update.status === "IN_PROGRESS" || update.status === "IN_QUEUE") {
          // Silent processing
        }
      }
    }) as { video?: { url?: string }; requestId?: string };


    // fal.subscribe 응답 구조 확인
    // 실제로는 result 자체에 video가 있음 (data 래핑 없이)
    const videoUrl = result?.video?.url;
    
    if (!videoUrl) {
      console.error('Result structure:', {
        hasVideo: !!result?.video,
        keys: Object.keys(result || {}),
        result: result
      });
      throw new Error('비디오 URL을 찾을 수 없습니다.');
    }

    return {
      videoUrl,
      generationId: result?.requestId || Date.now().toString()
    };
  } catch (error) {
    console.error('Video generation error:', error);
    // 상세 에러 정보 출력
    if (error && typeof error === 'object' && 'body' in error) {
      const typedError = error as { status?: number; body?: { detail?: unknown }; message?: string };
      console.error('Error details:', {
        status: typedError.status,
        body: typedError.body,
        message: typedError.message
      });
      
      // 422 에러의 경우 더 자세한 정보 출력
      if (typedError?.status === 422 && typedError?.body?.detail) {
        console.error('Validation errors:', JSON.stringify(typedError.body.detail, null, 2));
      }
    }
    
    // 401 에러의 경우 더 명확한 메시지
    const errorWithStatus = error as { status?: number };
    if (errorWithStatus?.status === 401) {
      throw new Error('fal.ai API 인증 실패. API 키를 확인해주세요.');
    }
    
    throw new Error(
      error instanceof Error 
        ? error.message 
        : '비디오 생성 중 오류가 발생했습니다.'
    );
  }
}

/**
 * 여러 효과 프롬프트를 하나로 결합합니다.
 * 각 프롬프트는 마침표(.)로 구분합니다.
 */
export function combineEffectPrompts(
  effects: Array<{ prompt: string; name?: string }>,
  basePrompt?: string
): string {
  const prompts: string[] = [];
  
  // 사용자 입력 프롬프트 추가
  if (basePrompt && basePrompt.trim()) {
    prompts.push(basePrompt.trim());
  }
  
  // 선택된 효과들의 프롬프트 추가
  effects.forEach(effect => {
    if (effect.prompt && effect.prompt.trim()) {
      prompts.push(effect.prompt.trim());
    }
  });
  
  // 마침표로 구분하여 결합
  return prompts.join('. ');
}

export interface SoundGenerationParams {
  text: string;
  duration_seconds?: number;
  prompt_influence?: number;
}

export interface SoundGenerationResult {
  audioUrl: string;
  requestId?: string;
}

/**
 * fal.ai ElevenLabs를 사용하여 AI 사운드를 생성합니다.
 */
export async function generateSound({
  text,
  duration_seconds,
  prompt_influence = 0.3
}: SoundGenerationParams): Promise<SoundGenerationResult> {
  const endpoint = "fal-ai/elevenlabs/sound-effects";
  
  try {
    // fal.ai API 호출 (subscribe 방식)
    const result = await fal.subscribe(endpoint, {
      input: {
        text,
        duration_seconds,
        prompt_influence
      },
      logs: true,
      onQueueUpdate: (update) => {
        // Status update handling
        if (update.status === "IN_PROGRESS" || update.status === "IN_QUEUE") {
          // Silent processing
        }
      }
    }) as { audio?: { url?: string }; requestId?: string };

    // 응답 구조 확인
    const audioUrl = result?.audio?.url;
    
    if (!audioUrl) {
      console.error('Sound generation result structure:', {
        hasAudio: !!result?.audio,
        keys: Object.keys(result || {}),
        result: result
      });
      throw new Error('오디오 URL을 찾을 수 없습니다.');
    }

    return {
      audioUrl,
      requestId: result?.requestId || Date.now().toString()
    };
  } catch (error) {
    console.error('Sound generation error:', error);
    
    // 401 에러의 경우 더 명확한 메시지
    const errorWithStatus = error as { status?: number };
    if (errorWithStatus?.status === 401) {
      throw new Error('fal.ai API 인증 실패. API 키를 확인해주세요.');
    }
    
    throw new Error(
      error instanceof Error 
        ? error.message 
        : '사운드 생성 중 오류가 발생했습니다.'
    );
  }
}
</file>

<file path="src/remotion/index.ts">
import { registerRoot } from 'remotion';
import { VideoComposition } from './VideoComposition';
import { loadCoreFonts } from './load-fonts';
import { injectFontStyles } from './inject-fonts';

// 폰트 스타일 인젝션 (Lambda 환경 대비)
injectFontStyles();

// 폰트 로딩 초기화 - Lambda와 로컬 모두에서 실행
loadCoreFonts().catch(console.error);

// Remotion Root 컴포지션 등록
registerRoot(VideoComposition);
</file>

<file path="types/sound.ts">
export interface GeneratedSound {
  id: string;
  url: string;
  title?: string;
  prompt: string;
  duration: number;
  createdAt: Date;
}

export type SoundGenerationType = 'sound_effect' | 'music';

export interface SoundGenerationRequest {
  prompt: string;
  duration_seconds?: number;
  title?: string;
  generation_type?: SoundGenerationType;
}

export interface SoundGenerationResult {
  audioUrl: string;
  requestId?: string;
}

export interface SoundGenerationJobStatus {
  jobId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  result?: {
    audioUrl: string;
  };
  error?: string;
  createdAt: string;
}
</file>

<file path=".mcp.json">
{
	"mcpServers": {
    "remotion-documentation-own": {
			"command": "npx",
			"args": [
				"@remotion/mcp@latest"
			]
		}
	}
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'readdy.ai',
        port: '',
        pathname: '/api/search-image**',
      },
      {
        protocol: 'https',
        hostname: 'static.readdy.ai',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'images.unsplash.com',
        port: '',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: '*.supabase.co',
        port: '',
        pathname: '/storage/v1/object/public/**',
      },
    ],
  },
  
  // Webpack 설정 추가
  webpack: (config, { isServer }) => {
    // README.md 파일 처리
    config.module.rules.push({
      test: /\.md$/,
      type: 'asset/source',
    });
    
    // esbuild 관련 모듈 제외
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        path: false,
        crypto: false,
      };
    }
    
    return config;
  },
  
  // 서버 컴포넌트에서 외부 패키지 처리
  serverExternalPackages: [
    '@remotion/lambda',
    '@remotion/bundler',
    '@remotion/renderer',
  ],
};

export default nextConfig;
</file>

<file path="app/api/canvas/library/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { createServiceClient } from '@/lib/supabase/service';

export async function GET(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }

    // URL 파라미터 가져오기
    const { searchParams } = new URL(request.url);
    const limit = parseInt(searchParams.get('limit') || '100');

    // 1. video_generations 가져오기 (clips)
    const { data: videos, error: videosError } = await supabase
      .from('video_generations')
      .select(`
        id,
        job_id,
        status,
        input_image_url,
        output_video_url,
        created_at,
        is_favorite,
        selected_effects
      `)
      .eq('user_id', user.id)
      .eq('status', 'completed')
      .not('output_video_url', 'is', null)
      .order('is_favorite', { ascending: false })
      .order('created_at', { ascending: false })
      .limit(limit);

    if (videosError) {
      console.error('Error fetching videos:', videosError);
      return NextResponse.json(
        { error: '비디오 목록을 불러오는데 실패했습니다.' },
        { status: 500 }
      );
    }

    // 2. project_saves 가져오기 (projects)
    const { data: projects, error: projectsError } = await supabase
      .from('project_saves')
      .select(`
        id,
        project_name,
        updated_at,
        latest_video_url,
        latest_render_id,
        thumbnail_url,
        content_snapshot,
        video_renders!project_saves_latest_render_id_fkey (
          render_id,
          output_url,
          thumbnail_url,
          status
        )
      `)
      .eq('user_id', user.id)
      .order('updated_at', { ascending: false })
      .limit(limit);

    if (projectsError) {
      console.error('Error fetching projects:', projectsError);
      // 프로젝트 조회 실패는 치명적이지 않으므로 빈 배열로 처리
    }

    // 3. user_uploaded_videos 가져오기 (uploads)
    const { data: uploads, error: uploadsError } = await supabase
      .from('user_uploaded_videos')
      .select(`
        id,
        user_id,
        file_name,
        storage_path,
        file_size,
        duration,
        aspect_ratio,
        thumbnail_url,
        metadata,
        uploaded_at
      `)
      .eq('user_id', user.id)
      .eq('is_deleted', false)
      .order('uploaded_at', { ascending: false })
      .limit(limit);

    if (uploadsError) {
      console.error('Error fetching uploads:', uploadsError);
      // 업로드 조회 실패는 치명적이지 않으므로 빈 배열로 처리
    }

    // Service Client로 공개 URL 가져오기
    const serviceSupabase = createServiceClient();
    const sanitizedUploads = (uploads || []).map(upload => {
      const { data: { publicUrl } } = serviceSupabase.storage
        .from('user-uploads')
        .getPublicUrl(upload.storage_path);
      
      return {
        ...upload,
        url: publicUrl
      };
    });

    // selected_effects에서 name만 추출하여 반환
    const sanitizedVideos = (videos || []).map(video => ({
      id: video.id,
      job_id: video.job_id,
      status: video.status,
      input_image_url: video.input_image_url,
      output_video_url: video.output_video_url,
      created_at: video.created_at,
      is_favorite: video.is_favorite,
      selected_effects: video.selected_effects?.map((effect: { id: number; name: string }) => ({
        id: effect.id,
        name: effect.name
      })) || []
    }));

    // project_saves 데이터 정리
    const sanitizedProjects = (projects || []).map(project => {
      // video_renders는 foreign key relation으로 배열 또는 단일 객체일 수 있음
      const videoRender = Array.isArray(project.video_renders) 
        ? project.video_renders[0] 
        : project.video_renders;
        
      return {
        id: project.id,
        project_name: project.project_name,
        updated_at: project.updated_at,
        latest_video_url: project.latest_video_url,
        thumbnail_url: project.thumbnail_url, // 프로젝트 썸네일 URL 추가
        latest_render: videoRender ? {
          render_id: videoRender.render_id,
          output_url: videoRender.output_url,
          thumbnail_url: videoRender.thumbnail_url,
          status: videoRender.status
        } : undefined,
        content_snapshot: project.content_snapshot ? {
          aspect_ratio: project.content_snapshot.aspect_ratio,
          duration_frames: project.content_snapshot.duration_frames
        } : undefined
      };
    });

    return NextResponse.json({
      videos: sanitizedVideos,  // backward compatibility
      clips: sanitizedVideos,
      projects: sanitizedProjects,
      uploads: sanitizedUploads,
      counts: {
        clips: sanitizedVideos.length,
        projects: sanitizedProjects.length,
        uploads: sanitizedUploads.length
      },
      count: sanitizedVideos.length  // backward compatibility
    });

  } catch {
    // Library API error
    return NextResponse.json(
      { error: '서버 오류가 발생했습니다.' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/sound/history/route.ts">
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

interface SoundGeneration {
  id: number;
  title: string | null;
  prompt: string;
  output_audio_url: string | null;
  duration_seconds: number;
  created_at: string;
  generation_group_id: string | null;
  variation_number: number | null;
  generation_type: string | null;
}

interface GroupedSoundHistory {
  groupId: string;
  prompt: string;
  title: string | null;
  createdAt: string;
  generationType: string | null;
  variations: {
    id: string;
    variationNumber: number;
    url: string;
    duration: number;
  }[];
}

export async function GET(request: Request) {
  try {
    // URL 파라미터에서 generation_type 가져오기
    const { searchParams } = new URL(request.url);
    const typeFilter = searchParams.get('type'); // 'all' | 'sound_effect' | 'music' | 'from_video'
    
    // Supabase 클라이언트 생성 및 인증 확인
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }
    
    // 최근 완료된 사운드 생성 기록 조회 (그룹화를 위해 더 많이 가져옴)
    // prompt 정보도 포함하여 그룹화
    let query = supabase
      .from('sound_generations')
      .select('id, title, prompt, output_audio_url, duration_seconds, created_at, generation_group_id, variation_number, generation_type')
      .eq('user_id', user.id)
      .eq('status', 'completed')
      .not('output_audio_url', 'is', null);
    
    // generation_type 필터 적용
    if (typeFilter && typeFilter !== 'all') {
      query = query.eq('generation_type', typeFilter);
    }
    
    const { data: soundHistory, error } = await query
      .order('created_at', { ascending: false })
      .limit(120); // 30개 그룹을 만들기 위해 더 많이 가져옴
    
    if (error) {
      console.error('Failed to fetch sound history:', error);
      return NextResponse.json(
        { error: '사운드 기록을 불러오는데 실패했습니다.' },
        { status: 500 }
      );
    }
    
    // 그룹화 처리
    const groupedMap = new Map<string, GroupedSoundHistory>();
    
    (soundHistory as SoundGeneration[] || []).forEach(sound => {
      const groupKey = sound.generation_group_id || `single-${sound.id}`;
      
      if (!groupedMap.has(groupKey)) {
        groupedMap.set(groupKey, {
          groupId: groupKey,
          prompt: sound.prompt,
          title: sound.title,
          createdAt: sound.created_at,
          generationType: sound.generation_type,
          variations: []
        });
      }
      
      const group = groupedMap.get(groupKey)!;
      group.variations.push({
        id: `history-${sound.id}`,
        variationNumber: sound.variation_number || 1,
        url: sound.output_audio_url!,
        duration: Number(sound.duration_seconds)
      });
    });
    
    // Map을 배열로 변환하고 정렬
    const groupedHistory = Array.from(groupedMap.values())
      .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
      .slice(0, 30); // 최근 30개 그룹만
    
    // 각 그룹 내의 variations를 variation_number 순으로 정렬
    groupedHistory.forEach(group => {
      group.variations.sort((a, b) => a.variationNumber - b.variationNumber);
    });
    
    return NextResponse.json({
      success: true,
      groups: groupedHistory
    });
    
  } catch (error) {
    console.error('Error fetching sound history:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '서버 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/canvas/_components/Canvas.tsx">
import { Pin, X } from "lucide-react";
import Image from "next/image";
import { CanvasControls } from "./CanvasControls";
import { CanvasHistoryPanel } from "./CanvasHistoryPanel";
import { VideoGenerationProgress } from "./VideoGenerationProgress";
import { useCanvas } from "../_hooks/useCanvas";
import type { GeneratedVideo } from "@/types/canvas";

interface CanvasProps {
  selectedResolution?: string;
  selectedSize?: string;
  onPromptModalOpen?: () => void;
  showControls?: boolean;
  slotContents?: Array<{type: 'image' | 'video', data: string | GeneratedVideo} | null>;
  slotStates?: Array<'empty' | 'generating' | 'completed'>;
  onVideoSelect?: (video: GeneratedVideo) => void;
  onGenerateClick?: () => void;
  isGenerating?: boolean;
  canGenerate?: boolean;
  selectedDuration?: string;
  onDurationChange?: (duration: string) => void;
  generatingProgress?: Map<string, number>;
  generatingJobIds?: Map<string, string>;
  onRemoveContent?: (index: number, type: 'image' | 'video') => void;
  onSlotSelect?: (index: number, video: GeneratedVideo | null) => void;
  selectedSlotIndex?: number | null;
  activeVideo?: GeneratedVideo | null;
  onDownloadClick?: () => void;
  isDownloading?: boolean;
  favoriteVideos?: Set<string>;
  onToggleFavorite?: (videoId: string) => void;
  onImageBrushOpen?: () => void;
  hasUploadedImage?: boolean;
}

export function Canvas({
  selectedResolution = "16:9",
  selectedSize = "1920×1080",
  onPromptModalOpen,
  showControls = false,
  slotContents = [null, null, null, null],
  slotStates = ['empty', 'empty', 'empty', 'empty'],
  onVideoSelect,
  onGenerateClick,
  isGenerating = false,
  canGenerate = false,
  selectedDuration = "6",
  onDurationChange,
  generatingProgress = new Map(),
  generatingJobIds = new Map(),
  onRemoveContent,
  onSlotSelect,
  selectedSlotIndex,
  activeVideo,
  onDownloadClick,
  isDownloading = false,
  favoriteVideos = new Set(),
  onToggleFavorite,
  onImageBrushOpen,
  hasUploadedImage = false,
}: CanvasProps) {
  const {
    images,
  } = useCanvas();

  return (
    <div className="flex-1 flex bg-background">
      <div className="flex-1 flex flex-col">
        {/* Main Images - 4 Columns */}
        <div className="grid grid-cols-4 gap-4 flex-1 p-4">
          {images.map((image, index) => {
            // 슬롯 콘텐츠 가져오기
            const content = slotContents[index];
            let displayContent: { type: 'video' | 'image' | 'empty', data?: GeneratedVideo | string } = { type: 'empty' };
            
            if (content) {
              displayContent = {
                type: content.type,
                data: content.data
              };
            } else if (image.url) {
              // 콘텐츠가 없으면 기본 이미지 표시
              displayContent = { type: 'image', data: image.url };
            }
            
            // 현재 슬롯의 생성 진행률 찾기
            const progress = generatingProgress.get(index.toString()) || 0;
            const isGeneratingThisSlot = slotStates[index] === 'generating' || 
              (isGenerating && generatingProgress.has(index.toString()) && progress < 100);
            
            return (
              <div
                key={image.id}
                className={`relative bg-surface rounded-lg overflow-hidden h-full cursor-pointer transition-all group ${
                  selectedSlotIndex === index ? 'ring-2 ring-primary' : ''
                }`}
                onClick={() => {
                  if (displayContent.type === 'video' && displayContent.data) {
                    onSlotSelect?.(index, displayContent.data as GeneratedVideo);
                  } else {
                    onSlotSelect?.(index, null);
                  }
                }}
              >
              {/* Pin button - 비디오가 있는 슬롯에만 표시 */}
              {displayContent.type === 'video' && displayContent.data && (
                <button
                  className="absolute top-4 left-4 w-10 h-10 bg-surface/90 backdrop-blur rounded-full flex items-center justify-center z-20 hover:bg-surface transition-colors"
                  onClick={(e) => {
                    e.stopPropagation();
                    onToggleFavorite?.((displayContent.data as GeneratedVideo).id);
                  }}
                  aria-label={
                    favoriteVideos.has((displayContent.data as GeneratedVideo).id) || 
                    (displayContent.data as GeneratedVideo).isFavorite 
                      ? "Remove from favorites" 
                      : "Add to favorites"
                  }
                >
                  <Pin
                    className={`w-5 h-5 ${
                      favoriteVideos.has((displayContent.data as GeneratedVideo).id) || 
                      (displayContent.data as GeneratedVideo).isFavorite
                        ? "text-primary fill-current"
                        : "text-foreground/80"
                    }`}
                  />
                </button>
              )}
              
              {/* X button for removing content */}
              {displayContent.type !== 'empty' && onRemoveContent && (
                <button
                  className="absolute top-4 right-4 w-10 h-10 bg-black/60 backdrop-blur rounded-full flex items-center justify-center z-20 opacity-0 group-hover:opacity-100 transition-opacity hover:bg-black/80"
                  onClick={(e) => {
                    e.stopPropagation();
                    if (displayContent.type === 'video' && displayContent.data) {
                      onRemoveContent(index, 'video');
                    } else if (displayContent.type === 'image' && displayContent.data) {
                      onRemoveContent(index, 'image');
                    }
                  }}
                  aria-label="Remove content"
                >
                  <X className="w-5 h-5 text-white" />
                </button>
              )}
              
              
              {/* 비디오 또는 이미지 표시 */}
              {displayContent.type === 'video' && displayContent.data ? (
                <video
                  src={(displayContent.data as GeneratedVideo).url}
                  className="w-full h-full object-cover"
                  controls
                  muted
                  playsInline
                />
              ) : displayContent.type === 'image' && displayContent.data ? (
                <>
                  <Image
                    src={displayContent.data as string}
                    alt={`Canvas image ${index + 1}`}
                    className="absolute inset-0 w-full h-full object-cover"
                    fill
                    sizes="(max-width: 1024px) 25vw, 25vw"
                    priority={index === 0}
                  />
                  {/* Ready to Generate 오버레이 - generating이 아닌 이미지에만 표시 */}
                  {!isGeneratingThisSlot && (
                    <div className="absolute inset-0 bg-black/20 flex items-center justify-center pointer-events-none">
                      <div className="bg-black/70 px-3 py-1.5 rounded-md text-white text-sm font-medium">
                        Ready to Generate
                      </div>
                    </div>
                  )}
                </>
              ) : null}
              
              {/* 프로그레스 오버레이 */}
              <VideoGenerationProgress 
                progress={progress}
                isVisible={isGeneratingThisSlot}
                jobId={generatingJobIds.get(index.toString())}
              />
            </div>
            );
          })}
        </div>

        {/* Controls */}
        {showControls && (
          <div className="flex justify-center p-4">
            <CanvasControls
              selectedResolution={selectedResolution}
              selectedSize={selectedSize}
              onPromptModalOpen={onPromptModalOpen}
              onGenerateClick={onGenerateClick}
              canGenerate={canGenerate}
              selectedDuration={selectedDuration}
              onDurationChange={onDurationChange}
              onDownloadClick={onDownloadClick}
              activeVideo={activeVideo}
              isDownloading={isDownloading}
              onImageBrushOpen={onImageBrushOpen}
              hasUploadedImage={hasUploadedImage}
            />
          </div>
        )}
      </div>

      {/* Right History Panel */}
      <CanvasHistoryPanel
        onVideoSelect={onVideoSelect}
        slotContents={slotContents}
      />
    </div>
  );
}
</file>

<file path="app/canvas/_components/CanvasModals.tsx">
'use client'

import React from 'react'
import { useRouter } from 'next/navigation'
import { LibraryModal } from '@/components/modals/LibraryModal'
import { EffectModal } from '@/components/modals/EffectModal'
import { PromptModal } from '@/components/modals/PromptModal'
import { CameraModal } from '@/components/modals/CameraModal'
import { ModelModal } from '@/components/modals/ModelModal'
import { ProjectTitleModal } from '@/components/modals/ProjectTitleModal'
import { ImageBrushModal } from './ImageBrushModal'
import { useCanvas, useSlotManager } from '../_context/CanvasContext'

/**
 * Canvas 페이지의 모든 모달을 관리하는 컨테이너 컴포넌트
 * Context를 통해 상태를 가져와 Props drilling 없이 모달 제어
 */
export function CanvasModals(): React.ReactElement {
  const router = useRouter()
  const { modals, settings, favorites, effects, currentGeneratingImage, setCurrentGeneratingImage } = useCanvas()
  const slotManager = useSlotManager()

  return (
    <>
      <LibraryModal
        isOpen={modals.modals.library}
        onClose={() => modals.closeModal('library')}
        favoriteVideos={favorites.favoriteIds}
        onToggleFavorite={favorites.toggleFavorite}
      />

      <EffectModal
        isOpen={modals.modals.effect}
        onClose={() => modals.closeModal('effect')}
        onSelectEffect={effects.toggleEffect}
        selectedEffects={effects.selectedEffects}
      />

      <PromptModal
        isOpen={modals.modals.prompt}
        onClose={() => modals.closeModal('prompt')}
        promptText={settings.promptText}
        negativePrompt={settings.negativePrompt}
        onPromptChange={(text: string) => settings.updateSettings({ promptText: text })}
        onNegativePromptChange={(text: string) => settings.updateSettings({ negativePrompt: text })}
        onApply={() => {
          // 프롬프트 적용 로직 (필요시 추가)
          modals.closeModal('prompt')
        }}
      />

      <CameraModal
        isOpen={modals.modals.camera}
        onClose={() => modals.closeModal('camera')}
        onCapture={() => {
          // 카메라 캡처 로직 (필요시 추가)
          modals.closeModal('camera')
        }}
      />

      <ModelModal
        isOpen={modals.modals.model}
        onClose={() => modals.closeModal('model')}
        onSelectModel={(modelId: string) => {
          settings.updateSettings({ selectedModelId: modelId })
        }}
        selectedModelId={settings.selectedModelId}
      />

      <ProjectTitleModal
        isOpen={modals.modals.projectTitle}
        onClose={() => modals.closeModal('projectTitle')}
        onConfirm={(title: string) => {
          router.push(`/video-editor?title=${encodeURIComponent(title)}`)
        }}
      />

      {currentGeneratingImage && (
        <ImageBrushModal
          isOpen={modals.modals.imageBrush}
          onClose={() => modals.closeModal('imageBrush')}
          imageUrl={currentGeneratingImage}
          onComplete={(brushedImageUrl: string) => {
            // 브러시 처리된 이미지로 업데이트
            setCurrentGeneratingImage(brushedImageUrl)
            
            // 현재 선택된 슬롯 또는 이미지가 있는 슬롯을 찾아서 업데이트
            const selectedIndex = slotManager.selectedSlotIndex
            
            // 선택된 슬롯이 있고 이미지 타입이면 해당 슬롯 업데이트
            if (selectedIndex !== null) {
              const selectedSlotContent = slotManager.slotContents[selectedIndex]
              if (selectedSlotContent?.type === 'image') {
                slotManager.setSlotToImage(selectedIndex, brushedImageUrl)
              }
            } else {
              // 선택된 슬롯이 없으면 현재 이미지와 일치하는 슬롯 찾아서 업데이트
              slotManager.slotContents.forEach((slot, index) => {
                if (slot?.type === 'image' && slot.data === currentGeneratingImage) {
                  slotManager.setSlotToImage(index, brushedImageUrl)
                }
              })
            }
            
            modals.closeModal('imageBrush')
          }}
        />
      )}
    </>
  )
}
</file>

<file path="app/video-editor/_context/ProjectContext.tsx">
'use client';

import { createContext, useContext, useState, useCallback, useMemo, ReactNode, useEffect, useRef } from 'react';
import { useSearchParams } from 'next/navigation';

interface ProjectContextType {
  // 프로젝트 메타데이터
  projectTitle: string;
  setProjectTitle: React.Dispatch<React.SetStateAction<string>>;
  
  // 타임라인 UI 상태
  timelineHeight: number;
  isResizing: boolean;
  dragStartY: number;
  initialHeight: number;
  maxTimelineHeight: number;
  
  // 타임라인 리사이징 함수
  handleResizerMouseDown: (e: React.MouseEvent) => void;
  setTimelineHeight: React.Dispatch<React.SetStateAction<number>>;
  
  // 모달 상태
  showVideoLibrary: boolean;
  showSoundLibrary: boolean;
  showTextEditor: boolean;
  showLibrary: boolean;
  setShowVideoLibrary: React.Dispatch<React.SetStateAction<boolean>>;
  setShowSoundLibrary: React.Dispatch<React.SetStateAction<boolean>>;
  setShowTextEditor: React.Dispatch<React.SetStateAction<boolean>>;
  setShowLibrary: React.Dispatch<React.SetStateAction<boolean>>;
  
  // 모달 열기 핸들러
  handleAddClip: () => void;
  handleAddSound: () => void;
  handleAddText: () => void;
  
  // 컨테이너 ref
  containerRef: React.RefObject<HTMLDivElement | null>;
}

const ProjectContext = createContext<ProjectContextType | undefined>(undefined);

export function ProjectProvider({ children }: { children: ReactNode }) {
  // 프로젝트 제목 (page.tsx에서 그대로)
  const [projectTitle, setProjectTitle] = useState('Untitled Project');
  const searchParams = useSearchParams();
  
  // 타임라인 높이 관리 (page.tsx에서 그대로)
  const maxTimelineHeight = 240;
  const [timelineHeight, setTimelineHeight] = useState(240);
  const [isResizing, setIsResizing] = useState(false);
  const [dragStartY, setDragStartY] = useState(0);
  const [initialHeight, setInitialHeight] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // 모달 상태 (page.tsx에서 그대로)
  const [showVideoLibrary, setShowVideoLibrary] = useState(false);
  const [showSoundLibrary, setShowSoundLibrary] = useState(false);
  const [showTextEditor, setShowTextEditor] = useState(false);
  const [showLibrary, setShowLibrary] = useState(false);
  
  // URL 파라미터에서 프로젝트 제목 읽기 (page.tsx에서 그대로)
  useEffect(() => {
    const title = searchParams.get('title');
    if (title) {
      setProjectTitle(decodeURIComponent(title));
    }
  }, [searchParams]);
  
  // 모달 열기 핸들러 (page.tsx에서 그대로)
  const handleAddClip = useCallback(() => {
    setShowVideoLibrary(true);
  }, []);
  
  const handleAddSound = useCallback(() => {
    setShowSoundLibrary(true);
  }, []);
  
  const handleAddText = useCallback(() => {
    setShowTextEditor(true);
  }, []);
  
  // 리사이저 드래그 핸들러 (page.tsx에서 그대로)
  const handleResizerMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    setIsResizing(true);
    setDragStartY(e.clientY);
    setInitialHeight(timelineHeight);
  }, [timelineHeight]);
  
  // 리사이징 이벤트 핸들러 (page.tsx에서 그대로)
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isResizing) return;
      
      // 드래그 시작점 대비 상대적 변화량 계산 (위로 드래그하면 음수)
      const deltaY = dragStartY - e.clientY;
      const newHeight = initialHeight + deltaY;
      
      // 최소 100px, 최대 300px
      const minHeight = 100;
      const maxHeight = maxTimelineHeight;
      
      setTimelineHeight(Math.min(maxHeight, Math.max(minHeight, newHeight)));
    };
    
    const handleMouseUp = () => {
      setIsResizing(false);
    };
    
    if (isResizing) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      document.body.style.cursor = 'ns-resize';
      
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        document.body.style.cursor = '';
      };
    }
  }, [isResizing, dragStartY, initialHeight, maxTimelineHeight]);
  
  // Context value를 useMemo로 최적화
  const value = useMemo(() => ({
    // 프로젝트 메타데이터
    projectTitle,
    setProjectTitle,
    
    // 타임라인 UI 상태
    timelineHeight,
    isResizing,
    dragStartY,
    initialHeight,
    maxTimelineHeight,
    
    // 타임라인 리사이징 함수
    handleResizerMouseDown,
    setTimelineHeight,
    
    // 모달 상태
    showVideoLibrary,
    showSoundLibrary,
    showTextEditor,
    showLibrary,
    setShowVideoLibrary,
    setShowSoundLibrary,
    setShowTextEditor,
    setShowLibrary,
    
    // 모달 열기 핸들러
    handleAddClip,
    handleAddSound,
    handleAddText,
    
    // 컨테이너 ref
    containerRef,
  }), [
    projectTitle,
    timelineHeight,
    isResizing,
    dragStartY,
    initialHeight,
    maxTimelineHeight,
    handleResizerMouseDown,
    showVideoLibrary,
    showSoundLibrary,
    showTextEditor,
    showLibrary,
    handleAddClip,
    handleAddSound,
    handleAddText,
  ]);
  
  return (
    <ProjectContext.Provider value={value}>
      {children}
    </ProjectContext.Provider>
  );
}

export function useProject() {
  const context = useContext(ProjectContext);
  if (!context) {
    throw new Error('useProject must be used within ProjectProvider');
  }
  return context;
}
</file>

<file path="app/video-editor/_hooks/useRemotionPlayer.ts">
import { useState, useEffect, useCallback, useRef } from 'react';
import type { PlayerRef } from '@remotion/player';

interface UseRemotionPlayerProps {
  playerRef: React.RefObject<PlayerRef | null>;
  isOpen: boolean;
  totalDurationInSeconds: number;
}

export const useRemotionPlayer = ({
  playerRef,
  isOpen,
  totalDurationInSeconds
}: UseRemotionPlayerProps) => {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [volume, setVolume] = useState(1);
  const [isMuted, setIsMuted] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const timeUpdateIntervalRef = useRef<NodeJS.Timeout | null>(null);

  // 모달이 닫힐 때 상태 초기화
  useEffect(() => {
    if (!isOpen) {
      setIsPlaying(false);
      setCurrentTime(0);
      setIsReady(false);
      if (playerRef.current) {
        playerRef.current.seekTo(0);
        playerRef.current.pause();
      }
    } else if (isOpen && playerRef.current) {
      // 모달이 열릴 때 첫 프레임 표시
      playerRef.current.seekTo(0);
      playerRef.current.pause();
      setIsPlaying(false);
      
      // 초기 볼륨을 1(100%)로 설정
      playerRef.current.setVolume(1);
      setVolume(1);
      
      // 충분한 시간을 두고 모든 요소(비디오, 텍스트, 오디오)가 렌더링될 때까지 대기
      // CompositePreview의 delayRender가 모두 완료될 시간 확보
      const timer = setTimeout(() => {
        setIsReady(true);
      }, 2500); // 2.5초로 증가 - 폰트 로딩 및 비디오 버퍼링 시간 확보
      
      return () => clearTimeout(timer);
    }
  }, [isOpen, playerRef]);

  // 시간 업데이트 폴링 (Remotion Player의 제한으로 인해 폴링 사용)
  useEffect(() => {
    if (!playerRef.current || !isOpen) return;
    
    const updateTime = () => {
      const frame = playerRef.current?.getCurrentFrame();
      if (frame !== undefined) {
        setCurrentTime(frame / 30);
      }
    };

    // 폴링 시작
    timeUpdateIntervalRef.current = setInterval(updateTime, 100);

    return () => {
      if (timeUpdateIntervalRef.current) {
        clearInterval(timeUpdateIntervalRef.current);
        timeUpdateIntervalRef.current = null;
      }
    };
  }, [isOpen, playerRef]);

  // 재생/일시정지 핸들러
  const handlePlayPause = useCallback(() => {
    if (!playerRef.current || !isReady) return;
    
    const player = playerRef.current;
    
    if (isPlaying) {
      player.pause();
      setIsPlaying(false);
    } else {
      // 재생이 끝났으면 처음부터 다시 재생
      if (currentTime >= totalDurationInSeconds - 0.1) {
        player.seekTo(0);
        setCurrentTime(0);
      }
      player.play();
      setIsPlaying(true);
    }
  }, [playerRef, isPlaying, isReady, currentTime, totalDurationInSeconds]);

  // 시간 이동 핸들러
  const handleSeek = useCallback((newTime: number) => {
    if (!playerRef.current) return;
    
    const frame = Math.round(newTime * 30);
    playerRef.current.seekTo(frame);
    setCurrentTime(newTime);
  }, [playerRef]);

  // 볼륨 변경 핸들러
  const handleVolumeChange = useCallback((newVolume: number) => {
    setVolume(newVolume);
    if (playerRef.current) {
      playerRef.current.setVolume(newVolume);
    }
    if (newVolume > 0 && isMuted) {
      setIsMuted(false);
    }
  }, [playerRef, isMuted]);

  // 음소거 토글 핸들러
  const handleMuteToggle = useCallback(() => {
    const newMuted = !isMuted;
    setIsMuted(newMuted);
    
    if (playerRef.current) {
      playerRef.current.setVolume(newMuted ? 0 : volume);
    }
  }, [playerRef, isMuted, volume]);

  // 재생 완료 감지
  useEffect(() => {
    if (isPlaying && currentTime >= totalDurationInSeconds - 0.1) {
      setIsPlaying(false);
      if (playerRef.current) {
        playerRef.current.pause();
      }
    }
  }, [currentTime, totalDurationInSeconds, isPlaying, playerRef]);

  return {
    isPlaying,
    currentTime,
    volume,
    isMuted,
    isReady,
    handlePlayPause,
    handleSeek,
    handleVolumeChange,
    handleMuteToggle,
  };
};
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Google Fonts 웹폰트 import - 전역 적용 */
@import '../styles/fonts.css';

@layer base {
  :root {
    /* Font Families for Text Editor */
    --font-roboto: 'Roboto', sans-serif;
    --font-open-sans: 'Open Sans', sans-serif;
    --font-montserrat: 'Montserrat', sans-serif;
    --font-poppins: 'Poppins', sans-serif;
    --font-playfair: 'Playfair Display', serif;
    --font-merriweather: 'Merriweather', serif;
    --font-dancing-script: 'Dancing Script', cursive;
    --font-pacifico: 'Pacifico', cursive;
    --font-lobster: 'Lobster', cursive;
    --font-bebas-neue: 'Bebas Neue', sans-serif;
    --font-oswald: 'Oswald', sans-serif;
    --font-noto-sans-kr: 'Noto Sans KR', sans-serif;
    
    /* Border Radius */
    --radius: 0.5rem;
    --radius-sm: 0.125rem;
    --radius-md: 0.375rem;
    --radius-lg: 0.5rem;
    --radius-xl: 0.75rem;
    
    /* Colors - Dark Mode Only */
    --background: 0 0 0;
    --foreground: 255 255 255;
    --card: 17 24 39;
    --card-foreground: 255 255 255;
    --popover: 17 24 39;
    --popover-foreground: 255 255 255;
    --primary: 56 244 124;
    --primary-foreground: 17 24 39;
    --secondary: 52 199 89;
    --secondary-foreground: 255 255 255;
    --muted: 31 41 55;
    --muted-foreground: 156 163 175;
    --accent: 31 41 55;
    --accent-foreground: 255 255 255;
    --destructive: 239 68 68;
    --destructive-foreground: 255 255 255;
    --border: 55 65 81;
    --input: 55 65 81;
    --ring: 56 244 124;
    
    /* Surface Colors */
    --surface: 17 24 39;
    --surface-foreground: 255 255 255;
    --surface-secondary: 31 41 55;
    --surface-tertiary: 55 65 81;
    
    /* Spacing */
    --space-1: 0.25rem;
    --space-2: 0.5rem;
    --space-3: 0.75rem;
    --space-4: 1rem;
    --space-5: 1.25rem;
    --space-6: 1.5rem;
    --space-8: 2rem;
    --space-10: 2.5rem;
    --space-12: 3rem;
    --space-16: 4rem;
    --space-20: 5rem;
    --space-24: 6rem;
    
    /* Transitions */
    --transition-fast: 150ms;
    --transition-normal: 300ms;
    --transition-slow: 500ms;
    
    /* Shadows */
    --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
    --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.4), 0 1px 2px 0 rgba(0, 0, 0, 0.3);
    --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4), 0 2px 4px -1px rgba(0, 0, 0, 0.3);
    --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
    --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.5), 0 10px 10px -5px rgba(0, 0, 0, 0.4);
  }

  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
  
  /* Fix autofill background color for dark theme */
  input:-webkit-autofill,
  input:-webkit-autofill:hover,
  input:-webkit-autofill:focus,
  input:-webkit-autofill:active,
  textarea:-webkit-autofill,
  textarea:-webkit-autofill:hover,
  textarea:-webkit-autofill:focus,
  textarea:-webkit-autofill:active,
  select:-webkit-autofill,
  select:-webkit-autofill:hover,
  select:-webkit-autofill:focus,
  select:-webkit-autofill:active {
    -webkit-background-clip: text;
    -webkit-text-fill-color: rgb(var(--foreground));
    transition: background-color 5000s ease-in-out 0s;
    box-shadow: inset 0 0 20px 20px rgb(var(--background));
  }
}

/* Custom animations */
@keyframes gradient {
  0%, 100% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
}

.animate-gradient {
  animation: gradient 15s ease infinite;
  background-size: 400% 400%;
}

@keyframes glitch {
  0% { transform: translate(0); filter: hue-rotate(0deg); }
  25% { transform: translate(2px, 2px); filter: hue-rotate(90deg); }
  50% { transform: translate(-2px, -2px); filter: hue-rotate(180deg); }
  75% { transform: translate(-2px, 2px); filter: hue-rotate(270deg); }
  100% { transform: translate(0); filter: hue-rotate(360deg); }
}

@keyframes wave {
  0% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0); }
}

@keyframes rainbow {
  0% { filter: hue-rotate(0deg); }
  100% { filter: hue-rotate(360deg); }
}

@keyframes glow {
  0% { opacity: 0.4; }
  50% { opacity: 0.8; }
  100% { opacity: 0.4; }
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.animate-gradient {
  background-size: 200% 200%;
  animation: gradient 3s ease infinite;
}

.animate-glitch { animation: glitch 2s linear infinite; }
.animate-wave { animation: wave 3s ease-in-out infinite; }
.animate-rainbow { animation: rainbow 4s linear infinite; }
.animate-glow { animation: glow 2.5s ease infinite; }
.animate-shimmer { animation: shimmer 2s linear infinite; }

/* Gradient styles using design tokens */
.gradient-text {
  background: linear-gradient(135deg, rgb(var(--primary)) 0%, rgb(var(--secondary)) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.gradient-bg {
  background: linear-gradient(135deg, rgb(var(--primary)) 0%, rgb(var(--secondary)) 100%);
}

.gradient-bg-hover {
  background: linear-gradient(135deg, rgb(var(--primary)) 0%, rgb(var(--secondary)) 100%);
  transition: all var(--transition-normal) ease;
}

.gradient-bg-hover:hover {
  background: linear-gradient(135deg, rgb(var(--primary) / 0.9) 0%, rgb(var(--secondary) / 0.9) 100%);
  filter: brightness(1.1);
}

/* Hero animations */
@keyframes float {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(10px); }
}

@keyframes float-reverse {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(-10px); }
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

.animate-float-reverse {
  animation: float-reverse 3s ease-in-out infinite;
}

.hero-image {
  background: radial-gradient(circle at center, rgba(var(--primary) / 0.1) 0%, rgba(var(--secondary) / 0.05) 100%);
}

/* Animation keyframes */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

@keyframes slideUp {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes slideDown {
  from { transform: translateY(-10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

/* Utility classes for animations */
.animate-fadeIn { animation: fadeIn var(--transition-slow) ease-out; }
.animate-fadeOut { animation: fadeOut var(--transition-slow) ease-out; }
.animate-slideUp { animation: slideUp var(--transition-normal) ease-out; }
.animate-slideDown { animation: slideDown var(--transition-normal) ease-out; }

/* Common Input Styles */
@layer components {
  /* Base input style for all inputs */
  .input-base {
    @apply w-full rounded-lg bg-background border border-border px-4 py-3;
    @apply text-foreground placeholder:text-muted-foreground;
    @apply focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary;
    @apply transition-colors;
  }
  
  /* Small input variant */
  .input-sm {
    @apply px-3 py-1 text-sm;
  }
  
  /* Input with border */
  .input-bordered {
    @apply border-border focus:border-primary;
  }
  
  /* Textarea base style (same as input base) */
  .textarea-base {
    @apply w-full rounded-lg bg-background border border-border px-4 py-3;
    @apply text-foreground placeholder:text-muted-foreground;
    @apply focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary;
    @apply transition-colors;
    @apply resize-none;
  }
  
  /* Prompter textarea style */
  .textarea-prompter {
    @apply w-full min-h-[80px] p-3 text-sm;
    @apply bg-background text-white border border-border rounded-md;
    @apply resize-none;
    @apply focus:outline-none focus:ring-1 focus:ring-primary focus:border-primary;
    @apply placeholder:text-muted-foreground;
  }
  
  /* Dark input style (for light backgrounds) */
  .input-dark {
    @apply bg-black/10 text-black placeholder:text-black/50;
    @apply focus:bg-black/15;
  }
  
  /* Light input style (for dark backgrounds) */
  .input-light {
    @apply bg-white/10 text-white placeholder:text-white/50;
    @apply focus:bg-white/15;
  }
  
  /* Auth input style (deprecated - use input-base instead) */
  .input-auth {
    @apply w-full rounded-lg bg-background border border-border px-4 py-3;
    @apply text-foreground placeholder:text-muted-foreground;
    @apply focus:border-primary focus:outline-none focus:ring-1 focus:ring-primary;
    @apply transition-colors;
  }
  
  /* Error state for inputs */
  .input-error {
    @apply border-destructive focus:ring-destructive;
  }
  
  /* Success state for inputs */
  .input-success {
    @apply border-primary focus:ring-primary;
  }
}

/* Timeline scrollbar styling */
.timeline-content::-webkit-scrollbar {
  width: 8px;
}

.timeline-content::-webkit-scrollbar-track {
  background: rgba(31, 41, 55, 0.5); /* gray-800 계열 */
}

.timeline-content::-webkit-scrollbar-thumb {
  background: rgba(107, 114, 128, 0.8); /* gray-500 계열 */
  border-radius: 4px;
}

.timeline-content::-webkit-scrollbar-thumb:hover {
  background: rgba(156, 163, 175, 0.9); /* gray-400 계열 */
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { 
  Geist, 
  Geist_Mono
} from "next/font/google";
import "./external-imports.css";
import "./globals.css";
import "../styles/fonts.css"; // Google Fonts 직접 import

import { StagewiseToolbar } from "@stagewise/toolbar-next";
import ReactPlugin from "@stagewise-plugins/react";
import { AuthProvider } from "@/lib/auth/AuthContext";
import { Toaster } from "sonner";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

// Text editor fonts are loaded via Google Fonts CDN in globals.css
// This ensures consistency between preview and Lambda rendering

export const metadata: Metadata = {
  title: "VogueDrop - AI Video Editor",
  description: "Create stunning fashion videos from static images with AI-powered effects and transitions",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <AuthProvider>
          {children}
        </AuthProvider>
        <StagewiseToolbar config={{ plugins: [ReactPlugin] }} />
        <Toaster 
          position="top-center"
          richColors
          toastOptions={{
            duration: 4000,
            style: {
              background: '#1f2937',
              color: '#fff',
              border: '1px solid #374151',
            },
          }}
        />
      </body>
    </html>
  );
}
</file>

<file path="lambda/render.ts">
import { renderMediaOnLambda, getRenderProgress, AwsRegion } from '@remotion/lambda';
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { RENDER_CONFIG, S3_CONFIG, LAMBDA_CONFIG } from '../remotion.config';

// S3 클라이언트 초기화
const s3Client = new S3Client({
  region: S3_CONFIG.region,
});

interface RenderRequest {
  videoClips: unknown[];
  textClips: unknown[];
  soundClips: unknown[];
  aspectRatio: '9:16' | '1:1' | '16:9';
  durationInFrames: number;
  userId?: string;
  projectId?: string;
}

interface RenderResponse {
  success: boolean;
  url?: string;
  renderId?: string;
  error?: string;
}

// 화면 비율에 따른 컴포지션 ID 매핑
const getCompositionId = (aspectRatio: string): string => {
  switch (aspectRatio) {
    case '9:16':
      return 'video-mobile';
    case '1:1':
      return 'video-square';
    case '16:9':
      return 'video-wide';
    default:
      return 'video-mobile';
  }
};

// 화면 비율에 따른 크기 반환
const getDimensions = (aspectRatio: string): { width: number; height: number } => {
  switch (aspectRatio) {
    case '9:16':
      return { width: 1080, height: 1920 };
    case '1:1':
      return { width: 1080, height: 1080 };
    case '16:9':
      return { width: 1920, height: 1080 };
    default:
      return { width: 1080, height: 1920 };
  }
};

// Lambda 핸들러 함수
export const handler = async (event: unknown): Promise<RenderResponse> => {
  try {
    // 요청 데이터 파싱
    const eventData = event as { body?: string };
    const request: RenderRequest = typeof eventData.body === 'string' 
      ? JSON.parse(eventData.body) 
      : event as RenderRequest;

    const {
      videoClips,
      textClips,
      soundClips,
      aspectRatio,
      durationInFrames,
      userId = 'anonymous',
      projectId = Date.now().toString(),
    } = request;

    // 컴포지션 ID와 크기 가져오기
    const compositionId = getCompositionId(aspectRatio);
    const dimensions = getDimensions(aspectRatio);

    // 출력 파일명 생성
    const outputFileName = `${userId}/${projectId}/video-${Date.now()}.mp4`;
    
    console.log('Starting render:', {
      compositionId,
      dimensions,
      durationInFrames,
      outputFileName,
    });

    // Remotion Lambda에서 비디오 렌더링
    const { renderId, bucketName } = await renderMediaOnLambda({
      region: LAMBDA_CONFIG.region as AwsRegion,
      functionName: LAMBDA_CONFIG.functionName,
      composition: compositionId,
      serveUrl: process.env.REMOTION_SERVE_URL!, // Remotion 번들 URL (배포 시 설정)
      codec: RENDER_CONFIG.codec,
      imageFormat: RENDER_CONFIG.imageFormat,
      jpegQuality: RENDER_CONFIG.jpegQuality,
      audioCodec: RENDER_CONFIG.audioCodec,
      videoBitrate: RENDER_CONFIG.videoBitrate,
      inputProps: {
        videoClips,
        textClips,
        soundClips,
        backgroundColor: 'black',
      },
      outName: outputFileName,
      privacy: S3_CONFIG.privacy,
      timeoutInMilliseconds: RENDER_CONFIG.timeoutInMilliseconds,
      maxRetries: RENDER_CONFIG.maxRetries,
      chromiumOptions: RENDER_CONFIG.chromiumOptions,
      ...dimensions,
      // Composition의 기본 durationInFrames를 오버라이드
      frameRange: [0, durationInFrames - 1],
    });

    console.log('Render started:', { renderId, bucketName });

    // 렌더링 진행 상황 확인 (옵션)
    let renderProgress = await getRenderProgress({
      renderId,
      bucketName,
      functionName: LAMBDA_CONFIG.functionName,
      region: LAMBDA_CONFIG.region as AwsRegion,
    });

    // 렌더링 완료 대기
    while (renderProgress.overallProgress < 1) {
      await new Promise(resolve => setTimeout(resolve, 3000)); // 3초 대기
      renderProgress = await getRenderProgress({
        renderId,
        bucketName,
        functionName: LAMBDA_CONFIG.functionName,
        region: LAMBDA_CONFIG.region as AwsRegion,
      });
      console.log('Render progress:', renderProgress.overallProgress);
    }

    // 완료된 파일 URL 생성
    const fileUrl = `https://${bucketName}.s3.${S3_CONFIG.region}.amazonaws.com/${outputFileName}`;

    console.log('Render completed:', fileUrl);

    return {
      success: true,
      url: fileUrl,
      renderId,
    };
  } catch (error) {
    console.error('Render error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error occurred',
    };
  }
};

// 렌더링 상태 확인 함수 (별도 엔드포인트용)
export const checkRenderStatus = async (event: unknown): Promise<unknown> => {
  try {
    const eventData = event as { body?: string };
    const { renderId, bucketName } = JSON.parse(eventData.body || '{}');

    const progress = await getRenderProgress({
      renderId,
      bucketName,
      functionName: LAMBDA_CONFIG.functionName,
      region: LAMBDA_CONFIG.region as AwsRegion,
    });

    return {
      statusCode: 200,
      body: JSON.stringify({
        success: true,
        progress: progress.overallProgress,
        done: progress.done,
        outputFile: progress.outputFile,
      }),
    };
  } catch (error) {
    console.error('Status check error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error occurred',
      }),
    };
  }
};
</file>

<file path="types/database.ts">
export interface Category {
  id: number
  name: string
  created_at: string
}

export interface MediaAsset {
  id: number
  storage_path: string
  file_name: string | null
  media_type: string | null
  created_at: string
}

export interface EffectTemplate {
  id: number
  name: string
  category_id: number
  prompt: string
  preview_media_id: number | null
  display_order: number
  is_active: boolean
  created_at: string
}

export interface EffectTemplateWithMedia extends EffectTemplate {
  category: Category
  preview_media: MediaAsset | null
  previewUrl?: string
}

export interface ProjectSave {
  id: number
  user_id: string
  project_name: string
  latest_render_id: string | null
  content_snapshot: {
    version: string
    aspect_ratio: '9:16' | '1:1' | '16:9'
    duration_frames: number
    video_clips: unknown[]
    text_clips: unknown[]
    sound_clips: unknown[]
    content_hash: string
    video_url?: string
  }
  content_hash: string
  version: number
  is_latest: boolean
  created_at: string
  updated_at: string
}

export interface VideoRender {
  id: number
  user_id: string
  project_name: string
  render_id: string
  status: 'processing' | 'completed' | 'failed'
  aspect_ratio: '9:16' | '1:1' | '16:9'
  duration_frames: number
  output_url: string | null
  thumbnail_url: string | null
  video_clips: unknown
  text_clips: unknown
  sound_clips: unknown
  content_hash: string | null
  project_save_id: number | null
  created_at: string
  completed_at: string | null
}

export interface UserUploadedVideo {
  id: number
  user_id: string
  file_name: string
  storage_path: string
  file_size: number
  duration?: number
  aspect_ratio?: string
  thumbnail_url?: string
  metadata?: any
  uploaded_at: string
  is_deleted?: boolean
}
</file>

<file path="remotion.config.ts">
import { Config } from '@remotion/cli/config';

// Remotion 설정
Config.setVideoImageFormat('jpeg');
Config.setOverwriteOutput(true);

// 번들링 설정
Config.overrideWebpackConfig((config) => {
  return {
    ...config,
    module: {
      ...config.module,
      rules: [
        ...(config.module?.rules ?? []),
        {
          test: /\.css$/i,
          use: ['style-loader', 'css-loader', 'postcss-loader'],
        },
      ],
    },
  };
});

// Lambda 렌더링 설정
export const RENDER_CONFIG = {
  codec: 'h264' as const,
  imageFormat: 'jpeg' as const,
  jpegQuality: 80,
  audioCodec: 'aac' as const,
  videoBitrate: '4M',
  audioBitrate: '128k',
  frameRate: 30,
  chromiumOptions: {
    disableWebSecurity: true,
  },
  timeoutInMilliseconds: 900000, // 15분
  maxRetries: 3,
};

// S3 버킷 설정
export const S3_CONFIG = {
  bucketName: process.env.AWS_S3_BUCKET_NAME || 'voguedrop-renders',
  region: process.env.AWS_REGION || 'us-east-1',
  privacy: 'public' as const,
};

// Lambda 함수 설정
export const LAMBDA_CONFIG = {
  functionName: process.env.LAMBDA_FUNCTION_NAME || 'voguedrop-render',
  region: process.env.AWS_REGION || 'us-east-1',
  memorySizeInMb: 3008,
  diskSizeInMb: 2048,
  timeoutInSeconds: 900, // 15분
};
</file>

<file path="app/api/sound/generate-async/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { nanoid } from 'nanoid';
import { processSoundTitle } from '@/lib/sound/utils';
import { SoundGenerationType } from '@/types/sound';

interface GenerateSoundRequest {
  prompt: string;
  duration_seconds?: number;
  title?: string;
  generation_type?: SoundGenerationType;
}

export async function POST(request: NextRequest) {
  const isMockMode = process.env.NEXT_PUBLIC_MOCK_MODE === 'true';
  
  try {
    // Supabase 클라이언트 생성 및 인증 확인
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다.' },
        { status: 401 }
      );
    }
    
    // 1. 요청 데이터 검증
    const body: GenerateSoundRequest = await request.json();
    const { 
      prompt,
      duration_seconds,
      title,
      generation_type = 'sound_effect' // 기본값은 sound_effect
    } = body;
    
    const userId = user.id;
    
    if (!prompt || prompt.trim().length === 0) {
      return NextResponse.json(
        { error: '사운드 설명을 입력해주세요.' },
        { status: 400 }
      );
    }
    
    if (prompt.length > 450) {
      return NextResponse.json(
        { error: '프롬프트는 450자를 초과할 수 없습니다.' },
        { status: 400 }
      );
    }
    
    // Music 타입은 32초 고정, Sound Effect는 사용자 설정값
    const finalDuration = generation_type === 'music' 
      ? 32 
      : (duration_seconds || 5);
    
    if (generation_type === 'sound_effect' && (finalDuration < 1 || finalDuration > 22)) {
      return NextResponse.json(
        { error: '길이는 1초에서 22초 사이여야 합니다.' },
        { status: 400 }
      );
    }
    
    // 2. Group ID 생성 (4개의 variation을 그룹화)
    const groupId = `group_${nanoid()}`;
    const jobIds: string[] = [];
    
    // 3. 4개의 variation에 대한 DB 레코드 생성
    const insertPromises = [];
    for (let i = 1; i <= 4; i++) {
      const jobId = `job_${nanoid()}`;
      jobIds.push(jobId);
      
      insertPromises.push(
        supabase
          .from('sound_generations')
          .insert({
            job_id: jobId,
            user_id: userId,
            prompt: prompt.trim(),
            title: processSoundTitle(title, prompt.trim()),
            duration_seconds: finalDuration,
            status: 'pending',
            webhook_status: 'pending',
            generation_group_id: groupId,
            variation_number: i,
            generation_type: generation_type // DB에 generation_type 필드 추가
          })
          .select('id, job_id, status')
          .single()
      );
    }
    
    const insertResults = await Promise.all(insertPromises);
    
    // 에러 체크
    const failedInserts = insertResults.filter(result => result.error);
    if (failedInserts.length > 0) {
      console.error('Failed to create sound generation records:', failedInserts);
      // 더 자세한 에러 메시지 반환
      const errorDetails = failedInserts[0].error;
      console.error('Detailed error:', errorDetails);
      return NextResponse.json(
        { 
          error: '사운드 생성 요청을 저장하는데 실패했습니다.',
          details: errorDetails?.message || errorDetails
        },
        { status: 500 }
      );
    }
    
    // 4. fal.ai에 비동기 요청 전송 (4개의 variation)
    const webhookBaseUrl = process.env.NEXT_PUBLIC_SITE_URL || 
                          `https://${request.headers.get('host')}`;
    
    // Mock 모드에서는 fal.ai API 호출을 건너뛰고 5초 후 자동 완료
    if (isMockMode) {
      console.log('Mock mode enabled - generating 4 sound variations');
      
      const { createServiceClient } = await import('@/lib/supabase/service');
      const serviceSupabase = createServiceClient();
      
      // 모든 job을 processing으로 업데이트
      for (const jobId of jobIds) {
        await serviceSupabase
          .from('sound_generations')
          .update({
            status: 'processing',
            fal_request_id: `mock_${jobId}`,
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
      }
      
      // 각 job에 대해 webhook 시뮬레이션 (약간의 딜레이를 두고)
      jobIds.forEach((jobId, index) => {
        setTimeout(async () => {
          try {
            const webhookUrl = `${webhookBaseUrl}/api/webhooks/fal-ai?jobId=${jobId}&type=sound`;
            const mockResponse = await fetch(webhookUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Webhook-Secret': process.env.WEBHOOK_SECRET || 'test-secret'
              },
              body: JSON.stringify({
                request_id: `mock_${jobId}`,
                gateway_request_id: 'mock-gateway-id',
                status: 'OK',
                payload: {
                  audio: {
                    url: `https://v3.fal.media/files/example/mock_sound_effect_v${index + 1}.mp3`
                  }
                }
              })
            });
            
            if (!mockResponse.ok) {
              console.error(`Mock webhook call failed for job ${jobId}`);
            }
          } catch (error) {
            console.error(`Mock webhook error for job ${jobId}:`, error);
          }
        }, 3000 + (index * 1000)); // 3초부터 시작해서 1초씩 간격
      });
      
      return NextResponse.json({
        success: true,
        groupId,
        jobIds,
        status: 'processing',
        message: '4개의 사운드 variation 생성이 시작되었습니다.'
      });
    }
    
    // 실제 fal.ai API 호출 (4개의 variation 동시 생성)
    const endpoint = generation_type === 'music' 
      ? "fal-ai/lyria2" 
      : "fal-ai/elevenlabs/sound-effects";
    const { createServiceClient } = await import('@/lib/supabase/service');
    const serviceSupabase = createServiceClient();
    
    // API별로 다른 페이로드 구조
    const requestPayload = generation_type === 'music'
      ? {
          prompt: prompt.trim(),
          negative_prompt: "low quality"
        }
      : {
          text: prompt.trim(),
          duration_seconds: finalDuration,
          prompt_influence: 0.3
        };
    
    // 4개의 API 호출을 병렬로 실행
    const apiPromises = jobIds.map(async (jobId) => {
      const webhookUrl = `${webhookBaseUrl}/api/webhooks/fal-ai?jobId=${jobId}&type=sound`;
      const queueUrl = `https://queue.fal.run/${endpoint}?fal_webhook=${encodeURIComponent(webhookUrl)}`;
      
      try {
        const response = await fetch(queueUrl, {
          method: 'POST',
          headers: {
            'Authorization': `Key ${process.env.FAL_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(requestPayload)
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          console.error(`fal.ai API error for job ${jobId}:`, errorData);
          
          // 실패 시 DB 업데이트
          await serviceSupabase
            .from('sound_generations')
            .update({
              status: 'failed',
              error_message: errorData.detail || 'fal.ai API 호출 실패',
              updated_at: new Date().toISOString()
            })
            .eq('job_id', jobId);
          
          return { success: false, jobId, error: errorData.detail || 'fal.ai API 호출 실패' };
        }
        
        const result = await response.json();
        
        // fal request ID 저장 및 상태 업데이트
        await serviceSupabase
          .from('sound_generations')
          .update({
            fal_request_id: result.request_id,
            status: 'processing',
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        return { success: true, jobId, requestId: result.request_id };
      } catch (error) {
        console.error(`Error calling fal.ai for job ${jobId}:`, error);
        
        await serviceSupabase
          .from('sound_generations')
          .update({
            status: 'failed',
            error_message: 'API 호출 중 오류 발생',
            updated_at: new Date().toISOString()
          })
          .eq('job_id', jobId);
        
        return { success: false, jobId, error: 'API 호출 중 오류 발생' };
      }
    });
    
    const apiResults = await Promise.all(apiPromises);
    
    // 성공한 job 확인
    const successfulJobs = apiResults.filter(r => r.success);
    
    if (successfulJobs.length === 0) {
      return NextResponse.json(
        { error: '모든 사운드 생성 요청이 실패했습니다.' },
        { status: 500 }
      );
    }
    
    // 5. 클라이언트에 즉시 응답 반환
    return NextResponse.json({
      success: true,
      groupId,
      jobIds,
      successfulJobIds: successfulJobs.map(j => j.jobId),
      status: 'processing',
      message: `${successfulJobs.length}개의 사운드 variation 생성이 시작되었습니다.`
    });
    
  } catch (error) {
    console.error('Sound generation error:', error);
    
    return NextResponse.json(
      { 
        error: error instanceof Error 
          ? error.message 
          : '서버 오류가 발생했습니다.'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/video/save/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { createServiceClient } from '@/lib/supabase/service';
import crypto from 'crypto';

interface SaveRequest {
  projectName: string;
  videoClips: unknown[];
  textClips: unknown[];
  soundClips: unknown[];
  aspectRatio: '9:16' | '1:1' | '16:9';
  durationInFrames: number;
  renderId?: string;
  renderOutputUrl?: string;
}

// 안전한 파일명 생성 함수
function sanitizeFileName(fileName: string): string {
  // 특수문자 제거, 공백을 언더스코어로 치환
  return fileName
    .replace(/[^a-zA-Z0-9가-힣.\-_]/g, '_')
    .replace(/\s+/g, '_')
    .replace(/_{2,}/g, '_')
    .slice(0, 100); // 최대 100자로 제한
}

// 컨텐츠 해시 생성 함수
function generateContentHash(data: {
  videoClips: unknown[];
  textClips: unknown[];
  soundClips: unknown[];
  aspectRatio: string;
}): string {
  // 비교에 필요한 핵심 데이터만 추출
  const essentialData = {
    aspectRatio: data.aspectRatio,
    videoClips: (data.videoClips as unknown[]).map((clip: unknown) => {
      const c = clip as Record<string, unknown>;
      return {
        url: c.url,
        position: c.position,
        duration: c.duration,
        startTime: c.startTime || 0,
        endTime: c.endTime
      };
    }).sort((a, b) => (a.position as number) - (b.position as number)),
    textClips: (data.textClips as unknown[]).map((text: unknown) => {
      const t = text as Record<string, unknown>;
      return {
        content: t.content,
        position: t.position,
        duration: t.duration,
        style: t.style,
        effect: t.effect
      };
    }).sort((a, b) => (a.position as number) - (b.position as number)),
    soundClips: (data.soundClips as unknown[]).map((sound: unknown) => {
      const s = sound as Record<string, unknown>;
      return {
        url: s.url,
        position: s.position,
        duration: s.duration,
        volume: s.volume,
        startTime: s.startTime || 0
      };
    }).sort((a, b) => (a.position as number) - (b.position as number))
  };

  // SHA256 해시 생성
  return crypto
    .createHash('sha256')
    .update(JSON.stringify(essentialData))
    .digest('hex');
}

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const body: SaveRequest = await request.json();
    const {
      projectName,
      videoClips,
      textClips,
      soundClips,
      aspectRatio,
      durationInFrames
    } = body;
    
    const { renderId, renderOutputUrl } = body;

    // 컨텐츠 해시 생성
    const contentHash = generateContentHash({
      videoClips,
      textClips,
      soundClips,
      aspectRatio
    });

    // 첫 번째 비디오 클립의 썸네일 URL 추출
    let thumbnailUrl: string | null = null;
    if (videoClips && videoClips.length > 0) {
      const firstClip = videoClips[0] as Record<string, unknown>;
      // thumbnail이 있으면 사용, 없으면 null
      thumbnailUrl = (firstClip.thumbnail as string) || null;
      console.log('Extracted thumbnail from first clip:', thumbnailUrl);
    }

    // 컨텐츠 스냅샷 생성
    const contentSnapshot = {
      version: '1.0',
      aspect_ratio: aspectRatio,
      duration_frames: durationInFrames,
      video_clips: videoClips,
      text_clips: textClips,
      sound_clips: soundClips,
      content_hash: contentHash
    };

    // render_id가 제공된 경우, video_renders 테이블에 존재하는지 확인
    let validRenderId: string | null = null;
    if (renderId) {
      const { data: renderExists } = await supabase
        .from('video_renders')
        .select('render_id')
        .eq('render_id', renderId)
        .single();
      
      if (renderExists) {
        validRenderId = renderId;
      } else {
        console.warn(`Render ID ${renderId} not found in video_renders table`);
      }
    }

    // UPSERT 방식으로 단순화 - 있으면 UPDATE, 없으면 INSERT
    const { data: savedProject, error: saveError } = await supabase
      .from('project_saves')
      .upsert({
        user_id: user.id,
        project_name: projectName,
        latest_render_id: validRenderId || null,
        latest_video_url: null, // 렌더링 후 업데이트 예정
        thumbnail_url: thumbnailUrl, // 첫 번째 클립의 썸네일 저장
        content_snapshot: contentSnapshot,
        content_hash: contentHash,
        updated_at: new Date().toISOString()
      }, {
        onConflict: 'user_id,project_name', // 복합 유니크 키
        ignoreDuplicates: false // 항상 덮어쓰기
      })
      .select()
      .single();

    if (saveError) {
      console.error('Error saving project:', saveError);
      throw saveError;
    }

    // validRenderId가 있으면 video_renders 업데이트
    if (validRenderId) {
      await supabase
        .from('video_renders')
        .update({ project_save_id: savedProject.id })
        .eq('render_id', validRenderId);
    }

    // Supabase Storage에 비디오와 메타데이터 저장
    let supabaseVideoUrl: string | null = null;
    
    if (renderOutputUrl) {
      try {
        // 1. S3에서 비디오 다운로드
        console.log('Downloading video from S3:', renderOutputUrl);
        const videoResponse = await fetch(renderOutputUrl);
        if (!videoResponse.ok) {
          throw new Error('Failed to download video from S3');
        }
        
        const videoBlob = await videoResponse.blob();
        
        // 파일 크기 검증 (최대 100MB)
        const MAX_FILE_SIZE = 100 * 1024 * 1024; // 100MB
        if (videoBlob.size > MAX_FILE_SIZE) {
          throw new Error(`Video file too large: ${(videoBlob.size / 1024 / 1024).toFixed(2)}MB (max: 100MB)`);
        }
        
        const videoFileName = `video-${Date.now()}.mp4`;
        const safeProjectName = sanitizeFileName(projectName);
        const videoPath = `video-projects/${user.id}/${safeProjectName}/${videoFileName}`;
        
        // 2. Service Client를 사용하여 Supabase Storage에 비디오 업로드
        // 사용자 인증은 이미 위에서 확인했으므로, Service Client로 RLS 우회
        console.log('Uploading video to Supabase Storage with Service Client:', videoPath);
        const serviceSupabase = createServiceClient();
        
        const { error: videoError } = await serviceSupabase.storage
          .from('user-uploads')
          .upload(videoPath, videoBlob, {
            contentType: 'video/mp4',
            upsert: true
          });

        if (videoError) {
          console.error('Storage upload error details:', {
            error: videoError,
            bucket: 'user-uploads',
            path: videoPath,
            fileSize: videoBlob.size,
            contentType: 'video/mp4'
          });
          throw new Error(`Storage upload failed: ${videoError.message || 'Unknown error'}`);
        }

        // 3. 비디오 공개 URL 가져오기 (Service Client 사용)
        const { data: { publicUrl } } = serviceSupabase.storage
          .from('user-uploads')
          .getPublicUrl(videoPath);
        
        supabaseVideoUrl = publicUrl;
        console.log('Video uploaded to Supabase:', supabaseVideoUrl);

        // 4. 메타데이터 저장 (Service Client 사용)
        const metadataPath = `video-projects/${user.id}/${safeProjectName}/metadata.json`;
        const { error: metadataError } = await serviceSupabase.storage
          .from('user-uploads')
          .upload(metadataPath, JSON.stringify({
            projectName,
            savedAt: new Date().toISOString(),
            s3Url: renderOutputUrl,
            supabaseUrl: supabaseVideoUrl,
            contentSnapshot
          }), {
            contentType: 'application/json',
            upsert: true
          });

        if (metadataError) {
          console.error('Error uploading metadata:', metadataError);
          // 메타데이터 업로드 실패는 치명적이지 않으므로 계속 진행
        }

        // 5. project_saves 테이블 업데이트 (Supabase URL 저장)
        await supabase
          .from('project_saves')
          .update({ 
            latest_render_id: validRenderId,
            latest_video_url: supabaseVideoUrl,  // latest_video_url 코럼에 저장
            content_snapshot: {
              ...contentSnapshot,
              video_url: supabaseVideoUrl  // 호환성을 위해 여기도 유지
            }
          })
          .eq('id', savedProject.id);

      } catch (error) {
        console.error('Error saving video to Supabase:', error);
        // S3 URL은 여전히 사용 가능하므로 실패해도 계속 진행
        supabaseVideoUrl = renderOutputUrl;
      }
    }

    return NextResponse.json({
      success: true,
      message: 'Project saved successfully',
      projectSaveId: savedProject.id,
      needsRender: !validRenderId && !renderOutputUrl, // 렌더링이 전현 없을 때만 true
      videoUrl: supabaseVideoUrl || renderOutputUrl,
      storageLocation: supabaseVideoUrl ? 'supabase' : renderOutputUrl ? 's3' : null
    });

  } catch (error) {
    console.error('Save API error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to save project',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

// 프로젝트 로드 엔드포인트
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const projectName = searchParams.get('projectName');
    
    if (!projectName) {
      return NextResponse.json(
        { error: 'Project name is required' },
        { status: 400 }
      );
    }

    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 프로젝트 조회 (단일 레코드)
    const { data: projectSave, error } = await supabase
      .from('project_saves')
      .select('*')
      .eq('user_id', user.id)
      .eq('project_name', projectName)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return NextResponse.json(
          { error: 'Project not found' },
          { status: 404 }
        );
      }
      throw error;
    }

    return NextResponse.json({
      success: true,
      project: projectSave
    });

  } catch (error) {
    console.error('Load project error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to load project',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/canvas/_components/CanvasHistoryPanel.tsx">
import { Play, Clock, Loader2 } from "lucide-react";
import Image from "next/image";
import { formatRelativeTime } from "@/lib/utils/session";
import type { GeneratedVideo } from "@/types/canvas";
import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/AuthContext";

interface CanvasHistoryPanelProps {
  onVideoSelect?: (video: GeneratedVideo) => void;
  slotContents?: Array<{type: 'image' | 'video', data: string | GeneratedVideo} | null>;
}

export function CanvasHistoryPanel({
  onVideoSelect,
  slotContents = [],
}: CanvasHistoryPanelProps) {
  const [dbVideos, setDbVideos] = useState<GeneratedVideo[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const { user } = useAuth();

  // Fetch user's video history from API
  // 비디오가 몇 번 슬롯에 있는지 찾는 함수
  const getSlotNumber = (videoId: string): number | null => {
    for (let i = 0; i < slotContents.length; i++) {
      const slot = slotContents[i];
      if (slot?.type === 'video' && (slot.data as GeneratedVideo).id === videoId) {
        return i + 1; // 1-based index for display
      }
    }
    return null;
  };

  useEffect(() => {
    async function fetchVideoHistory() {
      try {
        if (!user) {
          setDbVideos([]);
          setIsLoading(false);
          return;
        }
        
        // API 호출로 변경
        const response = await fetch('/api/canvas/history?limit=50');
        if (!response.ok) {
          throw new Error('Failed to fetch video history');
        }
        
        const data = await response.json();
        
        // API 응답 형식을 GeneratedVideo 형식으로 변환
        const convertedVideos: GeneratedVideo[] = (data.videos || [])
          .map((v: {id: string; videoUrl: string; createdAt: string; thumbnail: string; isFavorite: boolean}) => ({
            id: v.id,
            url: v.videoUrl,
            createdAt: new Date(v.createdAt),
            thumbnail: v.thumbnail,
            isFavorite: v.isFavorite || false
          }));
        
        setDbVideos(convertedVideos);
      } catch (error) {
        console.error('Failed to fetch video history:', error);
      } finally {
        setIsLoading(false);
      }
    }

    fetchVideoHistory();
  }, [user, slotContents]); // 슬롯 변화에도 재조회하여 실시간 반영
  return (
    <div className="w-24 flex flex-col items-center space-y-2 ml-4">
      {/* History Title */}
      <div className="text-xs text-muted-foreground mb-1">
        History
      </div>
      
      {/* Generated Videos */}
      {isLoading ? (
        <div className="text-center py-4">
          <Loader2 className="w-4 h-4 animate-spin text-muted-foreground mx-auto" />
          <p className="text-xs text-muted-foreground mt-2">Loading...</p>
        </div>
      ) : dbVideos.length === 0 ? (
        <div className="text-center py-4">
          <p className="text-xs text-muted-foreground">No videos yet</p>
        </div>
      ) : (
        dbVideos.slice(0, 6).map((video) => {
          const slotNumber = getSlotNumber(video.id);
          return (
            <button
              key={video.id}
              onClick={() => onVideoSelect?.(video)}
              className={`relative w-20 h-20 bg-surface/10 rounded-md overflow-hidden transition-all group ${
                slotNumber !== null
                  ? "border-2 border-primary"
                  : "border border-transparent hover:border-border"
              }`}
              aria-label={`Select video ${video.id}`}
            >
              {/* 슬롯 번호 배지 */}
              {slotNumber !== null && (
                <div className="absolute top-1 left-1 bg-primary text-primary-foreground w-5 h-5 rounded-full flex items-center justify-center z-30 text-xs font-bold">
                  {slotNumber}
                </div>
              )}
              
              {video.thumbnail ? (
                <>
                  <Image
                    src={video.thumbnail}
                    alt={`Video thumbnail ${video.id}`}
                    className="w-full h-full object-cover"
                    fill
                    sizes="80px"
                  />
                  {/* Play overlay on hover */}
                  <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                    <Play className="w-6 h-6 text-white fill-white" />
                  </div>
                </>
              ) : (
                <div className="w-full h-full flex items-center justify-center bg-muted">
                  <Play className="w-8 h-8 text-muted-foreground" />
                </div>
              )}
            
            
            {/* Time indicator */}
            <div className="absolute bottom-1 right-1 bg-black/60 px-1 py-0.5 rounded text-xs text-white flex items-center gap-0.5">
              <Clock className="w-2.5 h-2.5" />
              <span className="text-[10px]">
                {formatRelativeTime(video.createdAt.toISOString())}
              </span>
            </div>
            </button>
          );
        })
      )}
    </div>
  );
}
</file>

<file path="app/video-editor/_components/TimelineControls.tsx">
'use client';

import { useEffect, useState } from 'react';

interface TimelineControlsProps {
  isPlaying: boolean;
  currentTime: number; // in seconds
  totalDuration: number; // in seconds
  onPlayPause: () => void;
  onSeek: (time: number) => void;
  onUndo?: () => void;
  onRedo?: () => void;
  canUndo?: boolean;
  canRedo?: boolean;
}

export default function TimelineControls({
  isPlaying,
  currentTime,
  totalDuration,
  onPlayPause,
  onSeek,
  onUndo,
  onRedo,
  canUndo = false,
  canRedo = false,
}: TimelineControlsProps) {
  const [displayTime, setDisplayTime] = useState('00:00.00');
  const [displayDuration, setDisplayDuration] = useState('00:00.00');

  // 시간을 MM:SS.FF 형식으로 포맷팅 (FF는 프레임, 30fps 기준)
  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    const frames = Math.floor((seconds % 1) * 30); // 30fps 기준
    
    return `${minutes.toString().padStart(2, '0')}:${secs
      .toString()
      .padStart(2, '0')}.${frames.toString().padStart(2, '0')}`;
  };

  useEffect(() => {
    setDisplayTime(formatTime(currentTime));
  }, [currentTime]);

  useEffect(() => {
    setDisplayDuration(formatTime(totalDuration));
  }, [totalDuration]);

  return (
    <div className="flex items-center justify-between px-4 py-2 bg-gray-900 border-b border-gray-700">
      {/* 좌측: Undo/Redo 버튼 */}
      <div className="flex items-center gap-2">
        <button
          className={`w-8 h-8 flex items-center justify-center rounded transition-colors relative group ${
            canUndo 
              ? 'hover:bg-gray-800 text-gray-400 hover:text-white cursor-pointer' 
              : 'text-gray-600 cursor-not-allowed opacity-50'
          }`}
          onClick={onUndo}
          disabled={!canUndo}
          title="실행 취소 (Undo)"
        >
          <i className="ri-arrow-go-back-line text-lg"></i>
          {/* 영어 툴팁 */}
          <span className={`absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs bg-gray-800 text-white rounded whitespace-nowrap pointer-events-none transition-opacity ${
            canUndo ? 'opacity-0 group-hover:opacity-100' : 'opacity-0'
          }`}>
            Undo
          </span>
        </button>
        <button
          className={`w-8 h-8 flex items-center justify-center rounded transition-colors relative group ${
            canRedo 
              ? 'hover:bg-gray-800 text-gray-400 hover:text-white cursor-pointer' 
              : 'text-gray-600 cursor-not-allowed opacity-50'
          }`}
          onClick={onRedo}
          disabled={!canRedo}
          title="다시 실행 (Redo)"
        >
          <i className="ri-arrow-go-forward-line text-lg"></i>
          {/* 영어 툴팁 */}
          <span className={`absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs bg-gray-800 text-white rounded whitespace-nowrap pointer-events-none transition-opacity ${
            canRedo ? 'opacity-0 group-hover:opacity-100' : 'opacity-0'
          }`}>
            Redo
          </span>
        </button>
      </div>

      {/* 중앙: 재생 컨트롤 및 타임코드 */}
      <div className="flex items-center gap-3">
        {/* 처음으로 버튼 */}
        <button
          className="w-8 h-8 flex items-center justify-center rounded hover:bg-gray-800 transition-colors text-gray-400 hover:text-white relative group"
          onClick={() => onSeek(0)}
          title="처음으로 (Skip to Start)"
        >
          <i className="ri-skip-back-line text-lg"></i>
          {/* 영어 툴팁 */}
          <span className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs bg-gray-800 text-white rounded whitespace-nowrap pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity">
            Skip to Start
          </span>
        </button>

        {/* 재생/일시정지 버튼 */}
        <button
          className="w-10 h-10 flex items-center justify-center rounded-full bg-[#38f47cf9] hover:bg-[#38f47c] transition-colors text-black relative group"
          onClick={onPlayPause}
          title={isPlaying ? '일시정지 (Pause)' : '재생 (Play)'}
        >
          <i className={`${isPlaying ? 'ri-pause-fill' : 'ri-play-fill'} text-xl`}></i>
          {/* 영어 툴팁 */}
          <span className="absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 text-xs bg-gray-800 text-white rounded whitespace-nowrap pointer-events-none opacity-0 group-hover:opacity-100 transition-opacity">
            {isPlaying ? 'Pause' : 'Play'}
          </span>
        </button>

        {/* 타임코드 표시 */}
        <div className="flex items-center gap-1 ml-2 font-mono text-xs">
          <span className="text-white">{displayTime}</span>
          <span className="text-gray-500">/</span>
          <span className={totalDuration > 120 ? "text-red-400" : "text-gray-400"}>{displayDuration}</span>
          {totalDuration > 120 && (
            <span className="text-red-400 ml-2 text-[14px] font-sans">
              (Exceeds 2:00 limit)
            </span>
          )}
        </div>
      </div>

      {/* 우측: 빈 공간 */}
      <div className="w-8" />
    </div>
  );
}
</file>

<file path="app/video-editor/_components/TimelineTrack.tsx">
'use client';

import { VideoClip as VideoClipType, TextClip as TextClipType, SoundClip as SoundClipType } from '@/types/video-editor';
import TextClip from './TextClip';
import SoundClip from './SoundClip';

interface TimelineTrackProps {
  type: 'video' | 'text' | 'sound';
  clips: (VideoClipType | TextClipType | SoundClipType)[];
  selectedClips: string[];
  rectSelectedClips: { id: string; type: 'video' | 'text' | 'sound' }[];
  onClipClick: (clipId: string, clipType: 'video' | 'text' | 'sound') => void;
  onMouseDown: (e: React.MouseEvent, clipId: string, clipType: 'video' | 'text' | 'sound') => void;
  onResizeStart: (e: React.MouseEvent, clipId: string, handle: 'left' | 'right', clipType: 'video' | 'text' | 'sound') => void;
  onEditClip?: (clip: TextClipType | SoundClipType) => void;
  onDeleteClip?: (id: string) => void;
  onVolumeChange?: (id: string, volume: number) => void;
  onFadeChange?: (id: string, fadeType: 'fadeIn' | 'fadeOut', duration: number) => void;
  activeClip?: string | null;
  pixelsPerSecond?: number;
  isSelectingRange?: boolean;
  onTrackClick?: (e: React.MouseEvent<HTMLDivElement>) => void;
}

/**
 * Timeline track component
 * Renders a single track (video, text, or sound) with its clips
 */
export default function TimelineTrack({
  type,
  clips,
  selectedClips,
  rectSelectedClips,
  onClipClick,
  onMouseDown,
  onResizeStart,
  onEditClip,
  onDeleteClip,
  onVolumeChange,
  onFadeChange,
  activeClip,
  pixelsPerSecond = 40,
  isSelectingRange = false,
  onTrackClick,
}: TimelineTrackProps) {
  // 줌 비율 계산 (기준: 40px/초)
  const zoomRatio = pixelsPerSecond / 40;
  
  const renderVideoClip = (clip: VideoClipType) => {
    const isRectSelected = rectSelectedClips.some(c => c.id === clip.id && c.type === 'video');
    const isSelected = selectedClips.includes(clip.id);
    const clipWidth = clip.duration * zoomRatio;
    const showText = clipWidth > 30; // 30px 이하면 텍스트 숨김
    
    return (
      <div 
        key={clip.id}
        data-clip-id={clip.id}
        data-clip-type="video"
        className={`group absolute top-0 timeline-clip ${
          isRectSelected
            ? 'ring-2 ring-red-400 rounded'
            : isSelected
              ? 'ring-2 ring-[#38f47cf9] rounded'
              : ''
        }`}
        style={{ 
          width: `${clipWidth}px`,
          left: `${clip.position * zoomRatio}px`
        }}
        onClick={() => onClipClick(clip.id, 'video')}
        onMouseDown={(e) => {
          if (e.shiftKey || isSelectingRange) return;
          if (!(e.target as HTMLElement).classList.contains('resize-handle')) {
            onMouseDown(e, clip.id, 'video');
          }
        }}
      >
        <div 
          className="w-full h-5 bg-gradient-to-r from-gray-900 to-gray-800 rounded cursor-pointer hover:from-gray-800 hover:to-gray-700 transition-colors relative overflow-hidden border border-gray-700"
        >
          {/* Title - 작을 때는 숨김 */}
          {showText && (
            <div className="absolute inset-0 flex items-center">
              <div className="px-2 py-0.5 text-[10px] font-medium text-white/90 truncate">
                {clip.title || 'Video Clip'}
              </div>
            </div>
          )}
          {/* Resize handles - 줌 레벨에 따라 크기 조정 */}
          <div 
            className={`absolute inset-y-0 left-0 bg-[#38f47cf9] rounded-l cursor-ew-resize resize-handle ${
              clipWidth < 50 ? 'w-0.5' : 'w-1'
            }`}
            onMouseDown={(e) => onResizeStart(e, clip.id, 'left', 'video')}
          />
          <div 
            className={`absolute inset-y-0 right-0 bg-[#38f47cf9] rounded-r cursor-ew-resize resize-handle ${
              clipWidth < 50 ? 'w-0.5' : 'w-1'
            }`}
            onMouseDown={(e) => onResizeStart(e, clip.id, 'right', 'video')}
          />
        </div>
      </div>
    );
  };

  const renderTextClip = (clip: TextClipType) => {
    const isRectSelected = rectSelectedClips.some(c => c.id === clip.id && c.type === 'text');
    const isSelected = selectedClips.includes(clip.id);
    const clipWidth = clip.duration * zoomRatio;
    
    return (
      <div
        key={clip.id}
        data-clip-id={clip.id}
        data-clip-type="text"
        className={`timeline-clip absolute top-0 ${
          isRectSelected
            ? 'ring-2 ring-red-400 rounded'
            : isSelected
              ? 'ring-2 ring-[#38f47cf9] rounded'
              : ''
        }`}
        style={{ 
          width: `${clipWidth}px`,
          left: `${clip.position * zoomRatio}px`
        }}
        onClick={() => onClipClick(clip.id, 'text')}
        onMouseDown={(e) => {
          if (e.shiftKey || isSelectingRange) return;
          if (!(e.target as HTMLElement).classList.contains('resize-handle')) {
            onMouseDown(e, clip.id, 'text');
          }
        }}
      >
        <TextClip
          clip={clip}
          onEdit={onEditClip}
          onDelete={onDeleteClip}
          onResizeStart={(e, handle) => onResizeStart(e, clip.id, handle, 'text')}
          isActive={activeClip === clip.id}
          clipWidth={clipWidth}
        />
      </div>
    );
  };

  const renderSoundClip = (clip: SoundClipType) => {
    const isRectSelected = rectSelectedClips.some(c => c.id === clip.id && c.type === 'sound');
    const isSelected = selectedClips.includes(clip.id);
    const clipWidth = clip.duration * zoomRatio;
    
    return (
      <div
        key={clip.id}
        data-clip-id={clip.id}
        data-clip-type="sound"
        className={`timeline-clip absolute top-0 ${
          isRectSelected
            ? 'ring-2 ring-red-400 rounded'
            : isSelected
              ? 'ring-2 ring-[#38f47cf9] rounded'
              : ''
        }`}
        style={{ 
          width: `${clipWidth}px`,
          left: `${clip.position * zoomRatio}px`
        }}
        onClick={() => onClipClick(clip.id, 'sound')}
        onMouseDown={(e) => {
          if (e.shiftKey || isSelectingRange) return;
          if (!(e.target as HTMLElement).classList.contains('resize-handle')) {
            onMouseDown(e, clip.id, 'sound');
          }
        }}
      >
        <SoundClip
          clip={clip}
          onEdit={onEditClip}
          onDelete={onDeleteClip}
          onResizeStart={(e, handle) => onResizeStart(e, clip.id, handle, 'sound')}
          onVolumeChange={onVolumeChange}
          onFadeChange={onFadeChange}
          isActive={activeClip === clip.id}
          pixelsPerSecond={pixelsPerSecond}
          clipWidth={clipWidth}
        />
      </div>
    );
  };

  // Track height calculation based on type
  // Video: 32px, Text: 32px, Sound: 48px for waveform display
  const getTrackHeight = () => {
    switch (type) {
      case 'sound':
        return 'h-12'; // 48px for waveform display
      case 'video':
      case 'text':
      default:
        return 'h-8'; // 32px for video and text
    }
  };
  
  const getClipContainerHeight = () => {
    switch (type) {
      case 'sound':
        return 'h-10'; // 40px for sound clips
      case 'video':
      case 'text':
      default:
        return 'h-5'; // 20px for video and text clips
    }
  };

  return (
    <div className={`border-b border-gray-700 ${getTrackHeight()} flex items-center`} onClick={onTrackClick}>
      <div className={`relative w-full ${getClipContainerHeight()}`}>
        {clips.map((clip) => {
          if (type === 'video') return renderVideoClip(clip as VideoClipType);
          if (type === 'text') return renderTextClip(clip as TextClipType);
          if (type === 'sound') return renderSoundClip(clip as SoundClipType);
          return null;
        })}
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/VideoLibraryModal.tsx">
'use client';

import { LibraryModalBase } from '@/components/modals/library/LibraryModalBase';
import { LibraryModalConfig } from '@/types/library-modal';
import { LibraryItem } from '@/types/video-editor';

interface VideoLibraryModalProps {
  onClose: () => void;
  onAddToTimeline: (items: LibraryItem[]) => void;
}

export default function VideoLibraryModal({ onClose, onAddToTimeline }: VideoLibraryModalProps) {
  const config: LibraryModalConfig = {
    mode: 'selection',
    selection: {
      enabled: true,
      maxItems: 10,
      onSelect: onAddToTimeline
    },
    theme: {
      primaryColor: '#38f47cf9',
      buttonStyle: 'success',
      selectionColor: '#38f47cf9'
    }
  };

  return <LibraryModalBase isOpen={true} onClose={onClose} config={config} />;
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## VogueDrop 개발 가이드

VogueDrop은 AI 기반 패션 콘텐츠 생성 플랫폼입니다. 패션 크리에이터들이 정적 이미지를 AI 영상으로 변환하고 편집할 수 있습니다.

## Note
- Always answer in Korean.

## 핵심 문서 참조
개발 시 다음 문서를 반드시 참고하세요:
- `docs/prd.md` - 제품 요구사항과 Epic/Story 정의  
- `docs/fullstack-architecture.md` - 기술 스택과 시스템 설계
- `docs/frontend-architecture.md` - UI 구현 가이드
- `docs/ui-ux-spec.md` - 디자인 시스템과 UX 패턴
- `docs/video-render-setup-guide.md` - Remotion 렌더링 설정

## 주요 개발 명령어
```bash
# 개발 서버 시작 (Turbopack 사용)
npm run dev:turbo

# 개발 서버 시작 (표준)
npm run dev

# 빌드
npm run build

# 프로덕션 서버 시작
npm run start

# 린트 검사
npm run lint

# 테스트 실행 (watch 모드)
npm run test

# 테스트 실행 (단일 실행)
npm run test:run

# 폰트 렌더링 테스트
npm run test:font-render

# Remotion Studio 실행 (비디오 편집 개발)
npm run remotion:studio

# Remotion 비디오 렌더링
npm run remotion:render

# Remotion Lambda 배포
npm run remotion:lambda:deploy

# Remotion Lambda 사이트 생성
npm run remotion:lambda:sites

# 모든 폰트 다운로드 (초기 설정)
./scripts/download-all-fonts.sh
```

### 빌드 전 필수 체크
**중요**: 코드 작성 완료 후 반드시 `npm run lint`와 `npm run build`를 실행하여 타입 에러와 빌드 에러가 없는지 확인해야 합니다. 타입 에러가 있으면 프로덕션 배포가 실패합니다.

## 고수준 아키텍처

### 시스템 구조
- **Monorepo**: 단일 저장소에서 프론트엔드와 백엔드 통합 관리
- **Fullstack Framework**: Next.js 14+ App Router로 프론트엔드와 API 통합
- **Serverless**: Vercel Functions로 자동 스케일링
- **Database**: Supabase (PostgreSQL + Auth + Storage)
- **AI Integration**: fal.ai API로 영상 생성
- **Video Editing**: Remotion으로 클라이언트 사이드 비디오 편집 및 렌더링

### 주요 워크플로우
1. **AI 영상 생성 (Job-based Architecture)**:
   - 이미지 업로드 → Supabase Storage 저장
   - 효과 선택 (최대 2개) → job 생성 및 DB 기록
   - fal.ai API 비동기 호출 (webhook URL 포함)
   - 클라이언트 3초 간격 polling으로 진행상황 추적
   - Webhook 수신 시 job 상태 업데이트
   - 5분 후 webhook 미수신 시 fal.ai 직접 polling (fallback)
   - 완료된 영상 Supabase Storage 저장 및 메타데이터 업데이트

2. **영상 업로드 (Supabase Edge Function)**:
   - 대용량 파일 지원: 최대 50MB (Vercel 4.5MB 제한 우회)
   - 클라이언트 → Edge Function → Supabase Storage 직접 저장
   - 자동 썸네일 생성 및 메타데이터 추출
   - `lib/api/upload.ts`의 uploadVideo 함수 사용

3. **비디오 편집 (Remotion)**:
   - Video Editor에서 클립 타임라인 관리
   - Remotion Player로 실시간 프리뷰
   - AWS Lambda 또는 서버 사이드 렌더링으로 최종 영상 생성
   - 생성된 영상 Supabase Storage 저장

4. **사용자 인증**: Supabase Auth로 이메일/비밀번호 인증
5. **데이터 저장**: 생성된 영상과 메타데이터를 Supabase에 저장
6. **슬롯 기반 UI**: Canvas에서 4개 슬롯으로 컨텐츠 관리

## 프로젝트 구조 패턴

### Feature-First Co-location
```
app/
├── (feature-group)/              # 라우트 그룹 (URL에 영향 없음)
│   ├── feature-page/
│   │   ├── page.tsx             # 페이지 컴포넌트
│   │   ├── layout.tsx           # 레이아웃 (선택사항)
│   │   ├── _components/         # 기능 전용 컴포넌트
│   │   │   ├── index.ts         # 배럴 export
│   │   │   ├── ComponentA.tsx
│   │   │   └── ComponentB.tsx
│   │   ├── _hooks/              # 기능 전용 훅
│   │   │   ├── index.ts
│   │   │   └── useFeature.ts
│   │   ├── _context/            # 기능 전용 컨텍스트
│   │   │   └── FeatureContext.tsx
│   │   ├── _utils/              # 기능 전용 유틸리티
│   │   │   └── helpers.ts
│   │   └── _types/              # 기능 전용 타입
│   │       └── index.ts
│   └── another-feature/
│
├── api/                         # API 라우트
│   └── feature/
│       └── route.ts            # HTTP 메서드 export
│
components/                      # 공유 컴포넌트
├── ui/                         # 기본 UI 요소
│   ├── Button.tsx
│   └── index.ts
├── layout/                     # 레이아웃 컴포넌트
└── modals/                     # 공유 모달

lib/                            # 유틸리티 및 설정
├── supabase/
│   ├── client.ts
│   └── server.ts
├── utils/
└── constants/

types/                          # 글로벌 타입 정의
├── database.ts
├── api.ts
├── env.d.ts                    # 환경 변수 타입
└── index.ts

src/remotion/                   # Remotion 비디오 컴포지션
├── index.ts                    # Remotion 엔트리 포인트
└── compositions/               # 비디오 컴포지션 컴포넌트
```

### Import 순서 규칙
```typescript
// 1. React/Next.js
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';

// 2. 외부 라이브러리
import { createClient } from '@supabase/supabase-js';
import { z } from 'zod';

// 3. 절대 경로 import (@/)
import { Button } from '@/components/ui/Button';
import { useAuth } from '@/lib/auth';

// 4. 상대 경로 import
import { LocalComponent } from './_components/LocalComponent';
import { useLocalHook } from './_hooks/useLocalHook';

// 5. 타입 import (별도 그룹)
import type { User } from '@/types/database';
import type { ComponentProps } from './types';
```

### 타입 정의 구조
```
types/
├── database.ts        # Supabase 데이터베이스 타입
├── canvas.ts          # Canvas 기능 타입
├── video-editor.ts    # 비디오 에디터 타입
├── sound.ts          # 사운드 관련 타입
├── auth.ts           # 인증 관련 타입
└── env.d.ts          # 환경 변수 타입 정의
```

#### 환경 변수 타입 정의 예시
```typescript
// types/env.d.ts
declare namespace NodeJS {
  interface ProcessEnv {
    NEXT_PUBLIC_SUPABASE_URL: string;
    NEXT_PUBLIC_SUPABASE_ANON_KEY: string;
    SUPABASE_SERVICE_KEY: string;
    FAL_API_KEY: string;
    WEBHOOK_SECRET: string;
  }
}
```

#### Supabase 타입 안전한 쿼리
```typescript
// types/database.ts에 타입 정의
export interface VideoGenerationWithEffects extends VideoGeneration {
  effects: EffectTemplate[];
  user: User;
}

// 사용 예시
const { data, error } = await supabase
  .from('video_generations')
  .select('*, effects:effect_templates(*), user:users(*)')
  .returns<VideoGenerationWithEffects[]>();
```

### 데이터베이스 스키마
주요 테이블:
- `video_generations`: 영상 생성 작업 추적 (job_id, status, webhook 상태)
- `effect_templates`: AI 효과 템플릿 (카테고리별)
- `categories`: 효과 카테고리 관리
- `media_assets`: 파일 스토리지 관리
- `video_generation_logs`: 상세 로깅
- `project_saves`: 비디오 에디터 프로젝트 저장
- `sound_generations`: 사운드 생성 작업 추적

## 코딩 표준 및 에러 방지 가이드

### TypeScript 필수 규칙
- **`any` 타입 절대 금지** - 타입을 모를 때는 `unknown` 사용 후 타입 가드 적용
- **모든 함수에 명시적 반환 타입 정의**
- **interface로 props 정의, type은 유니온/인터섹션에 사용**
- **빌드 시 타입 에러가 없어야 함** - `npm run build`로 확인
- **엄격한 null 체크** - optional chaining(`?.`)과 nullish coalescing(`??`) 활용

#### 올바른 타입 정의 예시
```typescript
// ❌ 잘못된 예시
function getData(id) {  // 매개변수와 반환 타입 없음
  const result: any = fetchData(id);  // any 사용
  return result.data;  // null 체크 없음
}

// ✅ 올바른 예시
function getData(id: string): Promise<DataType | null> {
  const result: unknown = await fetchData(id);
  if (isDataType(result)) {  // 타입 가드
    return result.data ?? null;  // nullish coalescing
  }
  return null;
}
```

### React/Next.js ESLint 규칙

#### React Hook 의존성 배열 관리
```typescript
// ❌ 문제: cleanup 함수에서 ref 직접 접근
useEffect(() => {
  return () => {
    fontLoadHandles.current.clear();  // ref가 변경될 수 있음
  };
}, [textClips]);

// ✅ 해결: 로컬 변수에 복사
useEffect(() => {
  const handles = fontLoadHandles.current;
  return () => {
    handles.clear();
  };
}, [textClips]);
```

#### Async 함수 처리
```typescript
// ❌ useEffect에 async 직접 사용 불가
useEffect(async () => {
  await fetchData();
}, []);

// ✅ 내부 async 함수 정의
useEffect(() => {
  const loadData = async () => {
    await fetchData();
  };
  loadData();
}, []);

### 컴포넌트 패턴

#### 서버 컴포넌트 (기본)
```typescript
// app/feature/page.tsx
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Feature Page',
};

export default async function PageName() {
  // 서버에서 데이터 페칭
  const data = await fetchData();
  return (
    <div>
      <ClientComponent initialData={data} />
    </div>
  );
}
```

#### 클라이언트 컴포넌트
```typescript
// app/feature/_components/ClientComponent.tsx
'use client';

interface ClientComponentProps {
  initialData: DataType;
  onAction?: (id: string) => void;
}

export function ClientComponent({ initialData, onAction }: ClientComponentProps) {
  const [data, setData] = useState(initialData);
  
  return <div>{/* UI */}</div>;
}
```

### API 라우트 패턴
```typescript
// app/api/[feature]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { createClient } from '@/lib/supabase/server';

// 요청 스키마 정의
const requestSchema = z.object({
  field: z.string().min(1),
});

export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // 1. 인증 체크
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    // 2. 요청 검증
    const body = await request.json();
    const validated = requestSchema.parse(body);
    
    // 3. 비즈니스 로직
    const result = await processData(validated);
    
    return NextResponse.json({ data: result });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

### 커스텀 Hook 패턴
```typescript
// app/feature/_hooks/useFeature.ts
import { useState, useCallback, useEffect } from 'react';

interface UseFeatureOptions {
  autoLoad?: boolean;
}

interface UseFeatureReturn {
  data: DataType | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

export function useFeature(
  id: string,
  options: UseFeatureOptions = {}
): UseFeatureReturn {
  const { autoLoad = true } = options;
  const [data, setData] = useState<DataType | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  
  const fetch = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      const response = await fetchData(id);
      setData(response);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setLoading(false);
    }
  }, [id]);
  
  useEffect(() => {
    if (autoLoad) {
      fetch();
    }
  }, [autoLoad, fetch]);
  
  return { data, loading, error, refetch: fetch };
}
```

### 비동기 Job 처리 패턴
```typescript
// 1. Job 생성 및 비동기 작업 시작
POST /api/canvas/generate-async
- Job ID 생성 및 DB 기록
- fal.ai API 호출 (webhook URL 포함)
- Job ID 반환

// 2. 상태 확인 (Polling)
GET /api/canvas/jobs/[jobId]/poll
- DB에서 job 상태 확인
- 5분 이상 경과 시 fal.ai 직접 조회

// 3. Webhook 수신
POST /api/webhooks/fal-ai
- 서명 검증
- Job 상태 업데이트
- 결과 저장
```

## 현재 개발 상태 (MVP)

### 완료된 기능
- ✅ **Epic 1**: 사용자 인증 시스템 (완료)
  - 이메일/비밀번호 회원가입 및 로그인
  - Supabase Auth 통합
  - 세션 관리 및 보호된 라우트

- ✅ **Epic 2**: Canvas AI Studio (완료)
  - 이미지 업로드 (드래그앤드롭 지원)
  - 효과 선택 UI (최대 2개 효과 선택)
  - AI 영상 생성 (fal.ai Hailo 모델)
  - 실시간 진행상황 추적
  - 영상 히스토리 및 즐겨찾기
  - 슬롯 기반 컨텐츠 관리 (4 슬롯)
  - 영상 다운로드 기능

- ✅ **Epic 3**: 갤러리 시스템 (완료)
  - 영상 목록 및 필터링
  - 반응형 그리드 레이아웃
  - 카테고리별 브라우징

- 🚧 **Epic 4**: Video Editor (진행 중)
  - ✅ Remotion 통합 및 프리뷰
  - ✅ 타임라인 UI 및 클립 관리
  - ✅ 텍스트/사운드 클립 추가
  - ✅ 클립 복제/분할/트림 기능
  - ✅ 실행 취소/다시 실행
  - 🚧 서버 사이드 렌더링 (AWS Lambda)

### 기술적 구현 사항
- **Job 기반 비동기 처리**: 영상 생성 요청을 job으로 관리
- **Webhook 시스템**: fal.ai 서명 검증 및 상태 업데이트
- **Progress Tracking**: 실시간 진행률 시뮬레이션 및 표시
- **Fallback 메커니즘**: Webhook 실패 시 직접 polling
- **Favorites 기능**: 생성된 영상 즐겨찾기 관리
- **Stagewise 통합**: 개발 도구 통합 (포트 3100/3000)
- **Remotion Integration**: 클라이언트 사이드 비디오 편집 및 렌더링

## 환경 변수 설정
```bash
# .env.local (클라이언트에서 접근 가능)
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key
NEXT_PUBLIC_FAL_PUBLISHABLE_KEY=your-fal-publishable-key
NEXT_PUBLIC_MOCK_MODE=false  # true로 설정 시 AI API 호출 대신 목업 사용

# .env (서버 전용)
SUPABASE_SERVICE_KEY=your-service-key
FAL_API_KEY=your-fal-api-key
WEBHOOK_SECRET=your-webhook-secret
REMOTION_AWS_ACCESS_KEY_ID=your-aws-access-key
REMOTION_AWS_SECRET_ACCESS_KEY=your-aws-secret

# AWS Lambda 관련 (선택사항)
AWS_S3_BUCKET_NAME=voguedrop-renders
AWS_REGION=us-east-1
LAMBDA_FUNCTION_NAME=voguedrop-render
```

### Vercel 배포 설정
```json
// vercel.json
{
  "functions": {
    "app/api/canvas/generate-async/route.ts": {
      "maxDuration": 60
    },
    "app/api/video/render/route.ts": {
      "maxDuration": 60
    }
  }
}
```

## 개발 시 주의사항

### Supabase 데이터 접근 보안
- **클라이언트 컴포넌트에서 Supabase 직접 접근 금지**: 민감한 정보(prompt, model_type 등)가 네트워크 탭에 노출되므로, 반드시 API Route를 통해 서버 사이드에서만 데이터베이스 접근
- **API 응답 최소화**: select('*') 사용 금지, 클라이언트에 필요한 최소한의 필드만 명시적으로 선택하여 반환
- **환경 변수 분리 철저**: NEXT_PUBLIC_ 접두사가 있는 환경 변수는 클라이언트에 노출되므로, Service Key 등 민감한 정보는 서버 전용 환경 변수로 관리

### Remotion 비디오 편집
- **Player 상태 동기화**: currentFrame 업데이트 시 타임라인과 프리뷰 동기화 필수
- **클립 오버레이**: z-index와 레이어 순서 관리 주의
- **렌더링 성능**: 실시간 프리뷰는 클라이언트, 최종 렌더링은 서버 사이드 처리

### MVP 집중
- 2주 내 출시 목표: 핵심 기능만 구현
- 데스크톱 우선: 1280x720 이상 해상도
- 인증 전까지 anonymous 사용자 지원

### 성능 최적화
- 이미지는 Next.js Image 컴포넌트 사용
- 동적 임포트로 코드 스플리팅
- 서버 컴포넌트 우선 사용
- Remotion 컴포지션은 필요 시점에만 로드

### 에러 처리
- 모든 API 호출에 try-catch 필수
- 사용자 친화적인 에러 메시지 표시
- 로딩 상태 표시 필수
- Job 실패 시 재시도 로직 구현

### 코드 품질 체크
1. **작업 완료 후 필수 명령어 실행**:
   ```bash
   npm run lint      # ESLint 검사
   npm run build     # 타입 체크 및 빌드 테스트
   npm run test:run  # 테스트 실행
   ```
2. **빌드 에러 발생 시**:
   - 타입 에러: 정확한 타입 정의 추가
   - ESLint 에러: 코드 스타일 수정
   - 의존성 에러: package.json 확인

### 테스트 실행
```bash
# Vitest를 사용한 테스트
npm run test         # Watch 모드로 테스트 실행
npm run test:run     # 단일 실행 (CI/CD용)

# 특정 파일만 테스트
npm run test -- path/to/test.test.ts

# 커버리지 확인
npm run test -- --coverage
```

테스트 파일은 `*.test.ts` 또는 `*.test.tsx` 형식으로 작성하며, `@testing-library/react`를 사용합니다.

### 흔한 에러 및 해결 방법

#### 1. React Hook 의존성 경고
```
ESLint: React Hook useEffect has a missing dependency: '...'
```
**해결**: ESLint가 제안하는 의존성을 배열에 추가하거나, 의도적인 경우 주석 처리

#### 2. TypeScript 타입 에러
```
Property '...' does not exist on type 'unknown'
```
**해결**: 타입 가드를 사용하여 타입 좁히기
```typescript
if (data && typeof data === 'object' && 'property' in data) {
  // data.property 접근 가능
}
```

#### 3. Async 컴포넌트 에러
```
Error: Objects are not valid as a React child
```
**해결**: 서버 컴포넌트에서만 async 사용, 클라이언트 컴포넌트는 useEffect 활용

#### 4. Import 경로 에러
```
Cannot find module '@/...'
```
**해결**: tsconfig.json의 paths 설정 확인, 상대 경로 사용 고려

## Git 워크플로우

### 브랜치 전략
```bash
# 기능 브랜치
feat/story-{epic}.{story}-{description}
예: feat/story-2.1-image-upload

# 버그 수정
fix/{issue-description}

# 리팩토링
refactor/{description}
```

### 커밋 메시지 형식
```
{type}: {description}

- 상세 변경사항 1
- 상세 변경사항 2

🤖 Generated with Claude Code

Co-Authored-By: Claude <noreply@anthropic.com>
```

## 디버깅 팁

### Supabase 연결 문제
- Supabase 대시보드에서 API 설정 확인
- 환경 변수가 올바르게 설정되었는지 확인
- RLS 정책이 MVP에서는 비활성화되어 있는지 확인

### Next.js 라우팅 이슈
- 파일명이 `page.tsx`인지 확인
- 라우트 그룹 `()` 사용 시 URL에 영향 없음 확인
- 미들웨어가 올바른 경로를 매칭하는지 확인

### TypeScript 에러
- `npm run dev`로 실시간 타입 체크
- VS Code의 TypeScript 버전이 프로젝트와 일치하는지 확인
- `types/` 폴더의 타입 정의 확인
- **`npm run build` 실행 시 타입 에러 해결 방법**:
  - `@typescript-eslint/no-unused-vars`: 사용하지 않는 변수 제거
  - `@typescript-eslint/no-explicit-any`: `any` 대신 구체적인 타입 정의
  - React Hook 의존성 경고: `useCallback` 사용 또는 의존성 배열 업데이트
  - 타입 캐스팅이 필요한 경우: `as` 키워드 사용 (최소한으로)

### 에러 처리 패턴
```typescript
// lib/errors.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// 사용 예시
try {
  const result = await riskyOperation();
} catch (error) {
  if (error instanceof AppError) {
    // 앱 에러 처리
    console.error(`Error ${error.code}: ${error.message}`);
  } else if (error instanceof Error) {
    // 일반 에러 처리
    console.error(error.message);
  } else {
    // unknown 에러 처리
    console.error('Unknown error occurred');
  }
}
```

### fal.ai API 디버깅
- Webhook 수신 확인: `/api/canvas/jobs/[jobId]/check-webhook` 엔드포인트 활용
- Progress 추적: VideoGenerationProgress 컴포넌트의 상태 표시 확인
- 로그 확인: video_generation_logs 테이블에서 상세 로그 조회
- Mock 모드: `NEXT_PUBLIC_MOCK_MODE=true`로 AI API 호출 없이 테스트

### Remotion 렌더링 이슈
- Remotion Studio에서 컴포지션 미리보기: `npm run remotion:studio`
- 프레임 레이트 확인: 기본 30fps 설정 (`remotion.config.ts`에서 조정 가능)
- 메모리 사용량 모니터링: 긴 영상 렌더링 시 주의
- AWS Lambda 설정: `docs/video-render-setup-guide.md` 참조
- 폰트 로딩 이슈: `./scripts/download-all-fonts.sh` 실행하여 필요한 폰트 다운로드
- Lambda 함수 메모리: 3008MB (최대), 타임아웃: 15분 설정

## 추가 설정 파일
- `remotion.config.ts` - Remotion 렌더링 설정 (코덱, 비트레이트, Lambda 설정)
- `vitest.config.ts` - 테스트 환경 설정 (jsdom, React Testing Library)
- `eslint.config.mjs` - ESLint 설정 (Next.js 코어 웹 바이탈 규칙)
- `scripts/download-all-fonts.sh` - Google Fonts에서 프로젝트 폰트 다운로드

## Cursor Rules 통합
프로젝트는 다음 Cursor Rules를 포함합니다:
- `.cursor/rules/canvas-implementation-guide.mdc` - Canvas 페이지 구현 가이드
  - 4 슬롯 시스템 상태 관리
  - 이미지 업로드 및 효과 선택 플로우
  - Job 기반 비동기 영상 생성 패턴
</file>

<file path="package.json">
{
  "name": "my-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "dev:turbo": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest",
    "test:run": "vitest run",
    "test:font-render": "tsx scripts/test-font-render.ts",
    "remotion:studio": "remotion studio src/remotion/index.ts",
    "remotion:render": "remotion render src/remotion/index.ts video-mobile",
    "remotion:lambda:deploy": "remotion lambda functions deploy",
    "remotion:lambda:sites": "remotion lambda sites create src/remotion/index.ts --site-name=voguedrop"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.0.0",
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@fal-ai/serverless-client": "^0.15.0",
    "@radix-ui/react-slider": "^1.3.5",
    "@radix-ui/react-slot": "^1.2.3",
    "@remotion/bundler": "^4.0.332",
    "@remotion/cli": "^4.0.332",
    "@remotion/fonts": "^4.0.332",
    "@remotion/lambda": "^4.0.332",
    "@remotion/player": "^4.0.332",
    "@remotion/renderer": "^4.0.332",
    "@remotion/tailwind": "^4.0.332",
    "@stagewise-plugins/react": "^0.6.2",
    "@stagewise/toolbar-next": "^0.6.2",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "^2.52.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "lucide-react": "^0.525.0",
    "nanoid": "^5.1.5",
    "next": "15.2.4",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "remotion": "^4.0.332",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/forms": "^0.5.10",
    "@testing-library/jest-dom": "^6.6.4",
    "@testing-library/react": "^16.3.0",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.7.0",
    "autoprefixer": "^10.4.21",
    "dotenv": "^17.2.1",
    "eslint": "^9",
    "eslint-config-next": "15.2.4",
    "jsdom": "^26.1.0",
    "postcss": "^8.5.6",
    "prettier": "^3.6.2",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.20.4",
    "typescript": "^5",
    "vitest": "^3.2.4"
  }
}
</file>

<file path="app/video-editor/_components/FullscreenPreviewModal.tsx">
'use client';

import { useRef, useMemo, useCallback } from 'react';
import { Player, PlayerRef, RenderPoster } from '@remotion/player';
import { CompositePreview } from './remotion/CompositePreview';
import { PlayerControls } from './PlayerControls';
import { BufferingSpinner } from './BufferingSpinner';
import { useRemotionPlayer } from '../_hooks/useRemotionPlayer';
import { TextClip as TextClipType, SoundClip as SoundClipType } from '@/types/video-editor';

interface PreviewClip {
  id: string;
  thumbnail?: string;
  url?: string;
  duration: number;
  thumbnails?: number;
  position?: number;
  title?: string;
  maxDuration?: number;
  startTime?: number;
  endTime?: number;
}

interface FullscreenPreviewModalProps {
  isOpen: boolean;
  onClose: () => void;
  clips: PreviewClip[];
  textClips?: TextClipType[];
  soundClips?: SoundClipType[];
  aspectRatio?: '9:16' | '1:1' | '16:9';
  videoWidth?: number;
  videoHeight?: number;
}

export default function FullscreenPreviewModal({
  isOpen,
  onClose,
  clips,
  textClips = [],
  soundClips = [],
  aspectRatio = '9:16',
  videoWidth = 1080,
  videoHeight = 1920
}: FullscreenPreviewModalProps) {
  const playerRef = useRef<PlayerRef | null>(null);
  
  // 총 프레임 계산 (픽셀 기반 - 40px = 1초 = 30프레임)
  const calculateTotalFrames = useMemo(() => {
    // 각 트랙의 끝 위치 계산 (position + duration)
    const videoEnd = clips.length > 0 
      ? Math.max(...clips.map(c => (c.position || 0) + c.duration))
      : 0;
    const textEnd = textClips.length > 0
      ? Math.max(...textClips.map(c => (c.position || 0) + c.duration))
      : 0;
    const soundEnd = soundClips.length > 0
      ? Math.max(...soundClips.map(c => (c.position || 0) + c.duration))
      : 0;
    
    // 모든 트랙 중 가장 끝 위치
    const totalPx = Math.max(videoEnd, textEnd, soundEnd);
    const totalSeconds = totalPx / 40; // 40px = 1초
    return Math.max(30, Math.round(totalSeconds * 30)); // 최소 1초(30프레임) 보장
  }, [clips, textClips, soundClips]);
  
  const totalDurationInSeconds = useMemo(() => {
    return calculateTotalFrames / 30;
  }, [calculateTotalFrames]);

  // 커스텀 훅으로 플레이어 상태 및 핸들러 관리
  const {
    isPlaying,
    currentTime,
    volume,
    isMuted,
    isReady,
    handlePlayPause,
    handleSeek,
    handleVolumeChange,
    handleMuteToggle,
  } = useRemotionPlayer({
    playerRef,
    isOpen,
    totalDurationInSeconds
  });

  // renderPoster 콜백 정의
  const renderPoster: RenderPoster = useCallback(({ isBuffering }) => {
    if (isBuffering && !isReady) {
      return <BufferingSpinner />;
    }
    return null;
  }, [isReady]);


  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-[9999] flex items-center justify-center">
      {/* 배경 오버레이 */}
      <div 
        className="absolute inset-0 bg-black/90 z-[9998]"
        onClick={onClose}
      />
      
      {/* 모달 콘텐츠 */}
      <div className="relative w-[90vw] h-[90vh] bg-gray-900 rounded-lg flex flex-col z-[9999]">
        {/* 헤더 */}
        <div className="absolute top-4 right-4 z-[10000]">
          <button
            onClick={onClose}
            className="p-2 bg-black/50 rounded-full hover:bg-black/70 transition-colors"
          >
            <i className="ri-close-line text-2xl text-white"></i>
          </button>
        </div>
        
        {/* 비디오 플레이어 영역 */}
        <div className="flex-1 flex items-center justify-center bg-black overflow-hidden">
          <div 
            className="relative h-full flex items-center justify-center"
            style={{ 
              width: '100%',
              maxWidth: aspectRatio === '16:9' ? '95%' : 
                       aspectRatio === '1:1' ? '60%' : '40%'
            }}
          >
            <Player
              ref={playerRef}
              component={CompositePreview}
              inputProps={{
                videoClips: clips,
                textClips: textClips,  // 항상 텍스트 클립 전달
                soundClips: soundClips,
                backgroundColor: 'black'
              }}
              durationInFrames={calculateTotalFrames}
              compositionWidth={videoWidth}
              compositionHeight={videoHeight}
              fps={30}
              style={{ 
                width: '100%',
                height: '100%',
                maxHeight: '85vh',
                aspectRatio: aspectRatio.replace(':', '/')
              }}
              controls={false}
              showVolumeControls={false}
              clickToPlay={false}
              doubleClickToFullscreen={false}
              loop={false}
              moveToBeginningWhenEnded={true}
              renderPoster={renderPoster}
              showPosterWhenBuffering={true}
              showPosterWhenPaused={false}  // 일시정지 시에는 포스터 표시 안함
            />
            
            {/* 로딩 오버레이 */}
            {!isReady && <BufferingSpinner isOverlay />}
          </div>
        </div>
        
        {/* 분리된 컨트롤 컴포넌트 사용 */}
        <PlayerControls
          isPlaying={isPlaying}
          currentTime={currentTime}
          duration={totalDurationInSeconds}
          volume={volume}
          isMuted={isMuted}
          isReady={isReady}
          onPlayPause={handlePlayPause}
          onSeek={handleSeek}
          onVolumeChange={handleVolumeChange}
          onMuteToggle={handleMuteToggle}
        />
      </div>
    </div>
  );
}
</file>

<file path="components/modals/LibraryModal.tsx">
import { LibraryModalBase } from '@/components/modals/library/LibraryModalBase';
import { LibraryModalConfig } from '@/types/library-modal';

interface LibraryModalProps {
  isOpen: boolean;
  onClose: () => void;
  favoriteVideos?: Set<string>;
  onToggleFavorite?: (videoId: string) => void;
}

export function LibraryModal({ 
  isOpen, 
  onClose, 
  favoriteVideos = new Set(), 
  onToggleFavorite 
}: LibraryModalProps) {
  const config: LibraryModalConfig = {
    mode: 'view',
    favorites: {
      enabled: true,
      favoriteIds: favoriteVideos,
      onToggle: onToggleFavorite || (() => {})
    },
    download: {
      enabled: true
    },
    dateFilter: {
      enabled: true
    },
    theme: {
      primaryColor: '#38f47cf9',
      buttonStyle: 'success',
      selectionColor: '#38f47cf9'
    }
  };

  return <LibraryModalBase isOpen={isOpen} onClose={onClose} config={config} />;
}
</file>

<file path="app/canvas/page.tsx">
'use client'

import React from 'react'
import { CanvasProvider } from './_context/CanvasContext'
import { CanvasLayout } from './_components/CanvasLayout'
import { EffectsDataProvider } from './_hooks/useEffectsData'

/**
 * Canvas 페이지 엔트리 포인트
 * 모든 비즈니스 로직은 Context와 컴포넌트로 분리
 * 372줄 → 20줄로 간소화 (95% 감소)
 */
export default function CanvasPage(): React.ReactElement {
  return (
    <EffectsDataProvider>
      <CanvasProvider>
        <CanvasLayout />
      </CanvasProvider>
    </EffectsDataProvider>
  )
}
</file>

<file path="app/video-editor/_utils/clip-operations.ts">
import { VideoClip, TextClip, SoundClip } from '@/types/video-editor';

// 클립 복제 함수
export function duplicateVideoClip(clip: VideoClip, allClips: VideoClip[]): VideoClip {
  // 타임라인에서 가장 뒤에 있는 클립의 끝 위치 찾기
  let maxEndPosition = 0;
  allClips.forEach(c => {
    const clipEnd = c.position + c.duration;
    if (clipEnd > maxEndPosition) {
      maxEndPosition = clipEnd;
    }
  });
  
  const newClip: VideoClip = {
    ...clip,
    id: `clip-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    position: maxEndPosition, // 타임라인의 끝에 배치
  };
  
  return newClip;
}

export function duplicateTextClip(clip: TextClip, allClips: TextClip[]): TextClip {
  // 타임라인에서 가장 뒤에 있는 클립의 끝 위치 찾기
  let maxEndPosition = 0;
  allClips.forEach(c => {
    const clipEnd = c.position + c.duration;
    if (clipEnd > maxEndPosition) {
      maxEndPosition = clipEnd;
    }
  });
  
  const newClip: TextClip = {
    ...clip,
    id: `text-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    position: maxEndPosition, // 타임라인의 끝에 배치
  };
  
  return newClip;
}

export function duplicateSoundClip(clip: SoundClip, allClips: SoundClip[]): SoundClip {
  // 타임라인에서 가장 뒤에 있는 클립의 끝 위치 찾기
  let maxEndPosition = 0;
  allClips.forEach(c => {
    const clipEnd = c.position + c.duration;
    if (clipEnd > maxEndPosition) {
      maxEndPosition = clipEnd;
    }
  });
  
  const newClip: SoundClip = {
    ...clip,
    id: `sound-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    position: maxEndPosition, // 타임라인의 끝에 배치
  };
  
  return newClip;
}

// 클립 분할 함수
export function splitVideoClip(
  clip: VideoClip, 
  splitPosition: number, // 픽셀 단위의 절대 위치
  pixelsPerSecond: number = 40
): { firstClip: VideoClip; secondClip: VideoClip } | null {
  // 분할 위치가 클립 범위 내에 있는지 확인
  const clipStart = clip.position;
  const clipEnd = clip.position + clip.duration;
  
  if (splitPosition <= clipStart || splitPosition >= clipEnd) {
    return null; // 분할 불가능
  }
  
  // 분할 지점 계산 (픽셀 단위)
  const splitPoint = splitPosition - clipStart;
  
  // 시간 계산 (초 단위)
  const originalStartTime = clip.startTime || 0;
  const originalEndTime = clip.endTime || (clip.maxDuration ? clip.maxDuration / pixelsPerSecond : clip.duration / pixelsPerSecond);
  const totalDurationInSeconds = originalEndTime - originalStartTime;
  
  // 분할 비율 계산
  const splitRatio = splitPoint / clip.duration;
  const splitTimeInSeconds = originalStartTime + (totalDurationInSeconds * splitRatio);
  
  // 첫 번째 클립
  const firstClip: VideoClip = {
    ...clip,
    duration: splitPoint,
    startTime: originalStartTime,
    endTime: splitTimeInSeconds,
  };
  
  // 두 번째 클립
  const secondClip: VideoClip = {
    ...clip,
    id: `clip-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    duration: clip.duration - splitPoint,
    position: splitPosition,
    startTime: splitTimeInSeconds,
    endTime: originalEndTime,
  };
  
  return { firstClip, secondClip };
}

export function splitTextClip(
  clip: TextClip,
  splitPosition: number
): { firstClip: TextClip; secondClip: TextClip } | null {
  const clipStart = clip.position;
  const clipEnd = clip.position + clip.duration;
  
  if (splitPosition <= clipStart || splitPosition >= clipEnd) {
    return null;
  }
  
  const splitPoint = splitPosition - clipStart;
  
  const firstClip: TextClip = {
    ...clip,
    duration: splitPoint,
  };
  
  const secondClip: TextClip = {
    ...clip,
    id: `text-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    duration: clip.duration - splitPoint,
    position: splitPosition,
  };
  
  return { firstClip, secondClip };
}

export function splitSoundClip(
  clip: SoundClip,
  splitPosition: number,
  pixelsPerSecond: number = 40
): { firstClip: SoundClip; secondClip: SoundClip } | null {
  const clipStart = clip.position;
  const clipEnd = clip.position + clip.duration;
  
  if (splitPosition <= clipStart || splitPosition >= clipEnd) {
    return null;
  }
  
  const splitPoint = splitPosition - clipStart;
  
  // Calculate time positions (similar to splitVideoClip)
  const originalStartTime = clip.startTime || 0;
  const originalEndTime = clip.endTime || (clip.maxDuration ? clip.maxDuration / pixelsPerSecond : clip.duration / pixelsPerSecond);
  const totalDurationInSeconds = originalEndTime - originalStartTime;
  
  // Calculate the split time within the original audio
  const splitRatio = splitPoint / clip.duration;
  const splitTimeInSeconds = originalStartTime + (totalDurationInSeconds * splitRatio);
  
  const firstClip: SoundClip = {
    ...clip,
    duration: splitPoint,
    startTime: originalStartTime,
    endTime: splitTimeInSeconds,
  };
  
  const secondClip: SoundClip = {
    ...clip,
    id: `sound-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    duration: clip.duration - splitPoint,
    position: splitPosition,
    startTime: splitTimeInSeconds,
    endTime: originalEndTime,
  };
  
  return { firstClip, secondClip };
}

/**
 * 리사이즈 시 트리밍 시작/끝 시간을 일관된 규칙으로 갱신합니다.
 * - 왼쪽 핸들: startTime만 이동, endTime은 정의되어 있으면 유지합니다
 * - 오른쪽 핸들: endTime = startTime + (duration_px / pixelsPerSecond)
 */
export function applyResizeTrim<T extends { duration: number; startTime?: number; endTime?: number }>(
  clip: T,
  newDurationPx: number,
  handle?: 'left' | 'right',
  deltaPositionPx?: number,
  pixelsPerSecond: number = 40
): Partial<T> {
  // 안전장치: 최소 너비 보장
  const safeDuration = Math.max(80, newDurationPx);
  
  // duration은 px 단위로 유지 (타임라인과 동일 단위)
  const updates: Partial<T> = { duration: safeDuration } as Partial<T>;

  if (handle === 'left' && typeof deltaPositionPx === 'number') {
    const deltaSeconds = deltaPositionPx / pixelsPerSecond;
    const currentStart = clip.startTime ?? 0;
    const newStart = Math.max(0, currentStart + deltaSeconds);
    (updates as Record<string, unknown>).startTime = newStart;
    // 새로운 duration에 맞춰 endTime 재계산 (일관된 구간 길이 유지)
    const durationSeconds = safeDuration / pixelsPerSecond;
    (updates as Record<string, unknown>).endTime = newStart + durationSeconds;
  } else if (handle === 'right') {
    const currentStart = clip.startTime ?? 0;
    const durationSeconds = safeDuration / pixelsPerSecond;
    (updates as Record<string, unknown>).endTime = currentStart + durationSeconds;
  }

  return updates;
}

// 플레이헤드 위치에서 클립 찾기
export function findClipAtPosition<T extends { position: number; duration: number }>(
  clips: T[],
  position: number
): T | null {
  return clips.find(clip => 
    position >= clip.position && 
    position < clip.position + clip.duration
  ) || null;
}
</file>

<file path="src/remotion/VideoComposition.tsx">
import React from 'react';
import { Composition } from 'remotion';
import { CompositePreview } from '../../app/video-editor/_components/remotion/CompositePreview';
import { TextClip as TextClipType, SoundClip as SoundClipType } from '@/types/video-editor';
// CSS import 제거 - inject-fonts.ts에서 처리

interface VideoClip {
  id: string;
  duration: number;
  position?: number;
  url?: string;
  title?: string;
  startTime?: number;
  endTime?: number;
}

export interface VideoCompositionProps {
  videoClips: VideoClip[];
  textClips: TextClipType[];
  soundClips: SoundClipType[];
  backgroundColor?: string;
  width: number;
  height: number;
  fps: number;
  durationInFrames: number;
}

// 메인 비디오 컴포지션
export const VideoComposition: React.FC = () => {
  return (
    <>
      {/* 9:16 - 모바일 세로 */}
      <Composition
        id="video-mobile"
        component={CompositePreview as unknown as React.ComponentType<Record<string, unknown>>}
        durationInFrames={3600} // 120초(2분) 기본값 - Lambda 렌더링 시 frameRange로 실제 필요한 부분만 렌더링
        fps={30}
        width={1080}
        height={1920}
        defaultProps={{
          videoClips: [],
          textClips: [],
          soundClips: [],
          backgroundColor: 'black',
        }}
      />
      
      {/* 1:1 - 정사각형 */}
      <Composition
        id="video-square"
        component={CompositePreview as unknown as React.ComponentType<Record<string, unknown>>}
        durationInFrames={3600} // 120초(2분) 기본값 - Lambda 렌더링 시 frameRange로 실제 필요한 부분만 렌더링
        fps={30}
        width={1080}
        height={1080}
        defaultProps={{
          videoClips: [],
          textClips: [],
          soundClips: [],
          backgroundColor: 'black',
        }}
      />
      
      {/* 16:9 - 가로 */}
      <Composition
        id="video-wide"
        component={CompositePreview as unknown as React.ComponentType<Record<string, unknown>>}
        durationInFrames={3600} // 120초(2분) 기본값 - Lambda 렌더링 시 frameRange로 실제 필요한 부분만 렌더링
        fps={30}
        width={1920}
        height={1080}
        defaultProps={{
          videoClips: [],
          textClips: [],
          soundClips: [],
          backgroundColor: 'black',
        }}
      />
    </>
  );
};
</file>

<file path="app/api/video/render/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';
import { renderMediaOnLambda, getRenderProgress } from '@remotion/lambda';
import { AwsRegion } from '@remotion/lambda';
import { RENDER_CONFIG } from '@/remotion.config';

interface RenderRequest {
  videoClips: unknown[];
  textClips: unknown[];
  soundClips: unknown[];
  aspectRatio: '9:16' | '1:1' | '16:9';
  durationInFrames: number;
  projectName?: string;
  contentHash?: string; // content hash 추가
  projectSaveId?: number; // project save ID 추가
}

// 화면 비율에 따른 컴포지션 ID 매핑
const getCompositionId = (aspectRatio: string): string => {
  switch (aspectRatio) {
    case '9:16':
      return 'video-mobile';
    case '1:1':
      return 'video-square';
    case '16:9':
      return 'video-wide';
    default:
      return 'video-mobile';
  }
};

export async function POST(request: NextRequest) {
  try {
    // 인증 확인
    const supabase = await createClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // 요청 데이터 파싱
    const body: RenderRequest = await request.json();
    const { videoClips, textClips, soundClips, aspectRatio, durationInFrames, projectName, contentHash, projectSaveId } = body;

    // 유효성 검사
    if (!videoClips || videoClips.length === 0) {
      return NextResponse.json(
        { error: 'At least one video clip is required' },
        { status: 400 }
      );
    }

    if (!aspectRatio || !['9:16', '1:1', '16:9'].includes(aspectRatio)) {
      return NextResponse.json(
        { error: 'Invalid aspect ratio' },
        { status: 400 }
      );
    }

    if (!durationInFrames || durationInFrames <= 0) {
      return NextResponse.json(
        { error: 'Invalid duration' },
        { status: 400 }
      );
    }

    // 최대 duration 제한 (2분 = 3600 프레임)
    const MAX_DURATION_FRAMES = 3600;
    if (durationInFrames > MAX_DURATION_FRAMES) {
      return NextResponse.json(
        { 
          error: 'Duration exceeds maximum limit',
          details: `Maximum allowed duration is ${MAX_DURATION_FRAMES / 30} seconds (${MAX_DURATION_FRAMES} frames)`
        },
        { status: 400 }
      );
    }

    console.log('Starting render request:', {
      userId: user.id,
      clipCount: videoClips.length,
      textClips: textClips.length,
      soundClips: soundClips.length,
      aspectRatio,
      durationInFrames,
      durationInSeconds: durationInFrames / 30,
    });

    // Lambda에서 직접 렌더링
    const compositionId = getCompositionId(aspectRatio);
    const region = (process.env.AWS_REGION || 'us-east-1') as AwsRegion;
    const functionName = process.env.LAMBDA_FUNCTION_NAME || 'remotion-render-us-east-1';
    const serveUrl = process.env.REMOTION_SERVE_URL;

    if (!serveUrl) {
      throw new Error('REMOTION_SERVE_URL is not configured');
    }

    // 출력 파일명 생성
    const outputKey = `${user.id}/${Date.now()}/video.mp4`;

    console.log('Invoking Lambda render:', {
      compositionId,
      functionName,
      region,
      outputKey,
    });

    // Lambda에서 비디오 렌더링
    const result = await renderMediaOnLambda({
      region,
      functionName,
      composition: compositionId,
      serveUrl,
      codec: RENDER_CONFIG.codec,
      imageFormat: RENDER_CONFIG.imageFormat,
      jpegQuality: RENDER_CONFIG.jpegQuality,
      audioCodec: RENDER_CONFIG.audioCodec,
      videoBitrate: RENDER_CONFIG.videoBitrate,
      audioBitrate: RENDER_CONFIG.audioBitrate,
      chromiumOptions: RENDER_CONFIG.chromiumOptions,
      inputProps: {
        videoClips,
        textClips,
        soundClips,
        backgroundColor: 'black',
      },
      outName: outputKey,
      privacy: 'public',
      downloadBehavior: {
        type: 'download',
        fileName: `video-${Date.now()}.mp4`,
      },
      framesPerLambda: 150, // 3초씩 나누어 처리 (10초 = 3-4개 Lambda)
      timeoutInMilliseconds: RENDER_CONFIG.timeoutInMilliseconds,
      maxRetries: RENDER_CONFIG.maxRetries,
      overwrite: true,
      // Composition의 기본 durationInFrames를 오버라이드
      frameRange: [0, durationInFrames - 1],
    });

    console.log('Lambda render started:', {
      renderId: result.renderId,
      bucketName: result.bucketName,
    });

    // 렌더링 기록 저장 (content_hash와 project_save_id 포함)
    const { data: renderRecord, error: dbError } = await supabase
      .from('video_renders')
      .insert({
        user_id: user.id,
        project_name: projectName || `Video-${new Date().toISOString().split('T')[0]}`,
        render_id: result.renderId,
        status: 'processing',
        aspect_ratio: aspectRatio,
        duration_frames: durationInFrames,
        output_url: null,
        content_hash: contentHash || null, // content hash 저장
        project_save_id: projectSaveId || null, // project save ID 저장
        video_clips: videoClips,
        text_clips: textClips,
        sound_clips: soundClips,
        created_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (dbError) {
      console.error('Database insert error:', dbError);
      // DB 에러는 무시하고 계속 진행
    } else if (renderRecord && projectSaveId) {
      // video_renders 레코드가 성공적으로 생성되었고 projectSaveId가 있으면
      // project_saves 테이블의 latest_render_id를 업데이트
      const { error: updateError } = await supabase
        .from('project_saves')
        .update({ 
          latest_render_id: result.renderId,
          updated_at: new Date().toISOString()
        })
        .eq('id', projectSaveId)
        .eq('user_id', user.id); // 추가 보안을 위해 user_id도 확인

      if (updateError) {
        console.error('Failed to update project_saves with render_id:', updateError);
      }
    }

    // 즉시 renderId와 함께 응답 반환 (진행 상황은 클라이언트에서 확인)
    // 이렇게 하면 Lambda 동시 실행 제한을 피할 수 있습니다
    return NextResponse.json({
      success: true,
      renderId: result.renderId,
      bucketName: result.bucketName,
      status: 'processing',
      message: '렌더링이 시작되었습니다. 잠시 후 진행 상황을 확인해주세요.',
    });
  } catch (error) {
    console.error('Render API error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to start render',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

// 렌더링 상태 확인 엔드포인트
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const renderId = searchParams.get('renderId');
    
    if (!renderId) {
      return NextResponse.json(
        { error: 'renderId is required' },
        { status: 400 }
      );
    }

    const region = (process.env.AWS_REGION || 'us-east-1') as AwsRegion;
    const functionName = process.env.LAMBDA_FUNCTION_NAME || 'remotion-render-us-east-1';
    const bucketName = searchParams.get('bucketName') || process.env.AWS_S3_BUCKET_NAME || 'voguedrop-renders';

    // Lambda에서 렌더링 진행 상황 확인
    const progress = await getRenderProgress({
      renderId,
      bucketName,
      functionName,
      region,
    });

    // DB 상태 업데이트 (선택적)
    if (progress.done && progress.outputFile) {
      try {
        const supabase = await createClient();
        await supabase
          .from('video_renders')
          .update({
            status: 'completed',
            output_url: progress.outputFile,
            completed_at: new Date().toISOString(),
          })
          .eq('render_id', renderId);
      } catch (dbError) {
        console.error('Database update error:', dbError);
      }
    }

    return NextResponse.json({
      success: true,
      done: progress.done,
      overallProgress: progress.overallProgress,
      outputFile: progress.outputFile,
      errors: progress.errors,
    });
  } catch (error) {
    console.error('Status check error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to check render status',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
</file>

<file path="app/video-editor/_components/TextClip.tsx">
'use client';

import { useRef } from 'react';
import { TextClip as TextClipType } from '@/types/video-editor';

interface TextClipProps {
  clip: TextClipType;
  onEdit?: (clip: TextClipType) => void;
  onDelete?: (id: string) => void;
  onResizeStart?: (e: React.MouseEvent, handle: 'left' | 'right') => void;
  isActive?: boolean;
  clipWidth?: number;
}

export default function TextClip({
  clip,
  onEdit,
  onResizeStart,
  isActive = false,
  clipWidth = 100,
}: TextClipProps) {
  const clipRef = useRef<HTMLDivElement>(null);

  const handleDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (onEdit) {
      onEdit(clip);
    }
  };

  const getEffectClass = () => {
    switch (clip.effect) {
      case 'pulse': return 'animate-pulse';
      case 'bounce': return 'animate-bounce';
      case 'spin': return 'animate-spin';
      default: return '';
    }
  };

  const getEffectStyle = () => {
    if (clip.effect === 'gradient') {
      return {
        background: 'linear-gradient(45deg, #38f47c, #3b82f6)',
        WebkitBackgroundClip: 'text',
        WebkitTextFillColor: 'transparent',
      };
    }
    if (clip.effect === 'glow') {
      return {
        textShadow: '0 0 10px rgba(56, 244, 124, 0.8)',
      };
    }
    return {};
  };

  const showText = clipWidth > 30; // 30px 이하면 텍스트 숨김
  const showIcon = clipWidth > 20; // 20px 이하면 아이콘도 숨김

  return (
    <div
      ref={clipRef}
      className={`group relative w-full h-full ${isActive ? 'z-10' : ''}`}
      onDoubleClick={handleDoubleClick}
    >
      <div className={`w-full h-5 bg-purple-900/50 backdrop-blur-sm rounded cursor-move hover:bg-purple-900/60 transition-colors ${
        isActive ? 'ring-2 ring-[#38f47cf9]' : ''
      }`}>
        <div className="absolute inset-0 flex items-center px-1 overflow-hidden">
          {showIcon && (
            <div className="flex items-center gap-1 w-full">
              <i className="ri-text text-[10px] text-purple-300 flex-shrink-0"></i>
              {showText && (
                <span 
                  className={`text-[10px] text-white truncate ${getEffectClass()}`}
                  style={{
                    ...getEffectStyle(),
                    color: clip.effect === 'gradient' ? undefined : clip.style.color,
                  }}
                >
                  {clip.content}
                </span>
              )}
            </div>
          )}
        </div>
        
        {/* Resize handles - 줌 레벨에 따라 크기 조정 */}
        <div
          className={`absolute inset-y-0 left-0 bg-purple-500 rounded-l cursor-ew-resize resize-handle ${
            clipWidth < 50 ? 'w-0.5' : 'w-1'
          }`}
          onMouseDown={(e) => onResizeStart?.(e, 'left')}
        />
        <div
          className={`absolute inset-y-0 right-0 bg-purple-500 rounded-r cursor-ew-resize resize-handle ${
            clipWidth < 50 ? 'w-0.5' : 'w-1'
          }`}
          onMouseDown={(e) => onResizeStart?.(e, 'right')}
        />
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/TextEditorModal.tsx">
'use client';

import { useState, useEffect } from 'react';
import { X } from 'lucide-react';
import { TextClip, TextStyle, TextEffect } from '@/types/video-editor';
import { TEXT_DEFAULTS, FONT_SIZE_PRESETS, pixelsToRatio } from '../../../constants/text-editor';
import { FONT_FAMILIES } from '../../../constants/fonts';

interface TextEditorModalProps {
  isOpen: boolean;
  onClose: () => void;
  onAddText: (text: Partial<TextClip>) => void;
  editingClip?: TextClip;
}

// constants/fonts의 FONT_FAMILIES 사용
const fontFamilies = FONT_FAMILIES;

const presetColors = [
  '#000000',
  '#FFFFFF',
  '#38f47cf9',
  '#3b82f6',
  '#a855f7',
  '#ec4899',
  '#f97316',
  '#eab308',
  '#22c55e',
];

const textEffects: { value: TextEffect; label: string; className?: string }[] = [
  { value: 'none', label: 'None' },
  // Original effects
  { value: 'pulse', label: 'Pulse', className: 'text-pulse' },
  { value: 'bounce', label: 'Bounce', className: 'text-bounce' },
  { value: 'gradient', label: 'Gradient', className: 'text-gradient' },
  { value: 'spin', label: 'Spin', className: 'text-spin' },
  { value: 'shake', label: 'Shake', className: 'text-shake' },
  { value: 'slide', label: 'Slide', className: 'text-slide' },
  { value: 'fade', label: 'Fade', className: 'text-fade' },
  { value: 'typing', label: 'Typing', className: 'text-typing' },
  { value: 'glow', label: 'Glow', className: 'text-glow' },
  { value: 'wave', label: 'Wave', className: 'text-wave' },
  { value: 'zoom', label: 'Zoom', className: 'text-zoom' },
  // New 3D effects
  { value: 'flip', label: 'Flip', className: 'text-flip' },
  // Elastic effects
  { value: 'elastic', label: 'Elastic', className: 'text-elastic' },
  { value: 'rubberband', label: 'Rubberband', className: 'text-rubberband' },
  { value: 'jello', label: 'Jello', className: 'text-jello' },
  // Digital effects
  { value: 'flash', label: 'Flash', className: 'text-flash' },
  { value: 'glitch', label: 'Glitch', className: 'text-glitch' },
  // Style effects
  { value: 'neon', label: 'Neon', className: 'text-neon' },
  { value: 'shadow', label: 'Shadow', className: 'text-shadow' },
  { value: 'outline', label: 'Outline', className: 'text-outline' },
  { value: 'chrome', label: 'Chrome', className: 'text-chrome' },
  { value: 'rainbow', label: 'Rainbow', className: 'text-rainbow' },
  { value: 'fire', label: 'Fire', className: 'text-fire' },
  { value: 'ice', label: 'Ice', className: 'text-ice' },
];

export default function TextEditorModal({
  isOpen,
  onClose,
  onAddText,
  editingClip,
}: TextEditorModalProps) {
  const [content, setContent] = useState(editingClip?.content || '');
  const [style, setStyle] = useState<TextStyle>(
    editingClip?.style || {
      fontSize: TEXT_DEFAULTS.fontSize, // 호환성을 위해 유지
      fontSizeRatio: TEXT_DEFAULTS.fontSizeRatio, // 비율 추가
      fontFamily: 'default',
      color: '#FFFFFF',
      alignment: 'center',
      fontWeight: 700, // 숫자로 통일 (bold = 700)
      verticalPosition: 'middle',
      backgroundColor: '',
      backgroundOpacity: 0.7,
    }
  );
  const [selectedEffect, setSelectedEffect] = useState<TextEffect>(
    editingClip?.effect || 'none'
  );

  // 폰트 로딩 상태 확인 (디버깅용, 실제로는 CSS가 자동 로드)
  useEffect(() => {
    if (typeof window !== 'undefined' && isOpen) {
      // fonts.ready promise를 통한 로딩 완료 확인
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
          // 폰트가 모두 로드된 후 체크
          const fontFamilies = FONT_FAMILIES.filter(f => f.value !== 'default' && !f.value.includes('Arial') && !f.value.includes('Helvetica') && !f.value.includes('Times') && !f.value.includes('Georgia') && !f.value.includes('Courier'));
          
          let loadedCount = 0;
          let notLoadedCount = 0;
          
          fontFamilies.forEach(font => {
            if (document.fonts && document.fonts.check) {
              // 다양한 weight로 체크
              const loaded400 = document.fonts.check(`400 16px "${font.value}"`);
              const loaded700 = document.fonts.check(`700 16px "${font.value}"`);
              const loadedNormal = document.fonts.check(`16px "${font.value}"`);
              
              if (loaded400 || loaded700 || loadedNormal) {
                loadedCount++;
              } else {
                notLoadedCount++;
                console.warn(`Font not available: ${font.value}`);
              }
            }
          });
          
          console.log(`Fonts status - Loaded: ${loadedCount}, Not loaded: ${notLoadedCount}`);
        });
      }
    }
  }, [isOpen]);

  if (!isOpen) return null;

  const handleSubmit = () => {
    if (content.trim()) {
      const clipData: Partial<TextClip> = {
        content,
        style,
        effect: selectedEffect,
      };
      
      // 새로 추가할 때만 duration과 position 설정
      if (!editingClip) {
        clipData.duration = 200;
        clipData.position = 0;
      }
      
      onAddText(clipData);
      onClose();
      setContent('');
      setSelectedEffect('none');
    }
  };

  const getEffectStyle = (effect: TextEffect): React.CSSProperties => {
    switch (effect) {
      case 'gradient':
        return {
          backgroundImage: 'linear-gradient(90deg, #38f47c, #3b82f6, #a855f7, #ec4899, #38f47c)',
          backgroundSize: '200% auto',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text',
        } as React.CSSProperties;
      case 'glow':
        return {
          textShadow: '0 0 20px rgba(255,255,255,0.9), 0 0 40px rgba(56,244,124,0.7)',
        };
      case 'neon':
        return {
          textShadow: '0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor, 0 0 40px currentColor',
        };
      case 'shadow':
        return {
          textShadow: '3px 3px 6px rgba(0,0,0,0.5)',
        };
      case 'outline':
        return {
          WebkitTextStroke: '2px currentColor',
          WebkitTextFillColor: 'transparent',
        } as React.CSSProperties;
      case 'chrome':
        return {
          backgroundImage: 'linear-gradient(to bottom, #eee 0%, #999 50%, #777 51%, #555 100%)',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text',
          filter: 'drop-shadow(2px 2px 4px rgba(0,0,0,0.5))',
        } as React.CSSProperties;
      case 'rainbow':
        return {
          backgroundImage: 'linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)',
          backgroundSize: '200% auto',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text',
        } as React.CSSProperties;
      case 'fire':
        return {
          backgroundImage: 'linear-gradient(45deg, #ff0000, #ff4500, #ff8c00, #ffd700)',
          backgroundSize: '200% 200%',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text',
          filter: 'drop-shadow(0 0 3px #ff4500)',
        } as React.CSSProperties;
      case 'ice':
        return {
          backgroundImage: 'linear-gradient(45deg, #00ffff, #00bfff, #1e90ff, #4169e1)',
          backgroundSize: '200% 200%',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          backgroundClip: 'text',
          filter: 'drop-shadow(0 0 3px #00bfff)',
        } as React.CSSProperties;
      case 'typing':
        return {
          overflow: 'hidden',
          whiteSpace: 'nowrap',
          borderRight: '3px solid rgba(255,255,255,0.7)',
          display: 'inline-block',
          width: 'fit-content',
        };
      case 'glitch':
        return {
          position: 'relative' as const,
          display: 'inline-block',
        };
      case 'flip':
        return {
          display: 'inline-block',
          transformStyle: 'preserve-3d' as const,
          perspective: '1000px',
        };
      case 'pulse':
      case 'bounce':
      case 'spin':
      case 'wave':
      case 'zoom':
      case 'elastic':
      case 'rubberband':
      case 'jello':
      case 'flash':
        return {
          display: 'inline-block',
          transformOrigin: 'center',
        };
      default:
        return {};
    }
  };

  const getEffectClass = (effect: TextEffect) => {
    const effectItem = textEffects.find((e) => e.value === effect);
    return effectItem?.className || '';
  };

  return (
    <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center">
      <div className="bg-gray-800 rounded-lg w-[1000px] max-w-[90vw] h-[700px] max-h-[90vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-gray-700">
          <h2 className="text-xl font-medium text-white">Text Editor</h2>
          <button
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center hover:bg-gray-700 rounded-lg"
          >
            <X className="w-5 h-5 text-gray-400" />
          </button>
        </div>

        {/* Main Content - 2 Column Layout */}
        <div className="flex-1 flex overflow-hidden">
          {/* Left Panel - Editor (60%) */}
          <div className="w-3/5 p-6 space-y-4 overflow-y-auto border-r border-gray-700">
            {/* Text Content */}
            <div>
              <label className="block text-sm font-medium mb-2 text-gray-300">
                Text Content
              </label>
              <textarea
                value={content}
                onChange={(e) => setContent(e.target.value)}
                className="w-full h-20 bg-gray-900 rounded-lg p-3 text-sm text-white resize-none focus:ring-2 focus:ring-[#38f47cf9] focus:outline-none"
                placeholder="Enter your text..."
              />
            </div>

            {/* Font Style & Size - One Row */}
            <div className="flex gap-4">
              <div className="flex-1">
                <label className="block text-sm font-medium mb-2 text-gray-300">
                  Font Style
                </label>
                <select
                  value={style.fontFamily}
                  onChange={(e) => setStyle({ ...style, fontFamily: e.target.value })}
                  className="w-full bg-gray-900 rounded-lg px-3 py-2 text-sm text-white focus:ring-2 focus:ring-[#38f47cf9] focus:outline-none"
                >
                  {fontFamilies.map((font) => (
                    <option key={font.value} value={font.value}>
                      {font.label}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium mb-2 text-gray-300">
                  Font Size
                </label>
                <div className="flex flex-col gap-2">
                  {/* 크기 프리셋 버튼들 */}
                  <div className="flex gap-1">
                    {Object.entries(FONT_SIZE_PRESETS).map(([key, preset]) => {
                      const isActive = Math.abs((style.fontSizeRatio || TEXT_DEFAULTS.fontSizeRatio) - preset.ratio) < 0.005;
                      return (
                        <button
                          key={key}
                          onClick={() => {
                            const baseFontSize = Math.round(preset.ratio * 1080);
                            setStyle({ 
                              ...style, 
                              fontSize: baseFontSize,
                              fontSizeRatio: preset.ratio 
                            });
                          }}
                          className={`flex-1 px-2 py-1 text-xs rounded transition-colors ${
                            isActive 
                              ? 'bg-[#38f47cf9] text-black font-medium' 
                              : 'bg-gray-900 text-gray-300 hover:bg-gray-700'
                          }`}
                        >
                          {preset.label}
                        </button>
                      );
                    })}
                  </div>
                  {/* 미세 조정 슬라이더 */}
                  <div className="flex items-center gap-2">
                    <input
                      type="range"
                      min="0.02"
                      max="0.12"
                      step="0.002"
                      value={style.fontSizeRatio || pixelsToRatio(style.fontSize, 1080)}
                      onChange={(e) => {
                        const ratio = parseFloat(e.target.value);
                        const baseFontSize = Math.round(ratio * 1080);
                        setStyle({ 
                          ...style, 
                          fontSize: baseFontSize,
                          fontSizeRatio: ratio 
                        });
                      }}
                      className="flex-1"
                    />
                    <span className="text-xs text-gray-400 w-12 text-right">
                      {Math.round((style.fontSizeRatio || pixelsToRatio(style.fontSize, 1080)) * 1080)}px
                    </span>
                  </div>
                </div>
              </div>
            </div>

            {/* Text Color */}
            <div>
              <label className="block text-sm font-medium mb-2 text-gray-300">
                Text Color
              </label>
              <div className="flex items-center gap-3">
                <input
                  type="color"
                  value={style.color}
                  onChange={(e) => setStyle({ ...style, color: e.target.value })}
                  className="w-10 h-10 rounded cursor-pointer bg-transparent"
                />
                <div className="flex gap-2 flex-wrap">
                  {presetColors.map((color) => (
                    <button
                      key={color}
                      onClick={() => setStyle({ ...style, color })}
                      className={`w-8 h-8 rounded-full border-2 transition-all ${
                        style.color === color ? 'border-[#38f47cf9] scale-110' : 'border-transparent hover:scale-105'
                      }`}
                      style={{ backgroundColor: color }}
                    />
                  ))}
                </div>
              </div>
            </div>

            {/* Text Effects */}
            <div>
              <label className="block text-sm font-medium mb-2 text-gray-300">
                Text Effects
              </label>
              <div className="grid grid-cols-4 gap-2">
                {textEffects.map((effect) => (
                  <button
                    key={effect.value}
                    onClick={() => setSelectedEffect(effect.value)}
                    className={`px-2 py-1.5 bg-gray-900 rounded text-xs hover:bg-gray-700 transition-colors ${
                      selectedEffect === effect.value
                        ? 'ring-2 ring-[#38f47cf9] bg-gray-700'
                        : ''
                    }`}
                  >
                    {effect.label}
                  </button>
                ))}
              </div>
            </div>

            {/* Text Alignment */}
            <div>
              <label className="block text-sm font-medium mb-2 text-gray-300">
                Text Alignment
              </label>
              <div className="flex gap-2">
                <button
                  onClick={() => setStyle({ ...style, alignment: 'left' })}
                  className={`flex-1 px-3 py-2 bg-gray-900 rounded text-sm hover:bg-gray-700 transition-colors ${
                    style.alignment === 'left' ? 'bg-gray-700 ring-2 ring-[#38f47cf9]' : ''
                  }`}
                >
                  <i className="ri-align-left text-white"></i>
                </button>
                <button
                  onClick={() => setStyle({ ...style, alignment: 'center' })}
                  className={`flex-1 px-3 py-2 bg-gray-900 rounded text-sm hover:bg-gray-700 transition-colors ${
                    style.alignment === 'center' ? 'bg-gray-700 ring-2 ring-[#38f47cf9]' : ''
                  }`}
                >
                  <i className="ri-align-center text-white"></i>
                </button>
                <button
                  onClick={() => setStyle({ ...style, alignment: 'right' })}
                  className={`flex-1 px-3 py-2 bg-gray-900 rounded text-sm hover:bg-gray-700 transition-colors ${
                    style.alignment === 'right' ? 'bg-gray-700 ring-2 ring-[#38f47cf9]' : ''
                  }`}
                >
                  <i className="ri-align-right text-white"></i>
                </button>
              </div>
            </div>
          </div>

          {/* Right Panel - Preview (40%) */}
          <div className="w-2/5 p-6 bg-gray-900/50">
            <div className="h-full flex flex-col">
              <div className="mb-3">
                <label className="text-sm font-medium text-gray-300">
                  Live Preview
                </label>
              </div>
              <div className="flex-1 rounded-lg p-6 flex items-center relative overflow-hidden bg-gray-500">
                {/* Checkerboard Pattern */}
                <div className="absolute inset-0">
                  <div className="h-full w-full" style={{
                    backgroundImage: 'linear-gradient(45deg, #606060 25%, transparent 25%), linear-gradient(-45deg, #606060 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #606060 75%), linear-gradient(-45deg, transparent 75%, #606060 75%)',
                    backgroundSize: '20px 20px',
                    backgroundPosition: '0 0, 0 10px, 10px -10px, -10px 0px',
                    backgroundColor: '#505050'
                  }} />
                </div>
                
                {/* Grid overlay for better visibility */}
                <div className="absolute inset-0 opacity-5 pointer-events-none">
                  <div className="h-full w-full" style={{
                    backgroundImage: 'linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px)',
                    backgroundSize: '20px 20px'
                  }} />
                </div>
                
                {/* Preview Content */}
                <div className={`w-full flex items-center relative z-10 ${
                  style.alignment === 'left' ? 'justify-start' : 
                  style.alignment === 'right' ? 'justify-end' : 
                  'justify-center'
                }`}>
                  <div
                    className={`${getEffectClass(selectedEffect)} ${selectedEffect === 'typing' ? '' : 'w-full'}`}
                    style={{
                      fontSize: `${style.fontSize}px`,
                      fontFamily: style.fontFamily === 'default' ? 'sans-serif' : `"${style.fontFamily}", sans-serif`,
                      color: selectedEffect === 'gradient' || selectedEffect === 'rainbow' || selectedEffect === 'chrome' || selectedEffect === 'fire' || selectedEffect === 'ice' ? 'transparent' : style.color,
                      textAlign: style.alignment,
                      fontWeight: style.fontWeight,
                      ...getEffectStyle(selectedEffect),
                    }}
                  >
                    {content || 'Your text will appear here'}
                  </div>
                </div>
              </div>
              
              {/* Effect Info */}
              <div className="mt-4 p-3 bg-gray-800 rounded-lg">
                <div className="text-xs text-gray-400 space-y-1">
                  <div className="flex justify-between">
                    <span>Effect:</span>
                    <span className="text-white">{selectedEffect === 'none' ? 'None' : textEffects.find(e => e.value === selectedEffect)?.label}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Size:</span>
                    <span className="text-white">{style.fontSize}px</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Alignment:</span>
                    <span className="text-white capitalize">{style.alignment}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="p-6 border-t border-gray-700">
          <div className="flex justify-end gap-3">
            <button
              onClick={onClose}
              className="px-4 py-2 bg-gray-700 rounded-lg text-sm hover:bg-gray-600 transition-colors"
            >
              Cancel
            </button>
            <button
              onClick={handleSubmit}
              className="px-4 py-2 bg-[#38f47cf9] rounded-lg text-black text-sm font-medium hover:bg-[#38f47cf9]/80 transition-colors"
            >
              Add to Timeline
            </button>
          </div>
        </div>
      </div>

      <style jsx>{`
        @keyframes pulse {
          0%, 100% { 
            transform: scale(1); 
            opacity: 1; 
          }
          50% { 
            transform: scale(1.08); 
            opacity: 0.9; 
          }
        }
        
        @keyframes bounce {
          0%, 20%, 50%, 80%, 100% { 
            transform: translateY(0); 
          }
          40% { 
            transform: translateY(-30px); 
          }
          60% { 
            transform: translateY(-15px); 
          }
        }
        
        @keyframes gradient {
          0% { background-position: 0% center; }
          100% { background-position: 200% center; }
        }
        
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
          20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        
        @keyframes slide {
          0% { 
            transform: translateX(-100%); 
            opacity: 0; 
          }
          60% { 
            transform: translateX(10px); 
            opacity: 1; 
          }
          100% { 
            transform: translateX(0); 
            opacity: 1; 
          }
        }
        
        @keyframes fade {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }
        
        @keyframes typing {
          0%, 10% { 
            width: 0;
            border-right-color: transparent;
          }
          10.1%, 90% { 
            border-right-color: rgba(255,255,255,0.7);
          }
          90%, 100% { 
            width: 100%;
            border-right-color: transparent;
          }
        }
        
        @keyframes glow {
          0%, 100% { 
            text-shadow: 0 0 20px rgba(255,255,255,0.7), 0 0 40px rgba(56,244,124,0.5);
          }
          50% { 
            text-shadow: 0 0 30px rgba(255,255,255,0.9), 0 0 60px rgba(56,244,124,0.8);
          }
        }
        
        @keyframes wave {
          0%, 100% { 
            transform: translateY(0) rotate(0deg); 
          }
          25% { 
            transform: translateY(-5px) rotate(-2deg); 
          }
          50% { 
            transform: translateY(0) rotate(0deg); 
          }
          75% { 
            transform: translateY(-5px) rotate(2deg); 
          }
        }
        
        @keyframes zoom {
          0%, 100% { 
            transform: scale(1); 
          }
          25% { 
            transform: scale(1.1); 
          }
          50% { 
            transform: scale(1.3); 
          }
          75% { 
            transform: scale(1.1); 
          }
        }
        
        @keyframes flip {
          0% { transform: rotateY(0); }
          50% { transform: rotateY(180deg); }
          100% { transform: rotateY(360deg); }
        }
        
        @keyframes elastic {
          0%, 100% { transform: scale(1); }
          30% { transform: scale(1.25); }
          40% { transform: scale(0.75); }
          50% { transform: scale(1.15); }
          65% { transform: scale(0.95); }
          75% { transform: scale(1.05); }
        }
        
        @keyframes rubberband {
          0% { transform: scale(1); }
          30% { transform: scaleX(1.25) scaleY(0.75); }
          40% { transform: scaleX(0.75) scaleY(1.25); }
          60% { transform: scaleX(1.15) scaleY(0.85); }
          100% { transform: scale(1); }
        }
        
        @keyframes jello {
          0%, 100% { transform: skewX(0deg) skewY(0deg); }
          30% { transform: skewX(-12.5deg) skewY(-12.5deg); }
          40% { transform: skewX(6.25deg) skewY(6.25deg); }
          50% { transform: skewX(-3.125deg) skewY(-3.125deg); }
          65% { transform: skewX(1.5625deg) skewY(1.5625deg); }
        }
        
        @keyframes flash {
          0%, 50%, 100% { opacity: 1; }
          25%, 75% { opacity: 0; }
        }
        
        @keyframes glitch {
          0%, 100% { 
            text-shadow: 2px 0 #ff00ff, -2px 0 #00ffff;
            transform: translate(0);
          }
          20% {
            text-shadow: 2px 0 #ff00ff, -2px 0 #00ffff;
            transform: translate(-2px, 2px);
          }
          40% {
            text-shadow: -2px 0 #ff00ff, 2px 0 #00ffff;
            transform: translate(-2px, -2px);
          }
          60% {
            text-shadow: 2px 0 #ff00ff, -2px 0 #00ffff;
            transform: translate(2px, 2px);
          }
          80% {
            text-shadow: -2px 0 #ff00ff, 2px 0 #00ffff;
            transform: translate(2px, -2px);
          }
        }
        
        @keyframes neon {
          0%, 100% {
            text-shadow: 
              0 0 10px currentColor,
              0 0 20px currentColor,
              0 0 30px currentColor,
              0 0 40px currentColor;
          }
          50% {
            text-shadow: 
              0 0 5px currentColor,
              0 0 10px currentColor,
              0 0 15px currentColor,
              0 0 20px currentColor;
          }
        }
        
        @keyframes rainbow {
          0% { background-position: 0% center; }
          100% { background-position: 200% center; }
        }
        
        @keyframes fire {
          0%, 100% { 
            background-position: 0% 50%;
            filter: drop-shadow(0 0 3px #ff4500) brightness(1);
          }
          50% { 
            background-position: 100% 50%;
            filter: drop-shadow(0 0 8px #ff6347) brightness(1.1);
          }
        }
        
        @keyframes ice {
          0%, 100% { 
            background-position: 0% 50%;
            filter: drop-shadow(0 0 3px #00bfff) brightness(1);
          }
          50% { 
            background-position: 100% 50%;
            filter: drop-shadow(0 0 8px #87ceeb) brightness(1.1);
          }
        }

        .text-pulse {
          animation: pulse 1.5s ease-in-out infinite;
        }
        .text-bounce {
          animation: bounce 1.5s ease-in-out infinite;
        }
        .text-gradient {
          animation: gradient 3s linear infinite;
        }
        .text-spin {
          animation: spin 3s linear infinite;
        }
        .text-shake {
          animation: shake 0.3s ease-in-out infinite;
        }
        .text-slide {
          animation: slide 2s ease-in-out infinite;
        }
        .text-fade {
          animation: fade 2s ease-in-out infinite;
        }
        .text-typing {
          animation: typing 4s steps(40, end) infinite;
        }
        .text-glow {
          animation: glow 2s ease-in-out infinite;
        }
        .text-wave {
          animation: wave 2s ease-in-out infinite;
        }
        .text-zoom {
          animation: zoom 2s ease-in-out infinite;
        }
        .text-flip {
          animation: flip 3s ease-in-out infinite;
        }
        .text-elastic {
          animation: elastic 1.5s ease-in-out infinite;
        }
        .text-rubberband {
          animation: rubberband 1s ease-in-out infinite;
        }
        .text-jello {
          animation: jello 1s ease-in-out infinite;
        }
        .text-flash {
          animation: flash 1s ease-in-out infinite;
        }
        .text-glitch {
          animation: glitch 1s ease-in-out infinite;
        }
        .text-neon {
          animation: neon 1.5s ease-in-out infinite;
        }
        .text-shadow {
          text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        .text-outline {
          -webkit-text-stroke: 2px currentColor;
          -webkit-text-fill-color: transparent;
        }
        .text-chrome {
          background-image: linear-gradient(to bottom, #eee 0%, #999 50%, #777 51%, #555 100%);
          -webkit-background-clip: text;
          -webkit-text-fill-color: transparent;
          background-clip: text;
          filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.5));
        }
        .text-rainbow {
          animation: rainbow 3s linear infinite;
        }
        .text-fire {
          animation: fire 2s ease-in-out infinite;
        }
        .text-ice {
          animation: ice 2s ease-in-out infinite;
        }
      `}</style>
    </div>
  );
}
</file>

<file path="app/video-editor/_utils/timeline-utils.ts">
/**
 * Timeline utility functions for clip manipulation
 */

export interface BaseClip {
  id: string;
  duration: number;
  position: number;
  maxDuration?: number;
}

/**
 * Snap position to grid (e.g., 1-second intervals)
 * @param position Current position in pixels
 * @param gridSize Grid size in pixels (e.g., 40px = 1 second)
 * @returns Snapped position
 */
export const snapToGrid = (position: number, gridSize: number): number => {
  return Math.round(position / gridSize) * gridSize;
};

/**
 * Check if a clip would overlap with other clips
 * @param clips Array of clips to check against
 * @param clipId ID of the clip being moved
 * @param newPosition New position for the clip
 * @param duration Duration of the clip
 * @returns true if there's an overlap
 */
export const checkClipOverlap = <T extends BaseClip>(
  clips: T[],
  clipId: string,
  newPosition: number,
  duration: number
): boolean => {
  return clips.some(clip => 
    clip.id !== clipId &&
    newPosition < clip.position + clip.duration &&
    newPosition + duration > clip.position
  );
};

/**
 * Validate clip position and duration
 * @param position Clip position
 * @param duration Current duration
 * @param maxDuration Maximum allowed duration
 * @returns Valid duration
 */
export const validateClipDuration = (
  duration: number,
  maxDuration?: number
): number => {
  const minDuration = 80; // Minimum clip width in pixels
  let validDuration = Math.max(minDuration, duration);
  
  if (maxDuration !== undefined && maxDuration > 0) {
    validDuration = Math.min(validDuration, maxDuration);
  }
  
  return validDuration;
};

/**
 * Calculate valid position for a clip
 * @param position Requested position
 * @param duration Clip duration
 * @param timelineWidth Total timeline width
 * @returns Valid position
 */
export const validateClipPosition = (
  position: number,
  duration: number,
  timelineWidth?: number
): number => {
  // Ensure position is not negative
  let validPosition = Math.max(0, position);
  
  // If timeline width is provided, ensure clip doesn't go beyond timeline
  if (timelineWidth !== undefined && timelineWidth > 0) {
    const maxPosition = Math.max(0, timelineWidth - duration);
    validPosition = Math.min(validPosition, maxPosition);
  }
  
  return validPosition;
};

/**
 * Get the next available position after existing clips
 * @param clips Array of clips
 * @returns Next available position
 */
export const getNextAvailablePosition = <T extends BaseClip>(
  clips: T[]
): number => {
  if (clips.length === 0) return 0;
  
  const lastClipEnd = Math.max(
    ...clips.map(clip => clip.position + clip.duration)
  );
  
  return lastClipEnd; // No gap between clips
};

/**
 * Find a gap where a clip can fit
 * @param clips Array of clips sorted by position
 * @param duration Duration of clip to place
 * @param preferredPosition Preferred position (will find nearest valid position)
 * @returns Valid position or null if no space
 */
export const findAvailablePosition = <T extends BaseClip>(
  clips: T[],
  duration: number,
  preferredPosition: number = 0
): number | null => {
  // Sort clips by position
  const sortedClips = [...clips].sort((a, b) => a.position - b.position);
  
  // Check if preferred position is available
  const hasOverlap = checkClipOverlap(clips, '', preferredPosition, duration);
  if (!hasOverlap) {
    return Math.max(0, preferredPosition);
  }
  
  // Find first available gap
  let currentPosition = 0;
  
  for (const clip of sortedClips) {
    if (currentPosition + duration <= clip.position) {
      return currentPosition;
    }
    currentPosition = clip.position + clip.duration; // No gap between clips
  }
  
  return currentPosition;
};

/**
 * Get clip at position (for click selection)
 * @param clips Array of clips
 * @param clickPosition Click position in pixels
 * @returns Clip at position or null
 */
export const getClipAtPosition = <T extends BaseClip>(
  clips: T[],
  clickPosition: number
): T | null => {
  return clips.find(clip => 
    clickPosition >= clip.position &&
    clickPosition <= clip.position + clip.duration
  ) || null;
};

/**
 * Find available position for new clip without overlap
 * @param clips Array of existing clips
 * @param startPosition Starting position to search from
 * @param duration Duration of the new clip
 * @param gridSize Grid size for snapping (e.g., 40px = 1 second)
 * @returns Available position without overlap
 */
export const findNonOverlappingPosition = <T extends BaseClip>(
  clips: T[],
  startPosition: number,
  duration: number,
  gridSize: number
): number => {
  let position = startPosition;
  
  // Keep moving right until we find a position without overlap
  while (clips.some(clip =>
    position < clip.position + clip.duration &&
    position + duration > clip.position
  )) {
    position += gridSize; // Move by grid size (1 second)
  }
  
  return position;
};

/**
 * Get the next position for adding a new clip
 * @param clips Array of existing clips
 * @param currentTime Current playhead time in seconds
 * @param pixelsPerSecond Pixels per second ratio
 * @returns Next position for the new clip
 */
export const getNextPosition = <T extends BaseClip>(
  clips: T[],
  currentTime: number,
  pixelsPerSecond: number
): number => {
  if (clips.length === 0) return 0;
  
  if (currentTime > 0) {
    // Use playhead position when it's not at the start
    return currentTime * pixelsPerSecond;
  } else {
    // Place after the last clip when playhead is at 0
    return clips.reduce((max, clip) => {
      const clipEnd = clip.position + clip.duration;
      return Math.max(max, clipEnd);
    }, 0);
  }
};

/**
 * Find non-overlapping position based on drag direction
 * @param clips Array of existing clips (excluding the dragged clip)
 * @param requestedPosition The position where user wants to place the clip
 * @param duration Duration of the clip being placed
 * @param dragDirection Direction of the drag ('left' or 'right')
 * @param gridSize Grid size for snapping
 * @returns Non-overlapping position based on drag direction
 */
export const findNonOverlappingPositionWithDirection = <T extends BaseClip>(
  clips: T[],
  requestedPosition: number,
  duration: number
): number => {
  
  // 겹침을 허용할 최소 threshold (픽셀)
  const OVERLAP_THRESHOLD = 20; // 20픽셀 이상 겹쳐야 자동 재배치
  
  // Find overlapping clips
  const overlappingClips = clips.filter(clip => {
    const clipStart = clip.position;
    const clipEnd = clip.position + clip.duration;
    const draggedStart = requestedPosition;
    const draggedEnd = requestedPosition + duration;
    
    // 겹침 체크
    if (draggedStart < clipEnd && draggedEnd > clipStart) {
      // 겹침 정도 계산
      const overlapStart = Math.max(draggedStart, clipStart);
      const overlapEnd = Math.min(draggedEnd, clipEnd);
      const overlapAmount = overlapEnd - overlapStart;
      
      // threshold 이상 겹칠 때만 재배치 대상
      return overlapAmount > OVERLAP_THRESHOLD;
    }
    return false;
  });
  
  if (overlappingClips.length === 0) {
    // No significant overlap, place at requested position
    return Math.max(0, requestedPosition);
  }
  
  // 드래그된 클립의 중심점
  const draggedCenter = requestedPosition + (duration / 2);
  
  // 겹치는 클립들 중 가장 가까운 클립 찾기
  const closestClip = overlappingClips.reduce((closest, clip) => {
    const clipCenter = clip.position + (clip.duration / 2);
    const closestCenter = closest.position + (closest.duration / 2);
    
    const distToCurrent = Math.abs(draggedCenter - clipCenter);
    const distToClosest = Math.abs(draggedCenter - closestCenter);
    
    return distToCurrent < distToClosest ? clip : closest;
  });
  
  // 가장 가까운 클립의 중심과 비교하여 배치 위치 결정
  const targetClipCenter = closestClip.position + (closestClip.duration / 2);
  
  if (draggedCenter > targetClipCenter) {
    // 드래그한 클립의 중심이 타겟 클립보다 오른쪽 → 오른쪽에 배치
    const finalPos = closestClip.position + closestClip.duration;
    return finalPos;
  } else {
    // 드래그한 클립의 중심이 타겟 클립보다 왼쪽 → 왼쪽에 배치
    const leftPosition = closestClip.position - duration;
    
    // 음수 위치가 되면 오른쪽에 배치
    if (leftPosition < 0) {
      const finalPos = closestClip.position + closestClip.duration;
      return finalPos;
    }
    return leftPosition;
  }
};

/**
 * Magnetic positioning - automatically positions clips with smart insertion
 * @param clips Array of all clips (including the one being dragged)
 * @param draggedClipId ID of the clip being dragged
 * @param requestedPosition Position where the clip is being placed
 * @param duration Duration of the clip being placed
 * @returns Target position and adjusted clips array
 */
export const magneticPositioning = <T extends BaseClip>(
  clips: T[],
  draggedClipId: string,
  requestedPosition: number,
  duration: number
): { targetPosition: number; adjustedClips: T[] } => {
  // 드래그된 클립 제외한 클립들을 position 순으로 정렬
  const otherClips = clips.filter(c => c.id !== draggedClipId);
  const sortedClips = [...otherClips].sort((a, b) => a.position - b.position);
  
  // 클립이 없으면 그냥 요청 위치에 배치
  if (sortedClips.length === 0) {
    return { targetPosition: Math.max(0, requestedPosition), adjustedClips: [] };
  }
  
  // 드래그된 클립의 중심과 끝점
  const draggedCenter = requestedPosition + (duration / 2);
  const draggedEnd = requestedPosition + duration;
  
  // 1. 두 클립 사이에 있는지 확인
  for (let i = 0; i < sortedClips.length - 1; i++) {
    const leftClip = sortedClips[i];
    const rightClip = sortedClips[i + 1];
    
    const leftEnd = leftClip.position + leftClip.duration;
    const rightStart = rightClip.position;
    
    // 드래그한 클립이 두 클립 사이 공간과 관련이 있는지 확인
    // 더 넓은 범위로 감지: 중심이 사이에 있거나, 클립의 일부가 사이 공간과 겹치는 경우
    const isInBetween = 
      (draggedCenter >= leftEnd && draggedCenter <= rightStart) || // 중심이 사이에
      (requestedPosition >= leftEnd && requestedPosition <= rightStart) || // 시작이 사이에
      (draggedEnd >= leftEnd && draggedEnd <= rightStart) || // 끝이 사이에
      (requestedPosition <= leftEnd && draggedEnd >= rightStart); // 공간을 완전히 덮음
    
    if (isInBetween) {
      const gap = rightStart - leftEnd;
      
      console.log('클립 사이 감지:', {
        왼쪽클립끝: leftEnd,
        오른쪽클립시작: rightStart,
        간격: gap,
        필요공간: duration,
        요청위치: requestedPosition
      });
      
      if (gap >= duration) {
        // 공간이 충분하면 사용자가 드래그한 위치에 배치
        // 단, 왼쪽 클립과 겹치지 않고 오른쪽 클립과도 겹치지 않도록 조정
        let finalPosition = requestedPosition;
        
        // 왼쪽 클립과 겹치는 경우 조정
        if (finalPosition < leftEnd) {
          finalPosition = leftEnd;
        }
        
        // 오른쪽 클립과 겹치는 경우 조정
        if (finalPosition + duration > rightStart) {
          finalPosition = rightStart - duration;
        }
        
        console.log('공간 충분 - 사용자 위치에 배치:', finalPosition);
        return {
          targetPosition: finalPosition,
          adjustedClips: otherClips
        };
      } else {
        // 공간이 부족하면 오른쪽 클립들을 밀어내되, 연속적으로 재배치
        const insertPosition = leftEnd; // 삽입 위치는 왼쪽 클립 끝
        const pushAmount = duration; // 삽입할 클립의 길이만큼 공간 필요
        
        console.log('공간 부족 - 오른쪽 클립들 연속 재배치:', {
          삽입위치: insertPosition,
          필요공간: pushAmount
        });
        
        // 오른쪽 클립들을 연속적으로 재배치
        let currentPosition = insertPosition + duration; // 삽입될 클립 다음 위치
        const adjustedClips = sortedClips.map((clip, idx) => {
          if (idx <= i) {
            // 왼쪽 클립들은 그대로
            return clip;
          } else {
            // 오른쪽 클립들을 연속적으로 배치 (빈 공간 없이)
            const newClip = { ...clip, position: currentPosition } as T;
            currentPosition = currentPosition + clip.duration; // 다음 클립 위치 업데이트
            return newClip;
          }
        });
        
        return {
          targetPosition: insertPosition,
          adjustedClips
        };
      }
    }
  }
  
  // 2. 맨 앞에 놓으려는 경우
  if (draggedEnd <= sortedClips[0].position) {
    console.log('맨 앞에 배치');
    return {
      targetPosition: Math.max(0, requestedPosition),
      adjustedClips: otherClips
    };
  }
  
  // 3. 맨 앞 클립과 겹치는 경우 - 모든 클립 밀기
  if (requestedPosition < sortedClips[0].position && draggedEnd > sortedClips[0].position) {
    const pushAmount = draggedEnd - sortedClips[0].position;
    console.log('맨 앞 클립과 겹침 - 모두 밀기:', pushAmount);
    
    const adjustedClips = sortedClips.map(clip => ({
      ...clip,
      position: clip.position + pushAmount
    } as T));
    
    return {
      targetPosition: Math.max(0, requestedPosition),
      adjustedClips
    };
  }
  
  // 4. 단일 클립 위에 있는 경우 - 중심 기준 좌/우 배치
  const overlappingClip = sortedClips.find(clip =>
    requestedPosition < clip.position + clip.duration &&
    draggedEnd > clip.position
  );
  
  if (overlappingClip) {
    const clipCenter = overlappingClip.position + (overlappingClip.duration / 2);
    
    console.log('클립 위에 배치 - 중심 비교:', {
      드래그중심: draggedCenter,
      클립중심: clipCenter
    });
    
    if (draggedCenter > clipCenter) {
      // 오른쪽에 배치
      console.log('오른쪽에 배치');
      return {
        targetPosition: overlappingClip.position + overlappingClip.duration,
        adjustedClips: otherClips
      };
    } else {
      // 왼쪽에 배치
      const leftPos = overlappingClip.position - duration;
      
      if (leftPos < 0) {
        // 맨 앞 공간 부족 - 모든 클립 밀어내기
        const pushAmount = -leftPos;
        console.log('왼쪽 공간 부족 - 모두 밀기:', pushAmount);
        
        const adjustedClips = sortedClips.map(clip => ({
          ...clip,
          position: clip.position + pushAmount
        } as T));
        
        return {
          targetPosition: 0,
          adjustedClips
        };
      }
      
      console.log('왼쪽에 배치');
      return {
        targetPosition: leftPos,
        adjustedClips: otherClips
      };
    }
  }
  
  // 5. 빈 공간에 배치
  console.log('빈 공간에 배치');
  return {
    targetPosition: Math.max(0, requestedPosition),
    adjustedClips: otherClips
  };
};

/**
 * Free positioning for text and sound clips - allows free placement without pushing other clips
 * @param clips Array of all clips (including the one being dragged)
 * @param draggedClipId ID of the clip being dragged
 * @param requestedPosition Position where the clip is being placed
 * @param duration Duration of the clip being placed
 * @returns Target position (adjusted to avoid overlaps)
 */
export const freePositioning = <T extends BaseClip>(
  clips: T[],
  draggedClipId: string,
  requestedPosition: number,
  duration: number
): number => {
  // 드래그된 클립 제외한 클립들
  const otherClips = clips.filter(c => c.id !== draggedClipId);
  
  // 요청된 위치에서 겹침 확인
  const hasOverlap = otherClips.some(clip => {
    const clipStart = clip.position;
    const clipEnd = clip.position + clip.duration;
    const draggedStart = requestedPosition;
    const draggedEnd = requestedPosition + duration;
    
    return draggedStart < clipEnd && draggedEnd > clipStart;
  });
  
  // 겹침이 없으면 요청된 위치 사용
  if (!hasOverlap) {
    return Math.max(0, requestedPosition);
  }
  
  // 겹침이 있으면 가장 가까운 빈 공간 찾기
  const sortedClips = [...otherClips].sort((a, b) => a.position - b.position);
  
  // 요청 위치 앞쪽의 빈 공간 찾기
  let bestPosition = requestedPosition;
  let minDistance = Infinity;
  
  // 맨 앞 확인
  if (sortedClips.length === 0 || sortedClips[0].position >= duration) {
    const frontPosition = 0;
    const distance = Math.abs(requestedPosition - frontPosition);
    if (distance < minDistance) {
      bestPosition = frontPosition;
      minDistance = distance;
    }
  }
  
  // 클립들 사이 공간 확인
  for (let i = 0; i < sortedClips.length - 1; i++) {
    const leftEnd = sortedClips[i].position + sortedClips[i].duration;
    const rightStart = sortedClips[i + 1].position;
    const gap = rightStart - leftEnd;
    
    if (gap >= duration) {
      // 이 공간에 들어갈 수 있음
      const candidatePosition = leftEnd;
      const distance = Math.abs(requestedPosition - candidatePosition);
      if (distance < minDistance) {
        bestPosition = candidatePosition;
        minDistance = distance;
      }
    }
  }
  
  // 마지막 클립 뒤 확인
  if (sortedClips.length > 0) {
    const lastClip = sortedClips[sortedClips.length - 1];
    const afterLastPosition = lastClip.position + lastClip.duration;
    const distance = Math.abs(requestedPosition - afterLastPosition);
    if (distance < minDistance) {
      bestPosition = afterLastPosition;
      minDistance = distance;
    }
  }
  
  return Math.max(0, bestPosition);
};

/**
 * Sound positioning - intelligently positions sound clips with between-clip detection
 * Similar to video clips, pushes other clips when inserting between clips
 * @param clips Array of all clips (including the one being dragged)
 * @param draggedClipId ID of the clip being dragged
 * @param requestedPosition Position where the clip is being placed
 * @param duration Duration of the clip being placed
 * @returns Target position and adjusted clips array
 */
export const soundPositioning = <T extends BaseClip>(
  clips: T[],
  draggedClipId: string,
  requestedPosition: number,
  duration: number
): { targetPosition: number; adjustedClips: T[] } => {
  // 드래그된 클립 제외한 클립들을 position 순으로 정렬
  const otherClips = clips.filter(c => c.id !== draggedClipId);
  const sortedClips = [...otherClips].sort((a, b) => a.position - b.position);
  
  // 클립이 없으면 그냥 요청 위치에 배치
  if (sortedClips.length === 0) {
    return { targetPosition: Math.max(0, requestedPosition), adjustedClips: [] };
  }
  
  // 드래그된 클립의 중심과 끝점
  const draggedCenter = requestedPosition + (duration / 2);
  const draggedEnd = requestedPosition + duration;
  
  // 1. 두 클립 사이에 있는지 확인
  for (let i = 0; i < sortedClips.length - 1; i++) {
    const leftClip = sortedClips[i];
    const rightClip = sortedClips[i + 1];
    
    const leftEnd = leftClip.position + leftClip.duration;
    const rightStart = rightClip.position;
    
    // 드래그한 클립이 두 클립 사이 공간과 관련이 있는지 확인
    // 더 넓은 범위로 감지: 중심이 사이에 있거나, 클립의 일부가 사이 공간과 겹치는 경우
    const isInBetween = 
      (draggedCenter >= leftEnd && draggedCenter <= rightStart) || // 중심이 사이에
      (requestedPosition >= leftEnd && requestedPosition <= rightStart) || // 시작이 사이에
      (draggedEnd >= leftEnd && draggedEnd <= rightStart) || // 끝이 사이에
      (requestedPosition <= leftEnd && draggedEnd >= rightStart); // 공간을 완전히 덮음
    
    if (isInBetween) {
      const gap = rightStart - leftEnd;
      
      if (gap >= duration) {
        // 공간이 충분하면 사용자가 드래그한 위치에 배치
        // 단, 왼쪽 클립과 겹치지 않고 오른쪽 클립과도 겹치지 않도록 조정
        let finalPosition = requestedPosition;
        
        // 왼쪽 클립과 겹치는 경우 조정
        if (finalPosition < leftEnd) {
          finalPosition = leftEnd;
        }
        
        // 오른쪽 클립과 겹치는 경우 조정
        if (finalPosition + duration > rightStart) {
          finalPosition = rightStart - duration;
        }
        
        return {
          targetPosition: finalPosition,
          adjustedClips: otherClips
        };
      } else {
        // 공간이 부족하면 오른쪽 클립들을 밀어내되, 연속적으로 재배치
        const insertPosition = leftEnd; // 삽입 위치는 왼쪽 클립 끝
        
        // 오른쪽 클립들을 연속적으로 재배치
        let currentPosition = insertPosition + duration; // 삽입될 클립 다음 위치
        const adjustedClips = sortedClips.map((clip, idx) => {
          if (idx <= i) {
            // 왼쪽 클립들은 그대로
            return clip;
          } else {
            // 오른쪽 클립들을 연속적으로 배치 (빈 공간 없이)
            const newClip = { ...clip, position: currentPosition } as T;
            currentPosition = currentPosition + clip.duration; // 다음 클립 위치 업데이트
            return newClip;
          }
        });
        
        return {
          targetPosition: insertPosition,
          adjustedClips
        };
      }
    }
  }
  
  // 2. 맨 앞에 놓으려는 경우
  if (draggedEnd <= sortedClips[0].position) {
    return {
      targetPosition: Math.max(0, requestedPosition),
      adjustedClips: otherClips
    };
  }
  
  // 3. 맨 앞 클립과 겹치는 경우 - 모든 클립 밀기
  if (requestedPosition < sortedClips[0].position && draggedEnd > sortedClips[0].position) {
    const pushAmount = draggedEnd - sortedClips[0].position;
    
    const adjustedClips = sortedClips.map(clip => ({
      ...clip,
      position: clip.position + pushAmount
    } as T));
    
    return {
      targetPosition: Math.max(0, requestedPosition),
      adjustedClips
    };
  }
  
  // 4. 단일 클립 위에 있는 경우 - 중심 기준 좌/우 배치
  const overlappingClip = sortedClips.find(clip =>
    requestedPosition < clip.position + clip.duration &&
    draggedEnd > clip.position
  );
  
  if (overlappingClip) {
    const clipCenter = overlappingClip.position + (overlappingClip.duration / 2);
    
    if (draggedCenter > clipCenter) {
      // 오른쪽에 배치
      return {
        targetPosition: overlappingClip.position + overlappingClip.duration,
        adjustedClips: otherClips
      };
    } else {
      // 왼쪽에 배치
      const leftPos = overlappingClip.position - duration;
      
      if (leftPos < 0) {
        // 맨 앞 공간 부족 - 모든 클립 밀어내기
        const pushAmount = -leftPos;
        
        const adjustedClips = sortedClips.map(clip => ({
          ...clip,
          position: clip.position + pushAmount
        } as T));
        
        return {
          targetPosition: 0,
          adjustedClips
        };
      }
      
      return {
        targetPosition: leftPos,
        adjustedClips: otherClips
      };
    }
  }
  
  // 5. 빈 공간에 배치
  return {
    targetPosition: Math.max(0, requestedPosition),
    adjustedClips: otherClips
  };
};

/**
 * Magnetic insert - pushes clips to the right when inserting
 * @param clips Array of existing clips
 * @param insertPosition Position where new clip will be inserted
 * @param insertDuration Duration of the clip being inserted
 * @returns Updated clips array with pushed positions
 */
export const magneticInsert = <T extends BaseClip>(
  clips: T[],
  insertPosition: number,
  insertDuration: number
): T[] => {
  return clips.map(clip => {
    // Push clips that are at or after the insert position
    if (clip.position >= insertPosition) {
      return {
        ...clip,
        position: clip.position + insertDuration
      };
    }
    // Clips that overlap with insert position get pushed
    if (clip.position < insertPosition && clip.position + clip.duration > insertPosition) {
      return {
        ...clip,
        position: insertPosition + insertDuration
      };
    }
    return clip;
  });
};

/**
 * Magnetic delete - pulls clips to the left when deleting (ripple delete)
 * @param clips Array of clips
 * @param deletedPosition Position of deleted clip
 * @param deletedDuration Duration of deleted clip
 * @returns Updated clips array with pulled positions
 */
export const magneticDelete = <T extends BaseClip>(
  clips: T[],
  deletedPosition: number,
  deletedDuration: number
): T[] => {
  return clips.map(clip => {
    // Pull clips that are after the deleted position
    if (clip.position > deletedPosition) {
      return {
        ...clip,
        position: Math.max(deletedPosition, clip.position - deletedDuration)
      };
    }
    return clip;
  });
};

/**
 * Remove gaps between clips (compress timeline)
 * @param clips Array of clips
 * @returns Clips array with gaps removed
 */
export const removeGaps = <T extends BaseClip>(clips: T[]): T[] => {
  if (clips.length === 0) return clips;
  
  // Sort clips by position
  const sortedClips = [...clips].sort((a, b) => a.position - b.position);
  
  return sortedClips.map((clip, index) => {
    if (index === 0) {
      // First clip stays at position 0
      return { ...clip, position: 0 };
    }
    
    const previousClip = sortedClips[index - 1];
    const expectedPosition = previousClip.position + previousClip.duration;
    
    // Remove gap if exists
    if (clip.position > expectedPosition) {
      return { ...clip, position: expectedPosition };
    }
    
    return clip;
  });
};

/**
 * Get the end position of the last clip
 * @param clips Array of clips
 * @returns End position of the last clip
 */
export const getTimelineEnd = <T extends BaseClip>(clips: T[]): number => {
  if (clips.length === 0) return 0;
  
  return clips.reduce((max, clip) => {
    const clipEnd = clip.position + clip.duration;
    return Math.max(max, clipEnd);
  }, 0);
};

/**
 * Recalculate clip positions after duration change
 * Ensures clips remain tightly packed without gaps
 * @param clips Array of clips
 * @param changedClipId ID of the clip whose duration changed
 * @param newDuration New duration of the changed clip
 * @returns Updated clips array with recalculated positions
 */
export const recalculatePositionsAfterDurationChange = <T extends BaseClip>(
  clips: T[],
  changedClipId: string,
  newDuration: number
): T[] => {
  const clipIndex = clips.findIndex(c => c.id === changedClipId);
  if (clipIndex === -1) return clips;
  
  const oldDuration = clips[clipIndex].duration;
  const durationDiff = newDuration - oldDuration;
  
  return clips.map((clip, idx) => {
    if (clip.id === changedClipId) {
      // Update the changed clip's duration
      return { ...clip, duration: newDuration };
    } else if (idx > clipIndex) {
      // Adjust positions of clips after the changed clip
      return { ...clip, position: clip.position + durationDiff };
    }
    return clip;
  });
};
</file>

<file path="app/video-editor/_components/SoundClip.tsx">
'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { SoundClip as SoundClipType } from '@/types/video-editor';
import { drawWaveformFinalCutStyle, resampleWaveform } from '../_utils/audio-analysis';

interface SoundClipProps {
  clip: SoundClipType;
  onEdit?: (clip: SoundClipType) => void;
  onDelete?: (id: string) => void;
  onResizeStart?: (e: React.MouseEvent, handle: 'left' | 'right') => void;
  onVolumeChange?: (id: string, volume: number) => void;
  onFadeChange?: (id: string, fadeType: 'fadeIn' | 'fadeOut', duration: number) => void;
  isActive?: boolean;
  pixelsPerSecond?: number;
  clipWidth?: number;
}

export default function SoundClip({
  clip,
  onEdit,
  onResizeStart,
  onVolumeChange,
  onFadeChange,
  isActive = false,
  pixelsPerSecond = 40,
  clipWidth = 200,
}: SoundClipProps) {
  const clipRef = useRef<HTMLDivElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const volumeLineRef = useRef<HTMLDivElement>(null);
  const [isDraggingVolume, setIsDraggingVolume] = useState(false);
  const [tempVolume, setTempVolume] = useState(clip.volume);
  const [isHoveringVolumeLine, setIsHoveringVolumeLine] = useState(false);
  const [isDraggingFadeIn, setIsDraggingFadeIn] = useState(false);
  const [isDraggingFadeOut, setIsDraggingFadeOut] = useState(false);
  const [tempFadeIn, setTempFadeIn] = useState(clip.fadeInDuration || 0);
  const [tempFadeOut, setTempFadeOut] = useState(clip.fadeOutDuration || 0);
  const [isHoveringFadeIn, setIsHoveringFadeIn] = useState(false);
  const [isHoveringFadeOut, setIsHoveringFadeOut] = useState(false);
  const dragStartY = useRef<number>(0);
  const dragStartVolume = useRef<number>(clip.volume);
  const dragStartX = useRef<number>(0);
  const dragStartFade = useRef<number>(0);

  const handleDoubleClick = () => {
    if (onEdit) {
      onEdit(clip);
    }
  };

  const formatDuration = (duration: number) => {
    const totalSeconds = Math.floor(duration / pixelsPerSecond);
    const minutes = Math.floor(totalSeconds / 60);
    const remainingSeconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
  };

  // Draw Final Cut Pro style waveform with fade visualization
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Set canvas size to match container
    const container = clipRef.current;
    if (container) {
      canvas.width = container.clientWidth;
      canvas.height = 40; // Fixed height for sound clips
    }

    // Draw waveform or placeholder
    if (clip.waveformData && clip.waveformData.length > 0) {
      // Calculate how many samples we need for current width
      const samplesNeeded = Math.min(canvas.width, 300); // More samples for detailed waveform
      const resampledData = resampleWaveform(clip.waveformData, samplesNeeded);
      
      // Use Final Cut Pro style rendering
      drawWaveformFinalCutStyle(canvas, resampledData, tempVolume, isActive);
    } else {
      // Draw placeholder waveform
      const placeholderData = Array(100).fill(0).map(() => 0.3 + Math.random() * 0.4);
      drawWaveformFinalCutStyle(canvas, placeholderData, tempVolume, isActive);
    }

    // Draw fade areas on top of waveform
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Draw fade in area
    if (tempFadeIn > 0) {
      const fadeInWidth = tempFadeIn;
      const gradient = ctx.createLinearGradient(0, 0, fadeInWidth, 0);
      gradient.addColorStop(0, 'rgba(34, 211, 238, 0.4)'); // Slightly more visible
      gradient.addColorStop(0.5, 'rgba(34, 211, 238, 0.2)');
      gradient.addColorStop(1, 'rgba(34, 211, 238, 0)');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, fadeInWidth, canvas.height);
      
      // Draw fade in curve line (베지어 곡선)
      ctx.strokeStyle = 'rgba(34, 211, 238, 0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height); // Start at bottom left
      
      // 상단 (0px = 최대 볼륨)
      const topY = 5; // 상단에서 약간 떨어진 위치
      
      // 베지어 곡선 - 빠른 상승 후 상단에 도달
      ctx.quadraticCurveTo(
        fadeInWidth * 0.4,  // Control point X (40% 지점)
        topY + 10,          // Control point Y (거의 상단)
        fadeInWidth,        // End point X
        topY               // End point Y (상단)
      );
      ctx.stroke();
      
      // Draw handle connection line at 1/3 height
      ctx.strokeStyle = 'rgba(34, 211, 238, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(fadeInWidth, 0);
      ctx.lineTo(fadeInWidth, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Draw fade out area
    if (tempFadeOut > 0) {
      const fadeOutStart = canvas.width - tempFadeOut;
      const gradient = ctx.createLinearGradient(canvas.width, 0, fadeOutStart, 0);
      gradient.addColorStop(0, 'rgba(34, 211, 238, 0.4)'); // Slightly more visible
      gradient.addColorStop(0.5, 'rgba(34, 211, 238, 0.2)');
      gradient.addColorStop(1, 'rgba(34, 211, 238, 0)');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(fadeOutStart, 0, tempFadeOut, canvas.height);
      
      // Draw fade out curve line (베지어 곡선)
      ctx.strokeStyle = 'rgba(34, 211, 238, 0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      // 상단 (0px = 최대 볼륨)
      const topY = 5; // 상단에서 약간 떨어진 위치
      ctx.moveTo(fadeOutStart, topY); // Start at top (max volume)
      
      // 베지어 곡선 - 상단에서 시작해서 빠르게 하강 (ease-in)
      ctx.quadraticCurveTo(
        fadeOutStart + tempFadeOut * 0.6,  // Control point X (60% 지점)
        topY + 10,                          // Control point Y (거의 상단 유지)
        canvas.width,                       // End point X
        canvas.height                      // End point Y (바닥)
      );
      ctx.stroke();
      
      // Draw handle connection line at 1/3 height
      ctx.strokeStyle = 'rgba(34, 211, 238, 0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      ctx.beginPath();
      ctx.moveTo(fadeOutStart, 0);
      ctx.lineTo(fadeOutStart, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }, [clip.waveformData, clip.duration, tempVolume, isActive, tempFadeIn, tempFadeOut]);

  // Handle volume line drag start
  const handleVolumeMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation(); // Prevent clip dragging
    setIsDraggingVolume(true);
    dragStartY.current = e.clientY;
    dragStartVolume.current = tempVolume;
  }, [tempVolume]);

  // Handle volume drag
  useEffect(() => {
    if (!isDraggingVolume) return;

    const handleMouseMove = (e: MouseEvent) => {
      const deltaY = dragStartY.current - e.clientY; // Up increases volume
      const volumeChange = (deltaY / 20) * 100; // 20px = 100% volume change
      
      let newVolume = dragStartVolume.current + volumeChange;
      
      // Snap to 5% increments if Shift is held
      if (e.shiftKey) {
        newVolume = Math.round(newVolume / 5) * 5;
      }
      
      // Clamp between 0 and 100
      newVolume = Math.max(0, Math.min(100, newVolume));
      setTempVolume(newVolume);
    };

    const handleMouseUp = () => {
      setIsDraggingVolume(false);
      if (onVolumeChange && tempVolume !== clip.volume) {
        onVolumeChange(clip.id, tempVolume);
      }
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDraggingVolume, clip.id, clip.volume, tempVolume, onVolumeChange]);

  // Update temp volume when clip volume changes externally
  useEffect(() => {
    setTempVolume(clip.volume);
  }, [clip.volume]);

  // Update temp fade values when clip fade changes externally
  useEffect(() => {
    setTempFadeIn(clip.fadeInDuration || 0);
    setTempFadeOut(clip.fadeOutDuration || 0);
  }, [clip.fadeInDuration, clip.fadeOutDuration]);
  
  // Auto-adjust fade values when clip duration changes
  useEffect(() => {
    const minGap = 10;
    const maxFadeIn = Math.min(
      tempFadeIn,
      clip.duration * 0.5,
      clip.duration - tempFadeOut - minGap
    );
    const maxFadeOut = Math.min(
      tempFadeOut,
      clip.duration * 0.5,
      clip.duration - tempFadeIn - minGap
    );
    
    // Adjust fade in if it exceeds new limits
    if (tempFadeIn > maxFadeIn) {
      setTempFadeIn(Math.max(0, maxFadeIn));
      if (onFadeChange && maxFadeIn >= 0) {
        onFadeChange(clip.id, 'fadeIn', Math.max(0, maxFadeIn));
      }
    }
    
    // Adjust fade out if it exceeds new limits
    if (tempFadeOut > maxFadeOut) {
      setTempFadeOut(Math.max(0, maxFadeOut));
      if (onFadeChange && maxFadeOut >= 0) {
        onFadeChange(clip.id, 'fadeOut', Math.max(0, maxFadeOut));
      }
    }
  }, [clip.duration, clip.id, tempFadeIn, tempFadeOut, onFadeChange]);

  // Handle fade in drag start
  const handleFadeInMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingFadeIn(true);
    dragStartX.current = e.clientX;
    dragStartFade.current = tempFadeIn;
  }, [tempFadeIn]);

  // Handle fade out drag start
  const handleFadeOutMouseDown = useCallback((e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingFadeOut(true);
    dragStartX.current = e.clientX;
    dragStartFade.current = tempFadeOut;
  }, [tempFadeOut]);

  // Handle fade in drag
  useEffect(() => {
    if (!isDraggingFadeIn) return;

    const handleMouseMove = (e: MouseEvent) => {
      const deltaX = e.clientX - dragStartX.current;
      let newFadeIn = dragStartFade.current + deltaX;
      
      // Limit fade in to not overlap with fade out (minimum 10px gap)
      const minGap = 10; // Minimum gap between fade in and fade out
      const maxFadeSeconds = 10; // Maximum 10 seconds
      const maxFadePixels = maxFadeSeconds * pixelsPerSecond; // Convert to pixels
      
      const maxFadeIn = Math.min(
        maxFadePixels, // Maximum 10 seconds
        clip.duration * 0.5, // Maximum 50% of clip
        clip.duration - tempFadeOut - minGap // Don't overlap with fade out
      );
      newFadeIn = Math.max(0, Math.min(maxFadeIn, newFadeIn));
      
      // Snap to 0.5 second increments if Shift is held
      if (e.shiftKey) {
        const snapInterval = pixelsPerSecond * 0.5; // 0.5 second
        newFadeIn = Math.round(newFadeIn / snapInterval) * snapInterval;
      }
      
      setTempFadeIn(newFadeIn);
    };

    const handleMouseUp = () => {
      setIsDraggingFadeIn(false);
      if (onFadeChange && tempFadeIn !== (clip.fadeInDuration || 0)) {
        onFadeChange(clip.id, 'fadeIn', tempFadeIn);
      }
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDraggingFadeIn, clip.id, clip.fadeInDuration, clip.duration, tempFadeIn, tempFadeOut, onFadeChange, pixelsPerSecond]);

  // Handle fade out drag
  useEffect(() => {
    if (!isDraggingFadeOut) return;

    const handleMouseMove = (e: MouseEvent) => {
      const deltaX = dragStartX.current - e.clientX; // Reverse direction for fade out
      let newFadeOut = dragStartFade.current + deltaX;
      
      // Limit fade out to not overlap with fade in (minimum 10px gap)
      const minGap = 10; // Minimum gap between fade in and fade out
      const maxFadeSeconds = 10; // Maximum 10 seconds
      const maxFadePixels = maxFadeSeconds * pixelsPerSecond; // Convert to pixels
      
      const maxFadeOut = Math.min(
        maxFadePixels, // Maximum 10 seconds
        clip.duration * 0.5, // Maximum 50% of clip
        clip.duration - tempFadeIn - minGap // Don't overlap with fade in
      );
      newFadeOut = Math.max(0, Math.min(maxFadeOut, newFadeOut));
      
      // Snap to 0.5 second increments if Shift is held
      if (e.shiftKey) {
        const snapInterval = pixelsPerSecond * 0.5; // 0.5 second
        newFadeOut = Math.round(newFadeOut / snapInterval) * snapInterval;
      }
      
      setTempFadeOut(newFadeOut);
    };

    const handleMouseUp = () => {
      setIsDraggingFadeOut(false);
      if (onFadeChange && tempFadeOut !== (clip.fadeOutDuration || 0)) {
        onFadeChange(clip.id, 'fadeOut', tempFadeOut);
      }
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
  }, [isDraggingFadeOut, clip.id, clip.fadeOutDuration, clip.duration, tempFadeIn, tempFadeOut, onFadeChange, pixelsPerSecond]);

  // Calculate volume line position 
  // Center (20px) = 100%, Bottom (40px) = 0%
  const volumeLinePosition = 40 - (tempVolume / 100) * 20; // 0-100%: from bottom (40px) to center (20px)

  return (
    <div
      ref={clipRef}
      className={`group relative w-full h-full ${isActive ? 'z-10' : ''}`}
      onDoubleClick={handleDoubleClick}
    >
      <div className={`relative w-full h-10 bg-slate-800/70 backdrop-blur-sm rounded overflow-hidden ${
        isActive ? 'ring-2 ring-[#38f47cf9]' : ''
      }`}>
        {/* Background with subtle gradient */}
        <div className="absolute inset-0 bg-gradient-to-b from-slate-900/50 to-slate-800/50" />
        
        {/* Waveform Canvas */}
        <canvas
          ref={canvasRef}
          className="absolute inset-0 w-full h-full"
          style={{ imageRendering: 'auto' }}
        />
        
        {/* Volume adjustment line (horizontal) */}
        <div
          ref={volumeLineRef}
          className={`absolute left-0 right-0 h-[3px] cursor-ns-resize ${
            isDraggingVolume ? 'bg-yellow-400 shadow-lg' : 
            isHoveringVolumeLine ? 'bg-cyan-400 shadow-md' : 
            'bg-cyan-500/80'
          }`}
          style={{ 
            top: `${volumeLinePosition}px`,
            transition: isDraggingVolume ? 'none' : 'all 0.15s ease-out', // 드래그 중에는 transition 제거
            boxShadow: isDraggingVolume ? '0 0 8px rgba(250, 204, 21, 0.5)' : 
                      isHoveringVolumeLine ? '0 0 4px rgba(34, 211, 238, 0.3)' : 'none'
          }}
          onMouseDown={handleVolumeMouseDown}
          onMouseEnter={() => setIsHoveringVolumeLine(true)}
          onMouseLeave={() => setIsHoveringVolumeLine(false)}
        >
          {/* Volume handle dot */}
          <div className={`absolute -top-1 left-1/2 -translate-x-1/2 w-2 h-2 rounded-full ${
            isDraggingVolume ? 'bg-yellow-400' : 'bg-cyan-400'
          }`} 
          style={{
            transition: isDraggingVolume ? 'none' : 'all 0.15s ease-out' // 드래그 중에는 transition 제거
          }}
          />
        </div>
        
        {/* Max volume line at center (100% volume) */}
        <div className="absolute left-0 right-0 h-[1px] bg-white/20" style={{ top: '20px' }}>
          <span className="absolute -left-12 -top-2 text-[8px] text-gray-500">MAX</span>
        </div>
        
        {/* Loading indicator if analyzing */}
        {clip.isAnalyzing && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/30">
            <div className="animate-pulse text-xs text-white">Analyzing...</div>
          </div>
        )}
        
        {/* Clip info overlay - 작을 때 조건부 렌더링 */}
        {clipWidth > 30 && (
          <div className="absolute top-0 left-0 right-0 flex items-center justify-between px-2 py-1 pointer-events-none">
            {clipWidth > 40 ? (
              <>
                <div className="flex items-center gap-1">
                  <i className="ri-volume-up-line text-[10px] text-cyan-300 flex-shrink-0"></i>
                  {clipWidth > 60 && (
                    <span className="text-[10px] text-white/90 truncate max-w-[100px] font-medium">
                      {clip.name}
                    </span>
                  )}
                </div>
                
                <div className="flex items-center gap-2">
                  {/* Volume percentage display */}
                  {(isDraggingVolume || isHoveringVolumeLine) && (
                    <span className="text-[10px] text-cyan-300 font-mono bg-black/60 px-1 rounded">
                      {Math.round(tempVolume)}%
                    </span>
                  )}
                  {clipWidth > 80 && (
                    <span className="text-[10px] text-gray-400 whitespace-nowrap">
                      {formatDuration(clip.duration)}
                    </span>
                  )}
                </div>
              </>
            ) : (
              <i className="ri-volume-up-line text-[10px] text-cyan-300 mx-auto"></i>
            )}
          </div>
        )}
        
        {/* Fade handles */}
        {/* Fade In Handle - top 1/3 height position */}
        <div
          className={`absolute w-2 h-2 rounded-full cursor-ew-resize z-20 border border-gray-600 ${
            isDraggingFadeIn ? 'bg-yellow-400 scale-125 border-yellow-500' : 
            isHoveringFadeIn ? 'bg-white scale-110 border-white' : 
            'bg-gray-300'
          }`}
          style={{ 
            left: `${tempFadeIn}px`,
            top: '33%', // 상단 1/3 지점
            transform: 'translateY(-50%)',
            transition: isDraggingFadeIn ? 'none' : 'all 0.15s ease-out', // 드래그 중에는 transition 제거
            boxShadow: isDraggingFadeIn ? '0 0 8px rgba(250, 204, 21, 0.5)' : 
                      isHoveringFadeIn ? '0 0 6px rgba(255, 255, 255, 0.5)' : '0 0 3px rgba(255, 255, 255, 0.3)'
          }}
          onMouseDown={handleFadeInMouseDown}
          onMouseEnter={() => setIsHoveringFadeIn(true)}
          onMouseLeave={() => setIsHoveringFadeIn(false)}
          title="Drag to adjust fade in"
        />
        
        {/* Fade Out Handle - top 1/3 height position */}
        <div
          className={`absolute w-2 h-2 rounded-full cursor-ew-resize z-20 border border-gray-600 ${
            isDraggingFadeOut ? 'bg-yellow-400 scale-125 border-yellow-500' : 
            isHoveringFadeOut ? 'bg-white scale-110 border-white' : 
            'bg-gray-300'
          }`}
          style={{ 
            right: `${tempFadeOut}px`,
            top: '33%', // 상단 1/3 지점
            transform: 'translateY(-50%)',
            transition: isDraggingFadeOut ? 'none' : 'all 0.15s ease-out', // 드래그 중에는 transition 제거
            boxShadow: isDraggingFadeOut ? '0 0 8px rgba(250, 204, 21, 0.5)' : 
                      isHoveringFadeOut ? '0 0 6px rgba(255, 255, 255, 0.5)' : '0 0 3px rgba(255, 255, 255, 0.3)'
          }}
          onMouseDown={handleFadeOutMouseDown}
          onMouseEnter={() => setIsHoveringFadeOut(true)}
          onMouseLeave={() => setIsHoveringFadeOut(false)}
          title="Drag to adjust fade out"
        />
        
        {/* Resize handles */}
        <div
          className="absolute inset-y-0 left-0 w-1 bg-cyan-500 rounded-l cursor-ew-resize resize-handle hover:w-2 transition-all opacity-60 hover:opacity-100"
          onMouseDown={(e) => {
            e.stopPropagation();
            onResizeStart?.(e, 'left');
          }}
        />
        <div
          className="absolute inset-y-0 right-0 w-1 bg-cyan-500 rounded-r cursor-ew-resize resize-handle hover:w-2 transition-all opacity-60 hover:opacity-100"
          onMouseDown={(e) => {
            e.stopPropagation();
            onResizeStart?.(e, 'right');
          }}
        />
        
        {/* Visual feedback when dragging volume */}
        {isDraggingVolume && (
          <div className="absolute -top-8 left-1/2 -translate-x-1/2 bg-black/90 text-white px-2 py-1 rounded text-xs whitespace-nowrap pointer-events-none z-50">
            Volume: {Math.round(tempVolume)}%
            {tempVolume === 0 && <span className="text-red-400 ml-1">(Muted)</span>}
            {tempVolume === 100 && <span className="text-green-400 ml-1">(Max)</span>}
          </div>
        )}
        
        {/* Visual feedback when dragging fade in */}
        {isDraggingFadeIn && (
          <div 
            className="absolute -top-8 bg-black/90 text-white px-2 py-1 rounded text-xs whitespace-nowrap pointer-events-none z-50"
            style={{ left: `${tempFadeIn}px` }}
          >
            Fade In: {(tempFadeIn / pixelsPerSecond).toFixed(1)}s
          </div>
        )}
        
        {/* Visual feedback when dragging fade out */}
        {isDraggingFadeOut && (
          <div 
            className="absolute -top-8 bg-black/90 text-white px-2 py-1 rounded text-xs whitespace-nowrap pointer-events-none z-50"
            style={{ right: `${tempFadeOut}px` }}
          >
            Fade Out: {(tempFadeOut / pixelsPerSecond).toFixed(1)}s
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_components/TextOverlayEditor.tsx">
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { TextClip as TextClipType } from '@/types/video-editor';
import { TEXT_DEFAULTS, TEXT_PADDING, TEXT_POSITION_PRESETS, ratioToPixels, pixelsToRatio } from '../../../constants/text-editor';

interface TextOverlayEditorProps {
  textClips: TextClipType[];
  containerWidth: number;
  containerHeight: number;
  currentTime: number;
  pixelsPerSecond: number;
  onUpdatePosition: (id: string, x: number, y: number) => void;
  onUpdateSize: (id: string, fontSize: number, fontSizeRatio: number) => void;
  selectedClip: string | null;
  onSelectClip: (id: string | null) => void;
  aspectRatio?: string;
}


export default function TextOverlayEditor({
  textClips,
  containerWidth,
  containerHeight,
  currentTime,
  pixelsPerSecond,
  onUpdatePosition,
  onUpdateSize,
  selectedClip,
  onSelectClip,
  aspectRatio
}: TextOverlayEditorProps) {
  const containerRef = useRef<HTMLDivElement>(null);
  const [draggedClip, setDraggedClip] = useState<string | null>(null);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
  const [showGuides, setShowGuides] = useState(false);
  const [resizingClip, setResizingClip] = useState<string | null>(null);
  const [resizeStart, setResizeStart] = useState({ y: 0, size: 0 });
  const [, setForceUpdate] = useState(0);

  // DOM 크기 기반 스케일 계산 (원본 해상도 대비 표시 배율)
  const getScale = useCallback(() => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (rect && containerWidth && containerHeight) {
      const scaleX = rect.width / containerWidth;
      const scaleY = rect.height / containerHeight;
      const scale = Math.min(scaleX, scaleY);
      // 비율 변경 시 더 정확한 스케일 계산을 위한 로직
      if (aspectRatio) {
        // 컨테이너가 실제로 리렌더링된 후의 크기를 사용
        return scale;
      }
      return scale;
    }
    return 1;
  }, [containerWidth, containerHeight, aspectRatio]);

  // 현재 시간에 활성화된 텍스트 클립만 필터링
  const getActiveTextClips = () => {
    const currentFrame = currentTime * 30; // 30fps
    return textClips.filter(clip => {
      const startFrame = (clip.position / pixelsPerSecond) * 30;
      const endFrame = ((clip.position + clip.duration) / pixelsPerSecond) * 30;
      return currentFrame >= startFrame && currentFrame < endFrame;
    });
  };

  const activeClips = getActiveTextClips();

  const getContainerSize = useCallback(() => {
    return { width: containerWidth || 1080, height: containerHeight || 1920 };
  }, [containerWidth, containerHeight]);
  
  // Remotion Player와 동일한 스케일을 사용하기 위해 getScale만 사용
  // (별도 제한/클램핑 없이 실제 표시 배율 그대로 적용)


  const percentToPixel = (percent: number | undefined, max: number, defaultPercent: number = 50): number => {
    const p = percent ?? defaultPercent;
    return (p / 100) * max;
  };

  const pixelToPercent = (pixel: number, max: number): number => {
    return (pixel / max) * 100;
  };

  // 단순화된 텍스트 크기 측정 함수 - 원본 크기로 측정 (최대 너비 80% 적용)
  const measureTextSizeSimple = useCallback((text: string, fontSize: number, fontSizeRatio: number | undefined, fontFamily: string, fontWeight: number) => {
    // 상대적 크기 계산 (비율 우선 사용)
    const containerSize = getContainerSize();
    const actualFontSize = (() => {
      if (fontSizeRatio !== undefined) {
        return ratioToPixels(fontSizeRatio, containerSize.width);
      }
      // 기존 fontSize를 비율로 변환 (1080px 기준)
      const baseWidth = 1080;
      const ratio = pixelsToRatio(fontSize, baseWidth);
      return ratioToPixels(ratio, containerSize.width);
    })();
    const scaledFontSize = actualFontSize; // 스케일 미적용
    const aspectRatio = containerSize.width / containerSize.height;
    
    // DOM 측정만 사용 (더 정확함)
    const tempElement = document.createElement('div');
    tempElement.style.position = 'absolute';
    tempElement.style.left = '-9999px';
    tempElement.style.top = '-9999px';
    tempElement.style.fontSize = `${scaledFontSize}px`;
    tempElement.style.fontFamily = fontFamily;
    tempElement.style.fontWeight = String(fontWeight);
    tempElement.style.lineHeight = '1.2';
    // Remotion의 기본 흐름과 동일하게 공백을 접고 자동 줄바꿈되도록 설정
    tempElement.style.whiteSpace = 'normal';
    // Remotion 텍스트 컨테이너와 동일한 최대 너비 제한을 적용해 실제 줄바꿈을 반영
    tempElement.style.maxWidth = `${containerSize.width * TEXT_DEFAULTS.maxWidthRatio}px`;
    tempElement.style.visibility = 'hidden';
    tempElement.style.pointerEvents = 'none';
    tempElement.textContent = text;
    
    document.body.appendChild(tempElement);
    const rect = tempElement.getBoundingClientRect();
    const width = rect.width; // 보정 없이 그대로 사용
    const height = rect.height;
    document.body.removeChild(tempElement);
    
    // 빈 텍스트 처리
    const finalWidth = width || scaledFontSize * 0.5;
    const finalHeight = height || scaledFontSize * 1.2;
    
    return {
      width: finalWidth,
      height: finalHeight,
      scaledFontSize,
      aspectRatio
    };
  }, [getContainerSize]);

  const handleMouseDown = (e: React.MouseEvent, clipId: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    const clip = textClips.find(c => c.id === clipId);
    if (!clip) return;

    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return;

    const size = getContainerSize();
    const scale = getScale();
    
    // 현재 텍스트의 실제 위치 계산
    const has_custom_position = clip.style?.positionX !== undefined && clip.style?.positionY !== undefined;
    let anchorX = 0;
    let anchorY = 0;
    // 기본 앵커 위치 계산 (정렬에 따라 좌/중/우 기준이 달라짐)
    if (has_custom_position) {
      // 커스텀 위치는 항상 중앙 앵커로 저장/해석됨
      anchorX = percentToPixel(clip.style?.positionX, size.width);
      anchorY = percentToPixel(clip.style?.positionY, size.height);
    } else {
      const vertical = clip.style?.verticalPosition || 'middle';
      const align = clip.style?.alignment || 'center';
      const top_percent = TEXT_POSITION_PRESETS.vertical[vertical as keyof typeof TEXT_POSITION_PRESETS.vertical];
      const left_percent = TEXT_POSITION_PRESETS.horizontal[align as keyof typeof TEXT_POSITION_PRESETS.horizontal];
      anchorX = percentToPixel(left_percent, size.width);
      anchorY = percentToPixel(top_percent, size.height);
    }

    // 중앙 앵커로 변환: Remotion은 커스텀 좌표를 항상 중앙 기준으로 해석하므로
    // 좌/우 정렬로 기본 위치한 요소를 드래그 시작 시 중앙 기준으로 전환해 저장되도록 보정한다.
    // 텍스트 박스 전체 너비(패딩 포함)를 구해 좌/우 정렬 시 중앙 이동량을 반영한다.
    const actualFontSize = clip.style?.fontSize || TEXT_DEFAULTS.fontSize;
    const fontSizeRatio = clip.style?.fontSizeRatio;
    const fontFamily = clip.style?.fontFamily || TEXT_DEFAULTS.fontFamily;
    const fontWeight = clip.style?.fontWeight || TEXT_DEFAULTS.fontWeight;
    const hasBackground = !!clip.style?.backgroundColor;
    const measurement = measureTextSizeSimple(
      clip.content,
      actualFontSize,
      fontSizeRatio,
      fontFamily,
      fontWeight
    );
    const contentWidth = measurement.width; // 컴포지션 좌표계(px)
    const fullBoxWidth = contentWidth + (hasBackground ? TEXT_PADDING.horizontal * 2 : 0); // 좌/우 패딩 포함

    if (!has_custom_position) {
      const align = clip.style?.alignment || 'center';
      if (align === 'left') {
        // 좌측 정렬은 왼쪽 모서리 기준 → 중앙 기준으로 이동
        anchorX = anchorX + fullBoxWidth / 2;
      } else if (align === 'right') {
        // 우측 정렬은 오른쪽 모서리 기준 → 중앙 기준으로 이동
        anchorX = anchorX - fullBoxWidth / 2;
      }
    }
    
    // 마우스 클릭 위치와 텍스트 중심 간의 오프셋 계산
    const mouseX = (e.clientX - rect.left) / scale;
    const mouseY = (e.clientY - rect.top) / scale;
    
    setDraggedClip(clipId);
    setDragOffset({
      x: mouseX - anchorX,
      y: mouseY - anchorY
    });
    setShowGuides(true);
    onSelectClip(clipId);
  };

  const handleResizeStart = (e: React.MouseEvent, clipId: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    const clip = textClips.find(c => c.id === clipId);
    if (!clip) return;
    
    // fontSizeRatio가 있으면 1080px 기준으로 변환, 없으면 fontSize 사용
    const initialSize = clip.style?.fontSizeRatio 
      ? Math.round(clip.style.fontSizeRatio * 1080)
      : (clip.style?.fontSize || TEXT_DEFAULTS.fontSize);
    
    setResizingClip(clipId);
    setResizeStart({
      y: e.clientY,
      size: initialSize
    });
    onSelectClip(clipId);
  };

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (draggedClip) {
        const rect = containerRef.current?.getBoundingClientRect();
        if (!rect) return;

        const clip = textClips.find(c => c.id === draggedClip);
        if (!clip) return;

        const size = getContainerSize();
        const scale = getScale();
        
        // 마우스 위치에서 오프셋을 뺀 값으로 텍스트 중심 위치 계산
        const mouseX = (e.clientX - rect.left) / scale;
        const mouseY = (e.clientY - rect.top) / scale;
        
        const centerX = mouseX - dragOffset.x; // 항상 중앙 앵커 기준
        const centerY = mouseY - dragOffset.y; // 항상 중앙 앵커 기준
        
        const xPercent = pixelToPercent(centerX, size.width);
        const yPercent = pixelToPercent(centerY, size.height);
        
        onUpdatePosition(draggedClip, xPercent, yPercent);
      } else if (resizingClip) {
        const deltaY = e.clientY - resizeStart.y;
        const newSize = Math.round(Math.max(16, Math.min(200, resizeStart.size + deltaY / 2)));
        // fontSize와 fontSizeRatio를 모두 계산하여 전달 (1080px 기준)
        const newRatio = newSize / 1080; // TextEditorModal과 동일한 1080px 기준
        onUpdateSize(resizingClip, newSize, newRatio);
      }
    };

    const handleMouseUp = () => {
      setDraggedClip(null);
      setResizingClip(null);
      setShowGuides(false);
    };

    if (draggedClip || resizingClip) {
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
      
      return () => {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      };
    }
  }, [draggedClip, resizingClip, dragOffset, resizeStart, textClips, getContainerSize, getScale, onUpdatePosition, onUpdateSize]);

  // 비율 변경 시 강제 리렌더링
  useEffect(() => {
    // aspectRatio 또는 container 크기가 변경되면 DOM이 업데이트될 때까지 대기 후 리렌더링
    requestAnimationFrame(() => {
      setForceUpdate(prev => prev + 1);
    });
  }, [aspectRatio, containerWidth, containerHeight]);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (containerRef.current && !containerRef.current.contains(e.target as Node)) {
        onSelectClip(null);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [onSelectClip]);

  if (activeClips.length === 0) return null;

  const displayScale = getScale();
  const size = getContainerSize();
  
  // 스케일이 적용된 실제 크기
  const scaledSize = {
    width: size.width * displayScale,
    height: size.height * displayScale
  };

  return (
    <div 
      ref={containerRef}
      className="absolute inset-0 overflow-hidden rounded-lg flex items-center justify-center"
      style={{ 
        zIndex: 50,
        pointerEvents: 'none' // 컨테이너는 이벤트를 받지 않음
      }}
    >
      <div
        style={{
          width: `${scaledSize.width}px`,
          height: `${scaledSize.height}px`,
          position: 'relative',
          pointerEvents: 'auto' // 내부 컨테이너는 이벤트를 받음
        }}
        onClick={(e) => {
          // 빈 공간 클릭 시 선택 해제
          if (e.target === e.currentTarget) {
            onSelectClip(null);
          }
        }}
      >
        {showGuides && (
          <div className="absolute inset-0">
            <div className="absolute left-1/2 top-0 bottom-0 w-px bg-cyan-400 opacity-50" />
            <div className="absolute top-1/2 left-0 right-0 h-px bg-cyan-400 opacity-50" />
            <div className="absolute left-1/3 top-0 bottom-0 w-px bg-cyan-400 opacity-30" />
            <div className="absolute left-2/3 top-0 bottom-0 w-px bg-cyan-400 opacity-30" />
            <div className="absolute top-1/3 left-0 right-0 h-px bg-cyan-400 opacity-30" />
            <div className="absolute top-2/3 left-0 right-0 h-px bg-cyan-400 opacity-30" />
          </div>
        )}

        {activeClips.map(clip => {
          const isSelected = selectedClip === clip.id;
          
          const has_custom_position = clip.style?.positionX !== undefined && clip.style?.positionY !== undefined;
          let transform_style = 'translate(-50%, -50%)';
          let x = 0;
          let y = 0;
          if (has_custom_position) {
            x = percentToPixel(clip.style?.positionX, scaledSize.width);
            y = percentToPixel(clip.style?.positionY, scaledSize.height);
            // 항상 중앙 정렬 transform 사용
            transform_style = 'translate(-50%, -50%)';
          } else {
            const vertical = clip.style?.verticalPosition || 'middle';
            const align = clip.style?.alignment || 'center';
            const top_percent = TEXT_POSITION_PRESETS.vertical[vertical as keyof typeof TEXT_POSITION_PRESETS.vertical];
            const left_percent = TEXT_POSITION_PRESETS.horizontal[align as keyof typeof TEXT_POSITION_PRESETS.horizontal];
            x = percentToPixel(left_percent, scaledSize.width);
            y = percentToPixel(top_percent, scaledSize.height);
            // CompositePreview와 동일한 transform 로직 적용
            if (align === 'left') {
              transform_style = 'translateY(-50%)';
            } else if (align === 'right') {
              transform_style = 'translate(-100%, -50%)';
            } else {
              transform_style = 'translate(-50%, -50%)';
            }
          }
          
          const actualFontSize = clip.style?.fontSize || TEXT_DEFAULTS.fontSize;
          const fontSizeRatio = clip.style?.fontSizeRatio;
          const fontFamily = clip.style?.fontFamily || TEXT_DEFAULTS.fontFamily;
          const fontWeight = clip.style?.fontWeight || TEXT_DEFAULTS.fontWeight;
          
          // ---- [ 단순화된 텍스트 박스 크기 계산 ] ----
          // 1. 단순화된 텍스트 크기 측정
          const textMeasurement = measureTextSizeSimple(
            clip.content,
            actualFontSize,
            fontSizeRatio,
            fontFamily,
            fontWeight
          );
          
          const { width: textWidth, height: textHeight } = textMeasurement;
          
          // 2. 패딩 계산 - 상대적 크기 적용
          const hasBackground = !!clip.style?.backgroundColor;
          const scale = displayScale; // Remotion Player와 동일 스케일 사용
          // 상대적 패딩 계산
          const containerSize = getContainerSize();
          const paddingX = hasBackground ? ratioToPixels(TEXT_PADDING.horizontalRatio, containerSize.width) * scale : 0;
          const paddingY = hasBackground ? ratioToPixels(TEXT_PADDING.verticalRatio, containerSize.height) * scale : 0;
          
          // 3. 박스 크기 계산 - 콘텐츠(width/height) + 패딩을 스케일링
          const boxWidth = (textWidth * scale) + (paddingX * 2);
          const boxHeight = (textHeight * scale) + (paddingY * 2);
          
          // 4. 시각적 스타일 조정
          const cornerSize = 12 * scale; // 항상 같은 크기의 코너 사용
          // ---- [ 단순화 종료 ] ----

          return (
            <div
              key={clip.id}
              className="absolute"
              style={{
                left: `${x}px`,
                top: `${y}px`,
                transform: transform_style,
                cursor: draggedClip === clip.id ? 'grabbing' : 'grab',
                transition: draggedClip === clip.id ? 'none' : 'all 0.1s',
                pointerEvents: 'auto', // 명시적으로 포인터 이벤트 활성화
                zIndex: isSelected ? 52 : 51 // 선택된 요소를 위로
              }}
              onMouseDown={(e) => handleMouseDown(e, clip.id)}
              onClick={(e) => {
                e.stopPropagation();
                onSelectClip(clip.id);
              }}
            >
              {/* 상호작용 및 테두리를 위한 박스 (텍스트는 렌더링하지 않음) */}
              <div
                style={{
                  // 명시적으로 크기 지정하여 정확한 래핑 구현
                  width: `${boxWidth}px`,
                  height: `${boxHeight}px`,
                  
                  // 상대적 패딩 - 대칭 적용
                  padding: hasBackground 
                    ? `${paddingY}px ${paddingX}px` 
                    : '0',
                  backgroundColor: isSelected ? 'rgba(56, 244, 124, 0.1)' : 'transparent', // 선택 시 약간 보이게
                  borderRadius: '8px',
                  border: isSelected ? '1px solid rgba(56, 244, 124, 0.3)' : '2px solid transparent',
                  boxSizing: 'border-box',
                  userSelect: 'none',
                  cursor: 'move',
                  position: 'relative',
                  
                  // 그림자/글로우 제거하여 실제 렌더 텍스트만 보이게 함
                  boxShadow: 'none',
                }}
              >
                {/* 텍스트는 표시하지 않음. 실제 Remotion 텍스트가 아래에서 보임 */}
                {/* 코너 마커 - 선택 시에만 표시 (모든 크기에서 표시) */}
                {isSelected && (
                  <>
                    {/* Top-left corner */}
                    <div 
                      style={{
                        position: 'absolute',
                        top: -2,
                        left: -2,
                        width: `${cornerSize}px`,
                        height: `${cornerSize}px`,
                        borderTop: '2px solid rgba(255, 255, 255, 0.8)',
                        borderLeft: '2px solid rgba(255, 255, 255, 0.8)',
                        pointerEvents: 'none',
                      }}
                    />
                    {/* Top-right corner */}
                    <div 
                      style={{
                        position: 'absolute',
                        top: -2,
                        right: -2,
                        width: `${cornerSize}px`,
                        height: `${cornerSize}px`,
                        borderTop: '2px solid rgba(255, 255, 255, 0.8)',
                        borderRight: '2px solid rgba(255, 255, 255, 0.8)',
                        pointerEvents: 'none',
                      }}
                    />
                    {/* Bottom-left corner */}
                    <div 
                      style={{
                        position: 'absolute',
                        bottom: -2,
                        left: -2,
                        width: `${cornerSize}px`,
                        height: `${cornerSize}px`,
                        borderBottom: '2px solid rgba(255, 255, 255, 0.8)',
                        borderLeft: '2px solid rgba(255, 255, 255, 0.8)',
                        pointerEvents: 'none',
                      }}
                    />
                    {/* Bottom-right corner */}
                    <div 
                      style={{
                        position: 'absolute',
                        bottom: -2,
                        right: -2,
                        width: `${cornerSize}px`,
                        height: `${cornerSize}px`,
                        borderBottom: '2px solid rgba(255, 255, 255, 0.8)',
                        borderRight: '2px solid rgba(255, 255, 255, 0.8)',
                        pointerEvents: 'none',
                      }}
                    />
                  </>
                )}
              </div>

              {isSelected && (
                <>
                  <div
                    className="absolute bottom-0 right-0 bg-white border-2 border-gray-700 rounded-full cursor-se-resize pointer-events-auto"
                    style={{ 
                      width: `${16 * scale}px`,
                      height: `${16 * scale}px`,
                      transform: 'translate(50%, 50%)' 
                    }}
                    onMouseDown={(e) => handleResizeStart(e, clip.id)}
                  />
                  <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-black/80 text-white text-xs px-2 py-1 rounded whitespace-nowrap">
                    Size: {fontSizeRatio ? Math.round(fontSizeRatio * 1080) : actualFontSize}px
                  </div>
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="app/video-editor/_context/ClipContext.tsx">
'use client';

import { createContext, useContext, useState, useCallback, useMemo, useEffect, ReactNode } from 'react';
import { VideoClip, TextClip, SoundClip, LibraryVideo, LibraryProject, UserUploadedVideo, LibraryItem } from '@/types/video-editor';
import { toast } from 'sonner';
import {
  duplicateVideoClip,
  duplicateTextClip,
  duplicateSoundClip,
  splitVideoClip,
  splitTextClip,
  splitSoundClip,
  applyResizeTrim,
} from '../_utils/clip-operations';
import { analyzeAudioFile } from '../_utils/audio-analysis';
import { calculateTimelineDuration } from '../_utils/timeline-helpers';

interface ClipContextType {
  // 상태
  timelineClips: VideoClip[];
  textClips: TextClip[];
  soundClips: SoundClip[];
  selectedTextClip: string | null;
  
  // Setter 함수들
  setTimelineClips: React.Dispatch<React.SetStateAction<VideoClip[]>>;
  setTextClips: React.Dispatch<React.SetStateAction<TextClip[]>>;
  setSoundClips: React.Dispatch<React.SetStateAction<SoundClip[]>>;
  setSelectedTextClip: React.Dispatch<React.SetStateAction<string | null>>;
  
  // 비디오 클립 관련 함수
  handleAddToTimeline: (items: LibraryItem[]) => Promise<void>;
  handleDeleteVideoClip: (id: string) => void;
  handleDuplicateVideoClip: (id: string) => void;
  handleSplitVideoClip: (id: string, currentTime: number, pixelsPerSecond: number) => void;
  handleResizeVideoClip: (id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => void;
  handleUpdateVideoClipPosition: (id: string, newPosition: number) => void;
  handleUpdateAllVideoClips: (newClips: VideoClip[]) => void;
  handleReorderVideoClips: (newClips: VideoClip[]) => void;
  
  // 텍스트 클립 관련 함수
  handleAddTextClip: (textData: Partial<TextClip>) => void;
  handleEditTextClip: (clip: TextClip) => void;
  handleDeleteTextClip: (id: string) => void;
  handleDuplicateTextClip: (id: string) => void;
  handleSplitTextClip: (id: string, currentTime: number, pixelsPerSecond: number) => void;
  handleResizeTextClip: (id: string, newDuration: number) => void;
  handleUpdateTextClipPosition: (id: string, newPosition: number) => void;
  handleUpdateAllTextClips: (newClips: TextClip[]) => void;
  handleReorderTextClips: (newClips: TextClip[]) => void;
  handleUpdateTextPosition: (id: string, x: number, y: number) => void;
  handleUpdateTextSize: (id: string, fontSize: number, fontSizeRatio: number) => void;
  
  // 사운드 클립 관련 함수
  handleAddSoundClip: (soundData: Partial<SoundClip>) => void;
  handleAddSoundClips: (sounds: { name: string; url: string; duration: number }[]) => Promise<void>;
  handleDeleteSoundClip: (id: string) => void;
  handleDuplicateSoundClip: (id: string) => void;
  handleSplitSoundClip: (id: string, currentTime: number, pixelsPerSecond: number) => void;
  handleResizeSoundClip: (id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => void;
  handleUpdateSoundClipPosition: (id: string, newPosition: number) => void;
  handleUpdateAllSoundClips: (newClips: SoundClip[]) => void;
  handleReorderSoundClips: (newClips: SoundClip[]) => void;
  handleUpdateSoundVolume: (id: string, volume: number) => void;
  handleUpdateSoundFade: (id: string, fadeType: 'fadeIn' | 'fadeOut', duration: number) => void;
  
  // 편집 상태
  editingTextClip?: TextClip;
  setEditingTextClip: React.Dispatch<React.SetStateAction<TextClip | undefined>>;
  
  // 히스토리 저장 콜백 (HistoryContext에서 주입)
  saveToHistory?: () => void;
  setSaveToHistoryCallback?: React.Dispatch<React.SetStateAction<(() => void) | null>>;
}

export const ClipContext = createContext<ClipContextType | undefined>(undefined);

const PIXELS_PER_SECOND = 40;
const MAX_TIMELINE_DURATION_SECONDS = 120; // 2분 제한

interface ClipProviderProps {
  children: ReactNode;
}

export function ClipProvider({ children }: ClipProviderProps) {
  // 상태 (page.tsx에서 그대로 가져옴)
  const [timelineClips, setTimelineClips] = useState<VideoClip[]>([]);
  const [textClips, setTextClips] = useState<TextClip[]>([]);
  const [soundClips, setSoundClips] = useState<SoundClip[]>([]);
  const [selectedTextClip, setSelectedTextClip] = useState<string | null>(null);
  const [editingTextClip, setEditingTextClip] = useState<TextClip | undefined>(undefined);
  
  // 기본 saveToHistory 함수 (나중에 HistoryContext와 연결)
  const [saveToHistoryCallback, setSaveToHistoryCallback] = useState<(() => void) | null>(null);
  
  const saveToHistory = useCallback(() => {
    if (saveToHistoryCallback) {
      saveToHistoryCallback();
    }
  }, [saveToHistoryCallback]);
  
  // 마지막 경고 시간 추적 (중복 경고 방지)
  const [lastWarningTime, setLastWarningTime] = useState<number>(0);
  
  // 타임라인 전체 길이 모니터링
  useEffect(() => {
    const totalDuration = calculateTimelineDuration(timelineClips, textClips, soundClips, PIXELS_PER_SECOND);
    const isOverLimit = totalDuration > MAX_TIMELINE_DURATION_SECONDS;
    
    if (isOverLimit) {
      const now = Date.now();
      // 5초 내 중복 경고 방지
      if (now - lastWarningTime > 5000) {
        const minutes = Math.floor(totalDuration / 60);
        const seconds = Math.floor(totalDuration % 60);
        toast.warning(
          `Timeline cannot exceed 2 minutes (Current: ${minutes}m ${seconds}s)`,
          { duration: 5000 }
        );
        setLastWarningTime(now);
      }
    }
  }, [timelineClips, textClips, soundClips, lastWarningTime]);
  
  // 비디오 URL로부터 길이(초)를 읽어오는 헬퍼 (page.tsx에서 그대로)
  const getVideoDurationSeconds = useCallback((url?: string): Promise<number> => {
    return new Promise((resolve) => {
      if (!url) {
        resolve(0);
        return;
      }
      try {
        const videoEl = document.createElement('video');
        videoEl.preload = 'metadata';
        videoEl.src = url;
        const onLoaded = () => {
          const seconds = isFinite(videoEl.duration) ? videoEl.duration : 0;
          cleanup();
          resolve(seconds || 0);
        };
        const onError = () => {
          cleanup();
          resolve(0);
        };
        const cleanup = () => {
          videoEl.removeEventListener('loadedmetadata', onLoaded);
          videoEl.removeEventListener('error', onError);
        };
        videoEl.addEventListener('loadedmetadata', onLoaded);
        videoEl.addEventListener('error', onError);
      } catch {
        resolve(0);
      }
    });
  }, []);
  
  // URL에서 파일명 추출 (page.tsx에서 그대로)
  const extractTitleFromUrl = useCallback((url?: string): string | null => {
    if (!url) return null;
    try {
      const pathname = new URL(url).pathname;
      const parts = pathname.split('/').filter(Boolean);
      const last = parts[parts.length - 1];
      if (!last) return null;
      const base = last.split('?')[0].split('#')[0];
      const noExt = base.includes('.') ? base.substring(0, base.lastIndexOf('.')) : base;
      return decodeURIComponent(noExt);
    } catch {
      return null;
    }
  }, []);
  
  // 비디오 클립 추가 (LibraryItem 처리)
  const handleAddToTimeline = useCallback(async (items: LibraryItem[]) => {
    const { getTimelineEnd } = await import('../_utils/timeline-utils');
    
    const default_px = 240;
    const startPosition = getTimelineEnd(timelineClips);
    
    let currentPosition = startPosition;
    const newClips: VideoClip[] = [];
    
    for (const [index, item] of items.entries()) {
      let clipId: string;
      let url: string;
      let thumbnail: string | undefined;
      let title: string;
      let sourceType: 'clip' | 'upload' | 'project' = 'clip';
      
      if (item.type === 'clip') {
        const video = item.data as LibraryVideo;
        // job_id를 포함한 clipId 생성 (비디오 기반 음악 생성을 위해)
        clipId = `clip-${video.job_id}-${Date.now()}-${index}`;
        url = video.output_video_url;
        thumbnail = video.input_image_url;
        title = video.selected_effects?.[0]?.name || extractTitleFromUrl(video.output_video_url) || 'Video Clip';
        sourceType = 'clip'; // AI generated clip
        
        // 디버깅 로그
        console.log('Creating VideoClip from library video:', {
          originalJobId: video.job_id,
          newClipId: clipId,
          sourceType
        });
      } else if (item.type === 'project') {
        const project = item.data as LibraryProject;
        // 프로젝트는 render_id 또는 project_id 사용
        clipId = `project-${project.id}-${Date.now()}-${index}`;
        url = project.latest_video_url || '';
        thumbnail = project.thumbnail_url || undefined; // 프로젝트 썸네일 사용
        title = project.project_name || 'Project';
        sourceType = 'project'; // Project-based video
        
        // 디버깅 로그
        console.log('Creating VideoClip from project:', {
          projectId: project.id,
          newClipId: clipId,
          hasVideo: !!url,
          hasThumbnail: !!project.thumbnail_url,
          thumbnailUrl: project.thumbnail_url
        });
        
        if (!url) {
          toast.error(`Project "${title}" doesn't have a rendered video`);
          continue;
        }
      } else {
        const upload = item.data as UserUploadedVideo & { url?: string };
        // 업로드된 비디오 처리
        clipId = `upload-${upload.id}-${Date.now()}-${index}`;
        url = upload.url || '';
        thumbnail = upload.thumbnail_url || undefined; // 업로드 시 생성된 썸네일 사용
        title = upload.file_name || 'Uploaded Video';
        sourceType = 'upload'; // User uploaded video
        
        // 디버깅 로그
        console.log('Creating VideoClip from upload:', {
          uploadId: upload.id,
          newClipId: clipId,
          hasVideo: !!url,
          hasThumbnail: !!upload.thumbnail_url,
          thumbnailUrl: upload.thumbnail_url
        });
        
        if (!url) {
          toast.error(`Upload "${title}" doesn't have a valid video URL`);
          continue;
        }
      }
      
      const newClip: VideoClip = {
        id: clipId,
        duration: default_px,
        position: currentPosition,
        thumbnails: 1,
        url,
        sourceType,
        thumbnail,
        title,
        maxDuration: default_px,
        startTime: 0,
        endTime: undefined,
      };
      
      newClips.push(newClip);
      currentPosition += default_px;
      
      // 백그라운드에서 실제 duration 계산
      getVideoDurationSeconds(url).then((duration_seconds) => {
        const min_px = 80;
        const computed_px = Math.max(min_px, Math.round((duration_seconds || 0) * PIXELS_PER_SECOND));
        
        setTimelineClips(prev => {
          const clipIndex = prev.findIndex(c => c.id === clipId);
          if (clipIndex === -1) return prev;
          
          const oldDuration = prev[clipIndex].duration;
          const durationDiff = computed_px - oldDuration;
          
          return prev.map((clip, idx) => {
            if (clip.id === clipId) {
              return { ...clip, duration: computed_px, maxDuration: computed_px };
            } else if (idx > clipIndex) {
              return { ...clip, position: clip.position + durationDiff };
            }
            return clip;
          });
        });
      });
    }
    
    setTimelineClips(prev => [...prev, ...newClips]);
    saveToHistory();
  }, [timelineClips, extractTitleFromUrl, getVideoDurationSeconds, saveToHistory]);
  
  // 비디오 클립 삭제
  const handleDeleteVideoClip = useCallback((id: string) => {
    setTimelineClips(prev => prev.filter(c => c.id !== id));
    saveToHistory();
  }, [saveToHistory]);
  
  // 비디오 클립 복제
  const handleDuplicateVideoClip = useCallback((id: string) => {
    const clip = timelineClips.find(c => c.id === id);
    if (!clip) return;
    
    const duplicatedClip = duplicateVideoClip(clip, timelineClips);
    setTimelineClips([...timelineClips, duplicatedClip]);
    saveToHistory();
  }, [timelineClips, saveToHistory]);
  
  // 비디오 클립 분할
  const handleSplitVideoClip = useCallback((id: string, currentTime: number, pixelsPerSecond: number) => {
    const clip = timelineClips.find(c => c.id === id);
    if (!clip) return;
    
    const playheadPosition = currentTime * pixelsPerSecond;
    const result = splitVideoClip(clip, playheadPosition, pixelsPerSecond);
    
    if (result) {
      const { firstClip, secondClip } = result;
      setTimelineClips(timelineClips.map(c => 
        c.id === id ? firstClip : c
      ).concat(secondClip));
      saveToHistory();
    }
  }, [timelineClips, saveToHistory]);
  
  // 비디오 클립 리사이즈
  const handleResizeVideoClip = useCallback((id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => {
    if (newDuration <= 0) {
      console.error('[ClipContext] Invalid newDuration:', newDuration, 'for clip:', id);
      return;
    }
    
    setTimelineClips(prev => prev.map(clip => {
      if (clip.id !== id) return clip;
      const updates = applyResizeTrim(clip, newDuration, handle, deltaPosition, PIXELS_PER_SECOND);
      return { ...clip, ...updates };
    }));
  }, []);
  
  // 비디오 클립 위치 업데이트
  const handleUpdateVideoClipPosition = useCallback((id: string, newPosition: number) => {
    setTimelineClips(prev => prev.map(clip => 
      clip.id === id ? { ...clip, position: newPosition } : clip
    ));
    saveToHistory();
  }, [saveToHistory]);
  
  // 모든 비디오 클립 업데이트
  const handleUpdateAllVideoClips = useCallback((newClips: VideoClip[]) => {
    setTimelineClips(newClips);
    saveToHistory();
  }, [saveToHistory]);
  
  // 비디오 클립 재정렬
  const handleReorderVideoClips = useCallback((newClips: VideoClip[]) => {
    setTimelineClips(newClips);
  }, []);
  
  // 텍스트 클립 추가
  const handleAddTextClip = useCallback((textData: Partial<TextClip>) => {
    if (editingTextClip) {
      setTextClips(textClips.map(clip => 
        clip.id === editingTextClip.id 
          ? { 
              ...clip, 
              content: textData.content || clip.content,
              style: textData.style || clip.style,
              effect: textData.effect !== undefined ? textData.effect : clip.effect,
              // position과 duration은 명시적으로 전달되지 않으면 기존 값 유지
              position: textData.position !== undefined ? textData.position : clip.position,
              duration: textData.duration !== undefined ? textData.duration : clip.duration,
            } 
          : clip
      ));
      saveToHistory();
    } else {
      import('../_utils/timeline-utils').then(({ getTimelineEnd }) => {
        const duration = textData.duration || 200;
        const position = getTimelineEnd(textClips);
        
        const newTextClip: TextClip = {
          id: `text-${Date.now()}`,
          content: textData.content || '',
          duration: duration,
          position: textData.position || position,
          style: textData.style || {
            fontSize: 24,
            fontFamily: 'default',
            color: '#FFFFFF',
            alignment: 'center',
          },
          effect: textData.effect,
        };
        
        setTextClips([...textClips, newTextClip]);
        saveToHistory();
      });
    }
    setEditingTextClip(undefined);
  }, [editingTextClip, textClips, saveToHistory]);
  
  // 텍스트 클립 편집
  const handleEditTextClip = useCallback((clip: TextClip) => {
    setEditingTextClip(clip);
  }, []);
  
  // 텍스트 클립 삭제
  const handleDeleteTextClip = useCallback((id: string) => {
    setTextClips(prev => prev.filter(c => c.id !== id));
    saveToHistory();
  }, [saveToHistory]);
  
  // 텍스트 클립 복제
  const handleDuplicateTextClip = useCallback((id: string) => {
    const clip = textClips.find(c => c.id === id);
    if (!clip) return;
    
    const duplicatedClip = duplicateTextClip(clip, textClips);
    setTextClips([...textClips, duplicatedClip]);
    saveToHistory();
  }, [textClips, saveToHistory]);
  
  // 텍스트 클립 분할
  const handleSplitTextClip = useCallback((id: string, currentTime: number, pixelsPerSecond: number) => {
    const clip = textClips.find(c => c.id === id);
    if (!clip) return;
    
    const playheadPosition = currentTime * pixelsPerSecond;
    const result = splitTextClip(clip, playheadPosition);
    
    if (result) {
      const { firstClip, secondClip } = result;
      setTextClips(textClips.map(c => 
        c.id === id ? firstClip : c
      ).concat(secondClip));
      saveToHistory();
    }
  }, [textClips, saveToHistory]);
  
  // 텍스트 클립 리사이즈
  const handleResizeTextClip = useCallback((id: string, newDuration: number) => {
    setTextClips(textClips.map(clip => 
      clip.id === id ? { ...clip, duration: newDuration } : clip
    ));
  }, [textClips]);
  
  // 텍스트 클립 위치 업데이트
  const handleUpdateTextClipPosition = useCallback((id: string, newPosition: number) => {
    setTextClips(prev => prev.map(clip => 
      clip.id === id ? { ...clip, position: newPosition } : clip
    ));
    saveToHistory();
  }, [saveToHistory]);
  
  // 모든 텍스트 클립 업데이트
  const handleUpdateAllTextClips = useCallback((newClips: TextClip[]) => {
    setTextClips(newClips);
    saveToHistory();
  }, [saveToHistory]);
  
  // 텍스트 클립 재정렬
  const handleReorderTextClips = useCallback((newClips: TextClip[]) => {
    setTextClips(newClips);
  }, []);
  
  // 텍스트 위치 업데이트 (화면에서 드래그)
  const handleUpdateTextPosition = useCallback((id: string, x: number, y: number) => {
    setTextClips(prev => prev.map(clip => 
      clip.id === id 
        ? { ...clip, style: { ...clip.style, positionX: x, positionY: y } }
        : clip
    ));
    saveToHistory();
  }, [saveToHistory]);
  
  // 텍스트 크기 업데이트
  const handleUpdateTextSize = useCallback((id: string, fontSize: number, fontSizeRatio: number) => {
    setTextClips(prev => prev.map(clip => 
      clip.id === id 
        ? { ...clip, style: { ...clip.style, fontSize, fontSizeRatio } }
        : clip
    ));
    saveToHistory();
  }, [saveToHistory]);
  
  // 사운드 클립 추가
  const handleAddSoundClip = useCallback(async (soundData: Partial<SoundClip>) => {
    const newSoundClip: SoundClip = {
      id: `sound-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      name: soundData.name || 'New Sound',
      duration: soundData.duration || 300,
      position: soundData.position ?? 0,
      volume: soundData.volume || 100,
      url: soundData.url,
      maxDuration: soundData.maxDuration,
      isAnalyzing: true, // Start analyzing
    };
    setSoundClips([...soundClips, newSoundClip]);
    saveToHistory();
    
    // Analyze audio file asynchronously if URL is provided
    if (newSoundClip.url) {
      try {
        const analysisResult = await analyzeAudioFile(newSoundClip.url);
        setSoundClips(prev => prev.map(clip => 
          clip.id === newSoundClip.id 
            ? { ...clip, waveformData: analysisResult.waveformData, isAnalyzing: false }
            : clip
        ));
      } catch (error) {
        console.error('Failed to analyze audio:', error);
        // Remove analyzing flag on error
        setSoundClips(prev => prev.map(clip => 
          clip.id === newSoundClip.id 
            ? { ...clip, isAnalyzing: false }
            : clip
        ));
      }
    }
  }, [soundClips, saveToHistory]);
  
  // 여러 사운드 클립 추가 (SoundLibraryModal에서 사용)
  const handleAddSoundClips = useCallback(async (sounds: { name: string; url: string; duration: number }[]) => {
    const { getTimelineEnd } = await import('../_utils/timeline-utils');
    
    // Get the end position of existing clips
    let currentPosition = getTimelineEnd(soundClips);
    
    // 여러 사운드를 한 번에 처리
    const newSoundClips = sounds.map((sound, index) => {
      const durationInPixels = Math.round(sound.duration * PIXELS_PER_SECOND);
      
      const newClip: SoundClip = {
        id: `sound-${Date.now()}-${index}-${Math.random().toString(36).substr(2, 9)}`,
        name: sound.name,
        url: sound.url,
        duration: durationInPixels,
        maxDuration: durationInPixels,
        position: currentPosition,
        volume: 100,
        isAnalyzing: true, // Start analyzing
      };
      
      // Update position for next clip
      currentPosition += durationInPixels;
      
      return newClip;
    });
    
    // Add all clips at once
    setSoundClips([...soundClips, ...newSoundClips]);
    saveToHistory();
    
    // Analyze audio files asynchronously
    newSoundClips.forEach(async (clip) => {
      if (clip.url) {
        try {
          const analysisResult = await analyzeAudioFile(clip.url);
          setSoundClips(prev => prev.map(c => 
            c.id === clip.id 
              ? { ...c, waveformData: analysisResult.waveformData, isAnalyzing: false }
              : c
          ));
        } catch (error) {
          console.error(`Failed to analyze audio for ${clip.name}:`, error);
          // Remove analyzing flag on error
          setSoundClips(prev => prev.map(c => 
            c.id === clip.id 
              ? { ...c, isAnalyzing: false }
              : c
          ));
        }
      }
    });
  }, [soundClips, saveToHistory]);
  
  // 사운드 클립 삭제
  const handleDeleteSoundClip = useCallback((id: string) => {
    setSoundClips(prev => prev.filter(c => c.id !== id));
    saveToHistory();
  }, [saveToHistory]);
  
  // 사운드 클립 복제
  const handleDuplicateSoundClip = useCallback((id: string) => {
    const clip = soundClips.find(c => c.id === id);
    if (!clip) return;
    
    const duplicatedClip = duplicateSoundClip(clip, soundClips);
    setSoundClips([...soundClips, duplicatedClip]);
    saveToHistory();
  }, [soundClips, saveToHistory]);
  
  // 사운드 클립 분할
  const handleSplitSoundClip = useCallback((id: string, currentTime: number, pixelsPerSecond: number) => {
    const clip = soundClips.find(c => c.id === id);
    if (!clip) return;
    
    const playheadPosition = currentTime * pixelsPerSecond;
    const result = splitSoundClip(clip, playheadPosition, pixelsPerSecond);
    
    if (result) {
      const { firstClip, secondClip } = result;
      setSoundClips(soundClips.map(c => 
        c.id === id ? firstClip : c
      ).concat(secondClip));
      saveToHistory();
    }
  }, [soundClips, saveToHistory]);
  
  // 사운드 클립 리사이즈
  const handleResizeSoundClip = useCallback((id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => {
    setSoundClips(prev => prev.map(clip => {
      if (clip.id !== id) return clip;
      const updates = applyResizeTrim(clip, newDuration, handle, deltaPosition, PIXELS_PER_SECOND);
      return { ...clip, ...updates };
    }));
  }, []);
  
  // 사운드 클립 위치 업데이트
  const handleUpdateSoundClipPosition = useCallback((id: string, newPosition: number) => {
    setSoundClips(prev => prev.map(clip => 
      clip.id === id ? { ...clip, position: newPosition } : clip
    ));
    saveToHistory();
  }, [saveToHistory]);
  
  // 모든 사운드 클립 업데이트
  const handleUpdateAllSoundClips = useCallback((newClips: SoundClip[]) => {
    setSoundClips(newClips);
    saveToHistory();
  }, [saveToHistory]);
  
  // 사운드 클립 재정렬
  const handleReorderSoundClips = useCallback((newClips: SoundClip[]) => {
    setSoundClips(newClips);
  }, []);
  
  // 사운드 클립 음량 업데이트
  const handleUpdateSoundVolume = useCallback((id: string, volume: number) => {
    setSoundClips(prev => prev.map(clip => 
      clip.id === id ? { ...clip, volume } : clip
    ));
    saveToHistory();
  }, [saveToHistory]);
  
  // 사운드 클립 페이드 업데이트
  const handleUpdateSoundFade = useCallback((id: string, fadeType: 'fadeIn' | 'fadeOut', duration: number) => {
    setSoundClips(prev => prev.map(clip => {
      if (clip.id !== id) return clip;
      
      if (fadeType === 'fadeIn') {
        return { ...clip, fadeInDuration: duration };
      } else {
        return { ...clip, fadeOutDuration: duration };
      }
    }));
    saveToHistory();
  }, [saveToHistory]);
  
  // Context value를 useMemo로 최적화
  const value = useMemo(() => ({
    // 상태
    timelineClips,
    textClips,
    soundClips,
    selectedTextClip,
    editingTextClip,
    
    // Setter 함수
    setTimelineClips,
    setTextClips,
    setSoundClips,
    setSelectedTextClip,
    setEditingTextClip,
    
    // 비디오 클립 함수
    handleAddToTimeline,
    handleDeleteVideoClip,
    handleDuplicateVideoClip,
    handleSplitVideoClip,
    handleResizeVideoClip,
    handleUpdateVideoClipPosition,
    handleUpdateAllVideoClips,
    handleReorderVideoClips,
    
    // 텍스트 클립 함수
    handleAddTextClip,
    handleEditTextClip,
    handleDeleteTextClip,
    handleDuplicateTextClip,
    handleSplitTextClip,
    handleResizeTextClip,
    handleUpdateTextClipPosition,
    handleUpdateAllTextClips,
    handleReorderTextClips,
    handleUpdateTextPosition,
    handleUpdateTextSize,
    
    // 사운드 클립 함수
    handleAddSoundClip,
    handleAddSoundClips,
    handleDeleteSoundClip,
    handleDuplicateSoundClip,
    handleSplitSoundClip,
    handleResizeSoundClip,
    handleUpdateSoundClipPosition,
    handleUpdateAllSoundClips,
    handleReorderSoundClips,
    handleUpdateSoundVolume,
    handleUpdateSoundFade,
    
    // 히스토리 저장 (나중에 연결)
    saveToHistory,
    setSaveToHistoryCallback,
  }), [
    timelineClips,
    textClips,
    soundClips,
    selectedTextClip,
    editingTextClip,
    handleAddToTimeline,
    handleDeleteVideoClip,
    handleDuplicateVideoClip,
    handleSplitVideoClip,
    handleResizeVideoClip,
    handleUpdateVideoClipPosition,
    handleUpdateAllVideoClips,
    handleReorderVideoClips,
    handleAddTextClip,
    handleEditTextClip,
    handleDeleteTextClip,
    handleDuplicateTextClip,
    handleSplitTextClip,
    handleResizeTextClip,
    handleUpdateTextClipPosition,
    handleUpdateAllTextClips,
    handleReorderTextClips,
    handleUpdateTextPosition,
    handleUpdateTextSize,
    handleAddSoundClip,
    handleAddSoundClips,
    handleDeleteSoundClip,
    handleDuplicateSoundClip,
    handleSplitSoundClip,
    handleResizeSoundClip,
    handleUpdateSoundClipPosition,
    handleUpdateAllSoundClips,
    handleReorderSoundClips,
    handleUpdateSoundVolume,
    handleUpdateSoundFade,
    saveToHistory,
    setSaveToHistoryCallback,
  ]);
  
  return (
    <ClipContext.Provider value={value}>
      {children}
    </ClipContext.Provider>
  );
}

export function useClips() {
  const context = useContext(ClipContext);
  if (!context) {
    throw new Error('useClips must be used within ClipProvider');
  }
  return context;
}
</file>

<file path="app/video-editor/_components/remotion/CompositePreview.tsx">
import React from 'react';
import { AbsoluteFill, Sequence, OffthreadVideo, Audio, useVideoConfig, useCurrentFrame } from 'remotion';
import { TextClip as TextClipType, SoundClip as SoundClipType } from '@/types/video-editor';
import { TEXT_DEFAULTS, TEXT_PADDING, TEXT_POSITION_PRESETS, TEXT_ANIMATION, pxToFrames, ratioToPixels, pixelsToRatio } from '../../../../constants/text-editor';

interface VideoClip {
  id: string;
  duration: number;
  position?: number;
  url?: string;
  title?: string;
  startTime?: number;
  endTime?: number;
}

interface CompositePreviewProps {
  videoClips: VideoClip[];
  textClips: TextClipType[];
  soundClips: SoundClipType[];
  backgroundColor?: string;
}

// Audio component with fade in/out support
const AudioWithFade: React.FC<{
  src: string;
  baseVolume: number;
  fadeInFrames: number;
  fadeOutFrames: number;
  totalFrames: number;
  startFrom?: number;
  endAt?: number;
  fadeInType?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out';
  fadeOutType?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out';
}> = ({ 
  src, 
  baseVolume, 
  fadeInFrames, 
  fadeOutFrames, 
  totalFrames, 
  startFrom, 
  endAt,
  fadeInType = 'linear',
  fadeOutType = 'linear'
}) => {
  const frame = useCurrentFrame();
  
  // Calculate fade volume
  let fadeMultiplier = 1;
  
  // Apply fade in with more dramatic curve
  if (fadeInFrames > 0 && frame < fadeInFrames) {
    const fadeInProgress = frame / fadeInFrames;
    
    switch (fadeInType) {
      case 'ease-in':
        // More dramatic cubic curve for slower start
        fadeMultiplier = fadeInProgress * fadeInProgress * fadeInProgress;
        break;
      case 'ease-out':
        // Fast rise, then slow down (more dramatic)
        fadeMultiplier = 1 - Math.pow(1 - fadeInProgress, 3);
        break;
      case 'ease-in-out':
        // S-curve with more dramatic acceleration/deceleration
        fadeMultiplier = fadeInProgress < 0.5
          ? 4 * fadeInProgress * fadeInProgress * fadeInProgress
          : 1 - Math.pow(-2 * fadeInProgress + 2, 3) / 2;
        break;
      case 'linear':
      default:
        fadeMultiplier = fadeInProgress;
        break;
    }
  }
  
  // Apply fade out with more dramatic curve
  const fadeOutStart = totalFrames - fadeOutFrames;
  if (fadeOutFrames > 0 && frame >= fadeOutStart) {
    const fadeOutProgress = (totalFrames - frame) / fadeOutFrames;
    
    switch (fadeOutType) {
      case 'ease-in':
        // More dramatic cubic curve for gradual then fast drop
        fadeMultiplier = Math.pow(fadeOutProgress, 3);
        break;
      case 'ease-out':
        // Fast drop then slow (more dramatic)
        fadeMultiplier = 1 - Math.pow(1 - fadeOutProgress, 3);
        break;
      case 'ease-in-out':
        // S-curve with more dramatic acceleration/deceleration
        fadeMultiplier = fadeOutProgress < 0.5
          ? 4 * fadeOutProgress * fadeOutProgress * fadeOutProgress
          : 1 - Math.pow(-2 * fadeOutProgress + 2, 3) / 2;
        break;
      case 'linear':
      default:
        fadeMultiplier = fadeOutProgress;
        break;
    }
  }
  
  const finalVolume = baseVolume * fadeMultiplier;
  
  return (
    <Audio 
      src={src} 
      volume={finalVolume}
      startFrom={startFrom}
      endAt={endAt}
    />
  );
};

export const CompositePreview: React.FC<CompositePreviewProps> = ({ 
  videoClips, 
  textClips, 
  soundClips,
  backgroundColor = 'black'
}) => {
  const { width, height } = useVideoConfig();
  // Lambda 환경에서는 폰트가 이미 index.ts에서 로드됨
  // 브라우저 전용 document.fonts.load() 제거
  
  // 비율 계산
  const aspectRatio = width / height;
  const is16by9 = Math.abs(aspectRatio - 16/9) < 0.01;
  const is9by16 = Math.abs(aspectRatio - 9/16) < 0.01;
  const is1by1 = Math.abs(aspectRatio - 1) < 0.01;
  
  // 비디오 클립들을 position 기반으로 배치
  const videoSequences = videoClips
    .filter(clip => clip.url) // URL이 있는 클립만 처리
    .map(clip => {
      // 시작/종료 시간을 프레임으로 변환
      const startFrom = clip.startTime ? Math.round(clip.startTime * 30) : 0;
      
      return {
        id: clip.id,
        url: clip.url!,
        title: clip.title,
        from: pxToFrames(clip.position || 0), // position 값을 사용하여 시작 위치 결정
        durationInFrames: pxToFrames(clip.duration),
        startFrom,
        endAt: clip.endTime ? Math.round(clip.endTime * 30) : undefined
      };
    });
  
  return (
    <AbsoluteFill style={{ backgroundColor }}>
      {/* Letterbox 효과 - 모든 비율에 적용 */}
      {(is16by9 || is9by16 || is1by1) && (
        <>
          {/* 16:9 - 상하 letterbox */}
          {is16by9 && (
            <>
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: '10%',
                  background: 'linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
              <div
                style={{
                  position: 'absolute',
                  bottom: 0,
                  left: 0,
                  right: 0,
                  height: '10%',
                  background: 'linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
            </>
          )}
          
          {/* 9:16 - 좌우 letterbox */}
          {is9by16 && (
            <>
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  bottom: 0,
                  width: '10%',
                  background: 'linear-gradient(to right, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  right: 0,
                  bottom: 0,
                  width: '10%',
                  background: 'linear-gradient(to left, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
            </>
          )}
          
          {/* 1:1 - 네 방향 모두 letterbox */}
          {is1by1 && (
            <>
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  right: 0,
                  height: '8%',
                  background: 'linear-gradient(to bottom, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
              <div
                style={{
                  position: 'absolute',
                  bottom: 0,
                  left: 0,
                  right: 0,
                  height: '8%',
                  background: 'linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  bottom: 0,
                  width: '8%',
                  background: 'linear-gradient(to right, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
              <div
                style={{
                  position: 'absolute',
                  top: 0,
                  right: 0,
                  bottom: 0,
                  width: '8%',
                  background: 'linear-gradient(to left, rgba(0,0,0,0.8), rgba(0,0,0,0))',
                  pointerEvents: 'none',
                  zIndex: 5,
                }}
              />
            </>
          )}
        </>
      )}
      
      {/* 1. 비디오 레이어 - 순차 재생 */}
      {videoSequences.map(video => (
        <Sequence
          key={video.id}
          from={video.from}
          durationInFrames={video.durationInFrames}
          premountFor={Infinity} // 모든 비디오를 미리 마운트하여 끊김 없는 재생
        >
          <OffthreadVideo 
            src={video.url}
            startFrom={video.startFrom}
            endAt={video.endAt}
            pauseWhenBuffering={true} // 버퍼링 시 일시정지하여 끊김 방지
            onError={(e) => {
              console.error(`Video loading error for ${video.id}:`, e);
            }}
            // 첫 번째 비디오는 즉시 로드, 나머지는 순차적으로
            style={{ 
              width: '100%', 
              height: '100%', 
              objectFit: 'contain'
            }}
          />
        </Sequence>
      ))}
      
      {/* 2. 텍스트 오버레이 레이어 */}
      <AbsoluteFill style={{ pointerEvents: 'none', zIndex: 10 }}>
        {textClips.map(text => {
          const textFrom = pxToFrames(text.position || 0);
          const textDuration = pxToFrames(text.duration);
          
          // 텍스트 위치 계산 - 일관된 계산 방식 적용
          const getTextPosition = () => {
            const style = text.style;
            let top = '50%';
            let left = '50%';
            let transform = 'translate(-50%, -50%)';
            
            // positionX와 positionY가 있으면 우선 사용 (드래그로 설정한 커스텀 위치)
            if (style?.positionX !== undefined && style?.positionY !== undefined) {
              // 퍼센트 값 그대로 사용 (TextOverlayEditor와 동일)
              left = `${style.positionX}%`;
              top = `${style.positionY}%`;
              // 항상 중앙 기준으로 변환
              transform = 'translate(-50%, -50%)';
            } else {
              // 프리셋 위치 사용
              // 수직 위치
              const verticalPreset = style?.verticalPosition || 'middle';
              top = `${TEXT_POSITION_PRESETS.vertical[verticalPreset]}%`;
              
              // 수평 위치와 transform 조정
              const horizontalPreset = style?.alignment || 'center';
              left = `${TEXT_POSITION_PRESETS.horizontal[horizontalPreset]}%`;
              
              if (horizontalPreset === 'left') {
                transform = 'translateY(-50%)'; // Y축만 중앙 정렬
              } else if (horizontalPreset === 'right') {
                transform = 'translate(-100%, -50%)'; // 우측 정렬
              } else {
                transform = 'translate(-50%, -50%)'; // 완전 중앙 정렬
              }
            }
            
            return { top, left, transform };
          };
          
          const position = getTextPosition();
          const textAlign: 'left' | 'center' | 'right' = text.style?.alignment || 'center';
          
          // 상대적 크기 계산
          const actualFontSize = (() => {
            // fontSizeRatio가 있으면 우선 사용
            if (text.style?.fontSizeRatio !== undefined) {
              return ratioToPixels(text.style.fontSizeRatio, width);
            }
            // 기존 fontSize를 비율로 변환 (1080px 기준)
            const baseWidth = 1080;
            const ratio = pixelsToRatio(text.style?.fontSize || TEXT_DEFAULTS.fontSize, baseWidth);
            return ratioToPixels(ratio, width);
          })();
          
          // 상대적 패딩 계산
          const hasBackground = !!text.style?.backgroundColor;
          const paddingH = hasBackground ? ratioToPixels(TEXT_PADDING.horizontalRatio, width) : 0;
          const paddingV = hasBackground ? ratioToPixels(TEXT_PADDING.verticalRatio, height) : 0;
          
          return (
            <Sequence
              key={text.id}
              from={textFrom}
              durationInFrames={textDuration}
            >
              <div
                style={{
                  position: 'absolute',
                  ...position,
                  // 텍스트 박스 크기를 적절히 제한
                  maxWidth: `${TEXT_DEFAULTS.maxWidthRatio * 100}%`,
                  padding: hasBackground ? `${paddingV}px ${paddingH}px` : '0',
                  backgroundColor: text.style?.backgroundColor || 'transparent',
                  opacity: text.style?.backgroundOpacity ?? 1,
                  borderRadius: `${TEXT_ANIMATION.borderRadius}px`
                }}
              >
                <h1 style={{
                  fontSize: actualFontSize, // 상대적 크기 사용
                  color: text.effect === 'gradient' ? 'transparent' : (text.style?.color || TEXT_DEFAULTS.color),
                  fontFamily: (() => {
                    const baseFont = text.style?.fontFamily || TEXT_DEFAULTS.fontFamily;
                    if (baseFont === 'default') return 'sans-serif';
                    // Script/Cursive 폰트들
                    if (['Dancing Script', 'Pacifico', 'Lobster'].includes(baseFont)) {
                      return `"${baseFont}", cursive, sans-serif`;
                    }
                    // Serif 폰트들
                    if (['Playfair Display', 'Merriweather'].includes(baseFont)) {
                      return `"${baseFont}", serif, sans-serif`;
                    }
                    // Display 폰트들
                    if (['Bebas Neue', 'Oswald'].includes(baseFont)) {
                      return `"${baseFont}", Impact, sans-serif`;
                    }
                    // Sans-serif 폰트들 (기본)
                    return `"${baseFont}", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
                  })(),
                  fontWeight: text.style?.fontWeight || TEXT_DEFAULTS.fontWeight,
                  textShadow: text.effect === 'gradient' || text.effect === 'glow' ? 'none' : `
                    3px 3px 6px rgba(0,0,0,0.9),
                    -1px -1px 2px rgba(0,0,0,0.5),
                    1px -1px 2px rgba(0,0,0,0.5),
                    -1px 1px 2px rgba(0,0,0,0.5),
                    1px 1px 2px rgba(0,0,0,0.5)
                  `, // 더 강한 그림자 (gradient와 glow 제외)
                  textAlign,
                  margin: 0,
                  padding: 0,
                  lineHeight: TEXT_ANIMATION.lineHeight,
                  display: ['spin', 'pulse', 'bounce', 'zoom', 'wave', 'typing'].includes(text.effect || '') ? 'inline-block' : 'block',
                  transformOrigin: 'center',
                  // typing 효과일 때만 whiteSpace 적용
                  whiteSpace: text.effect === 'typing' ? 'nowrap' : 'normal',
                  // 텍스트 효과 추가
                  ...(text.effect === 'none' && {}),
                  ...(text.effect === 'fade' && {
                    animation: 'fadeInOut 2s ease-in-out infinite'
                  }),
                  ...(text.effect === 'slide' && {
                    animation: 'slideIn 1s ease-out'
                  }),
                  ...(text.effect === 'glow' && {
                    textShadow: '0 0 20px rgba(255,255,255,0.9), 0 0 40px rgba(56,244,124,0.7)',
                    animation: 'glow 2s ease-in-out infinite'
                  }),
                  ...(text.effect === 'pulse' && {
                    animation: 'pulse 1.5s ease-in-out infinite'
                  }),
                  ...(text.effect === 'bounce' && {
                    animation: 'bounce 1.5s ease-in-out infinite'
                  }),
                  ...(text.effect === 'gradient' && {
                    background: 'linear-gradient(90deg, #38f47c, #3b82f6, #a855f7, #ec4899, #38f47c)',
                    backgroundSize: '200% auto',
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                    backgroundClip: 'text',
                    animation: 'gradientMove 3s linear infinite'
                  }),
                  ...(text.effect === 'spin' && {
                    animation: 'spin 3s linear infinite'
                  }),
                  ...(text.effect === 'shake' && {
                    animation: 'shake 0.3s ease-in-out infinite'
                  }),
                  ...(text.effect === 'typing' && {
                    overflow: 'hidden',
                    width: '100%',
                    animation: 'typing 4s steps(40, end) infinite',
                    borderRight: '3px solid rgba(255,255,255,0.7)'
                  }),
                  ...(text.effect === 'wave' && {
                    animation: 'wave 2s ease-in-out infinite'
                  }),
                  ...(text.effect === 'zoom' && {
                    animation: 'zoom 2s ease-in-out infinite'
                  })
                }}>
                  {text.content}
                </h1>
              </div>
            </Sequence>
          );
        })}
      </AbsoluteFill>
      
      {/* 3. 오디오 레이어 - 동시 재생 가능 */}
      {soundClips.map(sound => {
        if (!sound.url) {
          return null;
        }
        
        // URL 유효성 체크
        try {
          // data URL이거나 http(s) URL인지 확인
          if (!sound.url.startsWith('data:') && !sound.url.startsWith('http')) {
            return null;
          }
        } catch {
          return null;
        }
        
        const audioFrom = pxToFrames(sound.position || 0);
        const audioDuration = pxToFrames(sound.duration);
        
        // 비디오와 동일한 트리밍 적용
        const startFrom = sound.startTime ? Math.round(sound.startTime * 30) : 0;
        const endAt = sound.endTime ? Math.round(sound.endTime * 30) : undefined;
        
        // Calculate volume (0-100% range, linear mapping)
        const volumeValue = sound.volume !== undefined ? sound.volume : 100;
        const normalizedVolume = volumeValue / 100; // 0% = 0, 100% = 1
        
        // Calculate fade frames
        const fadeInFrames = sound.fadeInDuration ? pxToFrames(sound.fadeInDuration) : 0;
        const fadeOutFrames = sound.fadeOutDuration ? pxToFrames(sound.fadeOutDuration) : 0;
        
        return (
          <Sequence
            key={`${sound.id}-${sound.url}`} // Key based on id and url only, not volume
            from={audioFrom}
            durationInFrames={audioDuration}
          >
            <AudioWithFade
              src={sound.url}
              baseVolume={normalizedVolume}
              fadeInFrames={fadeInFrames}
              fadeOutFrames={fadeOutFrames}
              totalFrames={audioDuration}
              startFrom={startFrom}
              endAt={endAt}
              fadeInType={sound.fadeInType || 'linear'}
              fadeOutType={sound.fadeOutType || 'linear'}
            />
          </Sequence>
        );
      })}
      
      {/* CSS 애니메이션 정의 */}
      <style>{`
        @keyframes fadeInOut {
          0%, 100% { opacity: 0.3; }
          50% { opacity: 1; }
        }
        
        @keyframes slideIn {
          0% { 
            transform: translateX(-100%); 
            opacity: 0; 
          }
          60% { 
            transform: translateX(10px); 
            opacity: 1; 
          }
          100% { 
            transform: translateX(0); 
            opacity: 1; 
          }
        }
        
        @keyframes glow {
          0%, 100% { 
            text-shadow: 0 0 20px rgba(255,255,255,0.7), 0 0 40px rgba(56,244,124,0.5);
          }
          50% { 
            text-shadow: 0 0 30px rgba(255,255,255,0.9), 0 0 60px rgba(56,244,124,0.8);
          }
        }
        
        @keyframes pulse {
          0%, 100% { 
            transform: scale(1); 
            opacity: 1; 
          }
          50% { 
            transform: scale(1.08); 
            opacity: 0.9; 
          }
        }
        
        @keyframes bounce {
          0%, 20%, 50%, 80%, 100% { 
            transform: translateY(0); 
          }
          40% { 
            transform: translateY(-30px); 
          }
          60% { 
            transform: translateY(-15px); 
          }
        }
        
        @keyframes gradientMove {
          0% { background-position: 0% center; }
          100% { background-position: 200% center; }
        }
        
        @keyframes spin {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes shake {
          0%, 100% { transform: translateX(0); }
          10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
          20%, 40%, 60%, 80% { transform: translateX(3px); }
        }
        
        @keyframes typing {
          0%, 10% { 
            width: 0;
            border-right-color: transparent;
          }
          10.1%, 90% { 
            border-right-color: rgba(255,255,255,0.7);
          }
          90%, 100% { 
            width: 100%;
            border-right-color: transparent;
          }
        }
        
        @keyframes wave {
          0%, 100% { 
            transform: translateY(0) rotate(0deg); 
          }
          25% { 
            transform: translateY(-5px) rotate(-2deg); 
          }
          50% { 
            transform: translateY(0) rotate(0deg); 
          }
          75% { 
            transform: translateY(-5px) rotate(2deg); 
          }
        }
        
        @keyframes zoom {
          0%, 100% { 
            transform: scale(1); 
          }
          25% { 
            transform: scale(1.1); 
          }
          50% { 
            transform: scale(1.3); 
          }
          75% { 
            transform: scale(1.1); 
          }
        }
      `}</style>
    </AbsoluteFill>
  );
};
</file>

<file path="app/video-editor/_components/SoundLibraryModal.tsx">
'use client';

import { useState, useRef, useEffect, useContext } from 'react';
import { useTranslation } from '@/hooks/useTranslation';
import { ChevronDown, ChevronRight, Loader2 } from 'lucide-react';
import { VideoClipSelector } from './VideoClipSelector';
import { useVideoSoundGeneration } from '../_hooks/useVideoSoundGeneration';
import { ClipContext } from '../_context/ClipContext';
import { formatSoundDisplayTitle } from '@/lib/sound/utils';
import { SoundGenerationType } from '@/types/sound';

interface SoundLibraryModalProps {
  onClose: () => void;
  onSelectSounds: (sounds: Array<{ name: string; url: string; duration: number }>) => void;
  onCreateVideo?: () => void;
}

interface UploadedAudio {
  id: string;
  name: string;
  url: string;
  duration: number;
  size: number;
}

export default function SoundLibraryModal({ onClose, onSelectSounds }: SoundLibraryModalProps) {
  const { t } = useTranslation();
  const [activeTab, setActiveTab] = useState<'preset' | 'upload' | 'generate'>('preset');
  const [selectedPreset, setSelectedPreset] = useState<string | null>(null);
  const [uploadedAudios, setUploadedAudios] = useState<UploadedAudio[]>([]);
  const [selectedAudioIds, setSelectedAudioIds] = useState<Set<string>>(new Set());
  const [playingAudioId, setPlayingAudioId] = useState<string | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  
  // AI Sound Generation states
  const [soundPrompt, setSoundPrompt] = useState('');
  const [soundTitle, setSoundTitle] = useState('');
  const [soundDuration, setSoundDuration] = useState(8);
  const [isGeneratingSound, setIsGeneratingSound] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [showDurationDropdown, setShowDurationDropdown] = useState(false);
  const [inputMode, setInputMode] = useState<'manual' | 'fromVideo'>('manual');
  const [selectedVideoClip, setSelectedVideoClip] = useState<string | null>(null);
  const [generationType, setGenerationType] = useState<SoundGenerationType>('sound_effect');
  // historyFilter는 아직 UI 구현이 없으므로 setter 제거
  const [historyFilter] = useState<'all' | SoundGenerationType | 'from_video'>('all');
  
  // Get timeline clips from ClipContext
  const clipContext = useContext(ClipContext);
  const timelineClips = clipContext?.timelineClips || [];
  
  // Video-based sound generation hook
  const videoSoundGeneration = useVideoSoundGeneration();
  interface SoundVariation {
    id: string;
    variationNumber: number;
    url: string;
    duration: number;
  }

  interface SoundGroup {
    groupId: string;
    prompt: string;
    title: string | null;
    createdAt: string;
    generationType?: string | null;
    variations: SoundVariation[];
  }
  
  interface JobProgress {
    jobId: string;
    variationNumber: number;
    progress: number;
    status: 'pending' | 'processing' | 'completed' | 'failed';
    result?: {
      url: string;
      title?: string;
      duration: number;
    };
  }

  const [soundGroups, setSoundGroups] = useState<SoundGroup[]>([]);
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());
  const [isLoadingHistory, setIsLoadingHistory] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  
  // 캐싱 관련 ref
  const soundCacheRef = useRef<SoundGroup[]>([]);
  const cacheTimestampRef = useRef<number>(0);
  const lastFilterRef = useRef<string>('all');
  const CACHE_DURATION = 60000; // 1분 캐시
  
  // 진행률 계산 유틸리티 함수
  const calculateProgressForElapsedTime = (elapsedSeconds: number, expectedDuration: number = 15): number => {
    const checkpoints = [
      { time: 2, progress: 15 },
      { time: 4, progress: 30 },
      { time: 6, progress: 50 },
      { time: 8, progress: 65 },
      { time: 10, progress: 80 },
      { time: 12, progress: 88 },
      { time: 15, progress: 90 }
    ];
    
    let targetProgress = 0;
    
    for (let i = 0; i < checkpoints.length; i++) {
      const checkpoint = checkpoints[i];
      const nextCheckpoint = checkpoints[i + 1];
      
      if (elapsedSeconds >= checkpoint.time) {
        if (!nextCheckpoint || elapsedSeconds < nextCheckpoint.time) {
          if (nextCheckpoint) {
            const timeRatio = (elapsedSeconds - checkpoint.time) / (nextCheckpoint.time - checkpoint.time);
            const progressDiff = nextCheckpoint.progress - checkpoint.progress;
            targetProgress = checkpoint.progress + (progressDiff * timeRatio);
          } else {
            targetProgress = checkpoint.progress;
          }
          break;
        }
      } else if (i === 0) {
        targetProgress = (elapsedSeconds / checkpoint.time) * checkpoint.progress;
        break;
      }
    }
    
    if (elapsedSeconds > expectedDuration) {
      const overtime = elapsedSeconds - expectedDuration;
      const slowdown = Math.log(1 + overtime / expectedDuration) * 2;
      targetProgress = Math.max(85, 90 - slowdown);
    }
    
    return Math.min(targetProgress, 90);
  };

  // 프리셋 음악 옵션들
  const presetSounds = [
    { key: 'epicTheme', label: t('videoEditor.controls.soundOptions.epicTheme'), duration: 180 },
    { key: 'dramatic', label: t('videoEditor.controls.soundOptions.dramatic'), duration: 120 },
    { key: 'ambient', label: t('videoEditor.controls.soundOptions.ambient'), duration: 240 },
    { key: 'sfx', label: t('videoEditor.controls.soundOptions.sfx'), duration: 60 },
  ];

  // Generate 탭으로 전환 시 과거 생성 기록 불러오기
  useEffect(() => {
    if (activeTab === 'generate' && !isLoadingHistory) {
      loadSoundHistory(false, historyFilter); // 캐시가 있으면 사용, 없으면 로드
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeTab, historyFilter]); // isLoadingHistory와 loadSoundHistory는 의도적으로 제외

  // Upload 탭으로 전환 시 업로드된 음악 목록 불러오기
  useEffect(() => {
    if (activeTab === 'upload') {
      loadUploadedMusic();
    }
  }, [activeTab]); // loadUploadedMusic는 의도적으로 제외

  // Duration 드롭다운 외부 클릭 감지
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      const target = event.target as HTMLElement;
      if (showDurationDropdown && !target.closest('.duration-dropdown-container')) {
        setShowDurationDropdown(false);
      }
    };

    if (showDurationDropdown) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => {
        document.removeEventListener('mousedown', handleClickOutside);
      };
    }
  }, [showDurationDropdown]);

  const loadSoundHistory = async (forceRefresh = false, filterType = historyFilter) => {
    // 캐시 유효성 검사 (필터가 바뀌면 캐시 무효화)
    const cacheKey = `${filterType}`;
    const now = Date.now();
    if (!forceRefresh && 
        soundCacheRef.current.length > 0 && 
        (now - cacheTimestampRef.current) < CACHE_DURATION &&
        lastFilterRef.current === cacheKey) {
      // 캐시된 데이터 사용
      setSoundGroups(soundCacheRef.current);
      return;
    }

    if (isLoadingHistory) return; // 중복 호출 방지
    
    setIsLoadingHistory(true);
    try {
      const url = filterType === 'all' 
        ? '/api/sound/history'
        : `/api/sound/history?type=${filterType}`;
      
      const response = await fetch(url);
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.groups) {
          // 캐시 업데이트
          soundCacheRef.current = data.groups;
          cacheTimestampRef.current = now;
          lastFilterRef.current = cacheKey;
          
          setSoundGroups(data.groups);
        }
      }
    } catch (error) {
      console.error('Failed to load sound history:', error);
    } finally {
      setIsLoadingHistory(false);
    }
  };

  const loadUploadedMusic = async () => {
    try {
      const response = await fetch('/api/upload/music', {
        method: 'GET',
      });

      if (!response.ok) {
        throw new Error('Failed to load uploaded music');
      }

      const data = await response.json();
      
      if (data.success && data.music) {
        // 서버에서 조회한 음악 파일들을 UploadedAudio 형식으로 변환
        const uploadedMusic: UploadedAudio[] = data.music.map((music: {
          id: number;
          file_name: string;
          url: string;
          duration: number | null;
          file_size: number;
        }) => ({
          id: music.id.toString(),
          name: music.file_name,
          url: music.url,
          duration: music.duration || 0,
          size: music.file_size,
        }));
        
        setUploadedAudios(uploadedMusic);
      }
    } catch (error) {
      console.error('Failed to load uploaded music:', error);
      // 에러 발생 시 빈 배열로 초기화
      setUploadedAudios([]);
    }
  };

  const getAudioDuration = (file: File): Promise<number> => {
    return new Promise((resolve, reject) => {
      const audio = new Audio();
      const url = URL.createObjectURL(file);
      
      audio.addEventListener('loadedmetadata', () => {
        URL.revokeObjectURL(url);
        resolve(audio.duration);
      });
      
      audio.addEventListener('error', () => {
        URL.revokeObjectURL(url);
        reject(new Error('Failed to load audio file'));
      });
      
      audio.src = url;
    });
  };


  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (!files || files.length === 0) return;

    setIsUploading(true);
    const newAudioIds: string[] = [];
    
    try {
      for (const file of Array.from(files)) {
        if (!file.type.startsWith('audio/')) {
          alert(`${file.name} is not an audio file.`);
          continue;
        }

        // 파일 메타데이터 추출
        const duration = await getAudioDuration(file);
        
        // FormData 생성
        const formData = new FormData();
        formData.append('file', file);
        formData.append('duration', duration.toString());
        
        // 서버에 업로드
        const response = await fetch('/api/upload/music', {
          method: 'POST',
          body: formData,
        });

        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Upload failed');
        }

        const data = await response.json();
        
        // 서버에서 반환된 데이터로 UploadedAudio 생성
        const newAudio: UploadedAudio = {
          id: data.music.id.toString(),
          name: data.music.file_name,
          url: data.music.url,
          duration: data.music.duration || duration,
          size: data.music.file_size,
        };
        
        setUploadedAudios(prev => [...prev, newAudio]);
        newAudioIds.push(newAudio.id);
      }
      
      // 새로 업로드된 파일들을 자동으로 선택
      setSelectedAudioIds(prev => {
        const newSet = new Set(prev);
        newAudioIds.forEach(id => newSet.add(id));
        return newSet;
      });
      
      // 업로드 성공 알림 (선택사항)
      if (newAudioIds.length > 0) {
        console.log(`Successfully uploaded ${newAudioIds.length} audio file(s)`);
        // 업로드 후 전체 목록 다시 로드
        await loadUploadedMusic();
      }
    } catch (error) {
      console.error('Error uploading audio:', error);
      alert(error instanceof Error ? error.message : 'Error uploading audio file.');
    } finally {
      setIsUploading(false);
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleDrop = async (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
    
    const files = event.dataTransfer.files;
    if (!files || files.length === 0) return;
    
    const input = fileInputRef.current;
    if (input) {
      const dataTransfer = new DataTransfer();
      for (const file of Array.from(files)) {
        dataTransfer.items.add(file);
      }
      input.files = dataTransfer.files;
      
      const changeEvent = new Event('change', { bubbles: true });
      input.dispatchEvent(changeEvent);
    }
  };

  const handleDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handlePlayPause = (audio: UploadedAudio) => {
    if (playingAudioId === audio.id) {
      if (audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
      }
      setPlayingAudioId(null);
    } else {
      if (audioRef.current) {
        audioRef.current.pause();
      }
      
      const newAudio = new Audio(audio.url);
      newAudio.play();
      audioRef.current = newAudio;
      setPlayingAudioId(audio.id);
      
      newAudio.addEventListener('ended', () => {
        setPlayingAudioId(null);
        audioRef.current = null;
      });
    }
  };

  const handleToggleSelect = (audioId: string) => {
    setSelectedAudioIds(prev => {
      const newSet = new Set(prev);
      if (newSet.has(audioId)) {
        newSet.delete(audioId);
      } else {
        newSet.add(audioId);
      }
      return newSet;
    });
  };

  const handleSelectAll = () => {
    if (selectedAudioIds.size === uploadedAudios.length) {
      setSelectedAudioIds(new Set());
    } else {
      setSelectedAudioIds(new Set(uploadedAudios.map(a => a.id)));
    }
  };

  const handleAddSelectedToTimeline = () => {
    if (activeTab === 'preset' && selectedPreset) {
      const preset = presetSounds.find(s => s.key === selectedPreset);
      if (preset) {
        onSelectSounds([{
          name: preset.label,
          url: '', // 프리셋 음악은 URL이 아닌 키로 처리
          duration: preset.duration,
        }]);
        onClose();
      }
    } else if (activeTab === 'upload') {
      const selectedAudios = uploadedAudios
        .filter(audio => selectedAudioIds.has(audio.id))
        .map(audio => ({
          name: audio.name,
          url: audio.url,
          duration: audio.duration,
        }));
      
      if (selectedAudios.length > 0) {
        onSelectSounds(selectedAudios);
        onClose();
      }
    } else if (activeTab === 'generate') {
      const selectedAudios: Array<{ name: string; url: string; duration: number }> = [];
      
      soundGroups.forEach(group => {
        group.variations.forEach((variation) => {
          if (selectedAudioIds.has(variation.id)) {
            selectedAudios.push({
              name: `${group.prompt} - Sample ${variation.variationNumber}`,
              url: variation.url,
              duration: variation.duration,
            });
          }
        });
      });
      
      if (selectedAudios.length > 0) {
        onSelectSounds(selectedAudios);
        onClose();
      }
    }
  };

  const handleSoundGenerate = async () => {
    // Manual mode validation
    if (inputMode === 'manual') {
      if (!soundPrompt.trim()) {
        setGenerationError('Please enter a sound description.');
        return;
      }

      if (soundPrompt.length > 450) {
        setGenerationError('Description cannot exceed 450 characters.');
        return;
      }
    }
    
    // From video mode validation
    if (inputMode === 'fromVideo') {
      if (!selectedVideoClip) {
        setGenerationError('Please select a video clip.');
        return;
      }
      
      const selectedClip = timelineClips.find(c => c.id === selectedVideoClip);
      if (!selectedClip) {
        setGenerationError('Selected video clip not found.');
        return;
      }
    }

    setIsGeneratingSound(true);
    setGenerationError(null);

    try {
      let response;
      let jobIds: string[];
      
      if (inputMode === 'manual') {
        // 1. Manual mode: API 호출로 4개의 job 시작
        response = await fetch('/api/sound/generate-async', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            prompt: soundPrompt.trim(),
            title: soundTitle.trim() || undefined,
            duration_seconds: soundDuration,
            generation_type: generationType,
          }),
        });
        
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Sound generation failed');
        }

        jobIds = data.jobIds;
      } else {
        // From video mode: 비디오 기반 생성
        const selectedClip = timelineClips.find(c => c.id === selectedVideoClip);
        if (!selectedClip) {
          throw new Error('Selected video clip not found');
        }
        
        // 비디오 기반 생성 (프롬프트는 서버에서 처리)
        const completedJobIds = await videoSoundGeneration.generateFromVideo(
          selectedClip,
          soundDuration
        );
        
        if (completedJobIds.length > 0) {
          // 생성 완료 시 히스토리 새로고침
          loadSoundHistory(true);
          setIsGeneratingSound(false);
          setSoundPrompt(''); // 입력 초기화
          setSoundTitle(''); // 타이틀 초기화
          setSelectedVideoClip(null); // 선택 초기화
          return; // 비디오 모드는 hook에서 처리 완료
        } else {
          throw new Error('Video-based sound generation failed');
        }
      }
      
      // 내부적으로 job progress 추적
      const jobProgresses: JobProgress[] = jobIds.map((jobId: string, index: number) => ({
        jobId,
        variationNumber: index + 1,
        progress: 0,
        status: 'processing' as const
      }));

      // 2. 각 job별로 진행률 시뮬레이션 시작
      const startTimes = new Map<string, number>();
      jobIds.forEach((jobId: string) => {
        startTimes.set(jobId, Date.now() + Math.random() * 2000); // 약간의 랜덤 딜레이
      });
      
      const progressInterval = setInterval(() => {
        jobProgresses.forEach(job => {
          if (job.status === 'completed' || job.status === 'failed') return;
          
          const startTime = startTimes.get(job.jobId) || Date.now();
          const elapsed = Math.max(0, (Date.now() - startTime) / 1000);
          const newProgress = calculateProgressForElapsedTime(elapsed, 15);
          
          job.progress = Math.floor(newProgress);
        });
      }, 500);

      // 3. 각 job별로 상태 폴링
      const pollIntervals = new Map<string, NodeJS.Timeout>();
      const pollCounts = new Map<string, number>();
      const maxPolls = 60;
      
      jobIds.forEach((jobId: string) => {
        pollCounts.set(jobId, 0);
        
        const interval = setInterval(async () => {
          const currentPollCount = (pollCounts.get(jobId) || 0) + 1;
          pollCounts.set(jobId, currentPollCount);
          
          const endpoint = currentPollCount > 150
            ? `/api/sound/jobs/${jobId}/poll`
            : `/api/sound/jobs/${jobId}`;
          
          try {
            const statusResponse = await fetch(endpoint);
            const status = await statusResponse.json();
            
            if (status.status === 'completed') {
              // 이 job의 polling 중지
              clearInterval(interval);
              pollIntervals.delete(jobId);
              
              // 완료 상태 업데이트
              const jobIndex = jobProgresses.findIndex(j => j.jobId === jobId);
              if (jobIndex !== -1) {
                jobProgresses[jobIndex].status = 'completed';
                jobProgresses[jobIndex].progress = 100;
              }
              
            } else if (status.status === 'failed') {
              clearInterval(interval);
              pollIntervals.delete(jobId);
              
              const jobIndex = jobProgresses.findIndex(j => j.jobId === jobId);
              if (jobIndex !== -1) {
                jobProgresses[jobIndex].status = 'failed';
                jobProgresses[jobIndex].progress = 0;
              }
              
            } else if (currentPollCount >= maxPolls) {
              clearInterval(interval);
              pollIntervals.delete(jobId);
              
              const jobIndex = jobProgresses.findIndex(j => j.jobId === jobId);
              if (jobIndex !== -1) {
                jobProgresses[jobIndex].status = 'failed';
                jobProgresses[jobIndex].progress = 0;
              }
            }
          } catch (err) {
            console.error(`Polling error for job ${jobId}:`, err);
          }
        }, 2000);
        
        pollIntervals.set(jobId, interval);
      });
      
      // 모든 job이 완료되었는지 확인하는 effect
      const checkAllCompleted = setInterval(() => {
        const allDone = jobProgresses.every(job => job.status === 'completed' || job.status === 'failed');
        const hasSuccess = jobProgresses.some(job => job.status === 'completed');
        
        if (allDone) {
          clearInterval(checkAllCompleted);
          clearInterval(progressInterval);
          pollIntervals.forEach(interval => clearInterval(interval));
          
          if (!hasSuccess) {
            setGenerationError('All sound generation failed.');
            setIsGeneratingSound(false);
          } else {
            // 생성 완료 시 히스토리 새로고침
            loadSoundHistory(true);
            setIsGeneratingSound(false);
            setSoundPrompt(''); // 입력 초기화
            setSoundTitle(''); // 타이틀 초기화
          }
        }
      }, 1000);

    } catch (err) {
      console.error('Sound generation error:', err);
      setGenerationError(err instanceof Error ? err.message : 'An error occurred during sound generation.');
      setIsGeneratingSound(false);
    }
  };

  const handleRemoveAudio = (audioId: string) => {
    const audio = uploadedAudios.find(a => a.id === audioId);
    if (audio) {
      // data URL은 revoke할 필요 없음 (blob URL만 revoke 필요)
      // URL.revokeObjectURL(audio.url);
      setUploadedAudios(prev => prev.filter(a => a.id !== audioId));
      setSelectedAudioIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(audioId);
        return newSet;
      });
      
      if (playingAudioId === audioId && audioRef.current) {
        audioRef.current.pause();
        audioRef.current = null;
        setPlayingAudioId(null);
      }
    }
  };

  const formatDuration = (seconds: number): string => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return bytes + ' B';
    const kb = bytes / 1024;
    if (kb < 1024) return kb.toFixed(1) + ' KB';
    const mb = kb / 1024;
    return mb.toFixed(1) + ' MB';
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg w-[800px] max-h-[80vh] flex flex-col">
        <div className="flex items-center justify-between p-6 border-b border-gray-700">
          <h2 className="text-xl font-medium">Sound Library</h2>
          <button 
            onClick={onClose}
            className="w-8 h-8 flex items-center justify-center hover:bg-gray-700 rounded-lg"
          >
            <i className="ri-close-line"></i>
          </button>
        </div>
        
        <div className="flex-1 overflow-auto p-6">
          {/* 탭 선택 */}
          <div className="flex gap-2 mb-6">
            <button
              onClick={() => setActiveTab('preset')}
              className={`px-4 py-2 rounded-lg transition-colors ${
                activeTab === 'preset' 
                  ? 'bg-primary text-black' 
                  : 'bg-gray-700 hover:bg-gray-600'
              }`}
            >
              Preset Music
            </button>
            <button
              onClick={() => setActiveTab('upload')}
              className={`px-4 py-2 rounded-lg transition-colors ${
                activeTab === 'upload' 
                  ? 'bg-primary text-black' 
                  : 'bg-gray-700 hover:bg-gray-600'
              }`}
            >
              Upload Audio
            </button>
            <button
              onClick={() => setActiveTab('generate')}
              className={`px-4 py-2 rounded-lg transition-colors ${
                activeTab === 'generate' 
                  ? 'bg-primary text-black' 
                  : 'bg-gray-700 hover:bg-gray-600'
              }`}
            >
              Create Sound
            </button>
          </div>
          
          {activeTab === 'preset' ? (
            /* 프리셋 음악 선택 */
            <div>
              <h3 className="font-medium mb-4">Select Preset Music</h3>
              <div className="grid grid-cols-2 gap-3">
                {presetSounds.map((sound) => (
                  <div
                    key={sound.key}
                    onClick={() => setSelectedPreset(sound.key)}
                    className={`p-4 rounded-lg cursor-pointer transition-all ${
                      selectedPreset === sound.key
                        ? 'bg-primary text-black'
                        : 'bg-gray-700 hover:bg-gray-600'
                    }`}
                  >
                    <div className="flex items-center gap-3">
                      <i className="ri-volume-up-line text-2xl"></i>
                      <div>
                        <div className="font-medium">{sound.label}</div>
                        <div className={`text-sm ${
                          selectedPreset === sound.key ? 'text-black/70' : 'text-gray-400'
                        }`}>
                          {formatDuration(sound.duration)}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          ) : activeTab === 'generate' ? (
            /* AI 생성 섹션 */
            <div>
              <div className="mb-6">
                <h3 className="font-medium mb-4">AI Sound Generation</h3>
                
                {/* Input Mode Selection */}
                <div className="flex gap-2 mb-4">
                  <button
                    onClick={() => {
                      setInputMode('manual');
                      setGenerationError(null);
                      videoSoundGeneration.clearError();
                    }}
                    className={`flex-1 px-4 py-2 rounded-lg transition-colors flex items-center justify-center gap-2 ${
                      inputMode === 'manual'
                        ? 'bg-primary text-black'
                        : 'bg-gray-700 hover:bg-gray-600'
                    }`}
                  >
                    <i className="ri-edit-line"></i>
                    <span>Write description</span>
                  </button>
                  <button
                    onClick={() => {
                      setInputMode('fromVideo');
                      setGenerationError(null);
                      videoSoundGeneration.clearError();
                    }}
                    disabled={timelineClips.length === 0}
                    className={`flex-1 px-4 py-2 rounded-lg transition-colors flex items-center justify-center gap-2 ${
                      inputMode === 'fromVideo'
                        ? 'bg-primary text-black'
                        : 'bg-gray-700 hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed'
                    }`}
                  >
                    <i className="ri-video-line"></i>
                    <span>From video clip</span>
                  </button>
                </div>
                
                {/* 인라인 생성 폼 */}
                <div className="space-y-4">
                  {/* Conditional Input based on mode */}
                  {inputMode === 'manual' ? (
                    /* Manual Input Mode */
                    <div className="space-y-3">
                      {/* Generation Type Selection */}
                      <div className="flex gap-2 p-3 bg-gray-700/50 rounded-lg">
                        <button
                          onClick={() => setGenerationType('sound_effect')}
                          className={`flex-1 px-3 py-2 rounded-lg transition-colors ${
                            generationType === 'sound_effect'
                              ? 'bg-primary text-black'
                              : 'bg-gray-800 hover:bg-gray-700'
                          }`}
                          disabled={isGeneratingSound}
                        >
                          <i className="ri-volume-up-line mr-2"></i>
                          Sound Effect
                        </button>
                        <button
                          onClick={() => setGenerationType('music')}
                          className={`flex-1 px-3 py-2 rounded-lg transition-colors ${
                            generationType === 'music'
                              ? 'bg-primary text-black'
                              : 'bg-gray-800 hover:bg-gray-700'
                          }`}
                          disabled={isGeneratingSound}
                        >
                          <i className="ri-music-2-line mr-2"></i>
                          Music
                          <span className={`ml-1 text-xs ${
                            generationType === 'music' ? 'text-black/70' : 'text-gray-500'
                          }`}>(32s)</span>
                        </button>
                      </div>
                      
                      {/* Title Input */}
                      <div className="p-4 bg-gray-700/50 rounded-lg">
                        <div className="text-sm text-gray-400 mb-2">
                          Title <span className="text-gray-500">(optional)</span>
                        </div>
                        <input
                          type="text"
                          value={soundTitle}
                          onChange={(e) => setSoundTitle(e.target.value)}
                          placeholder="Uses description if empty"
                          className="w-full px-4 py-2 bg-gray-800 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                          disabled={isGeneratingSound}
                          maxLength={100}
                        />
                      </div>
                      
                      {/* Prompt and Controls */}
                      <div className="p-4 bg-gray-700/50 rounded-lg">
                        <div className="flex items-center justify-between mb-2">
                          <div className="text-sm text-gray-400">
                            Description <span className="text-red-400">*</span>
                          </div>
                          <span className="text-xs text-gray-500">
                            {soundPrompt.length}/450
                          </span>
                        </div>
                        <div className="flex items-start gap-3">
                          <textarea
                            value={soundPrompt}
                            onChange={(e) => {
                              setSoundPrompt(e.target.value);
                              setGenerationError(null);
                            }}
                            placeholder="Describe the sound you want to generate..."
                            className="flex-1 px-4 py-2 bg-gray-800 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary resize-none min-h-[40px] max-h-[120px] overflow-y-auto"
                            disabled={isGeneratingSound}
                            maxLength={450}
                            rows={1}
                            style={{
                              height: 'auto',
                              minHeight: '40px'
                            }}
                            onInput={(e) => {
                              const target = e.target as HTMLTextAreaElement;
                              target.style.height = 'auto';
                              target.style.height = Math.min(target.scrollHeight, 120) + 'px';
                            }}
                          />
                          
                          {/* Duration 선택 - Sound Effect일 때만 표시 */}
                          {generationType === 'sound_effect' && (
                            <div className="relative duration-dropdown-container">
                              <button
                                onClick={() => setShowDurationDropdown(!showDurationDropdown)}
                                disabled={isGeneratingSound}
                                className="flex items-center gap-2 px-3 py-2 bg-gray-800 rounded-lg hover:bg-gray-700 disabled:opacity-50"
                              >
                                <span className="text-sm min-w-[55px]">↔ {soundDuration}.0s</span>
                              </button>
                              
                              {showDurationDropdown && (
                                <div className="absolute top-full mt-2 left-0 bg-gray-800 border border-gray-700 rounded-lg shadow-2xl shadow-black/50 z-10 p-4 w-80">
                                  <div className="text-sm text-gray-400 mb-2">Duration</div>
                                  <div className="flex items-center gap-3">
                                    <input
                                      type="range"
                                      min="1"
                                      max="22"
                                      value={soundDuration}
                                      onChange={(e) => setSoundDuration(Number(e.target.value))}
                                      className="flex-1 accent-primary"
                                    />
                                    <span className="text-sm text-gray-300 min-w-[50px] text-right">
                                      ↔ {soundDuration}.0s
                                    </span>
                                  </div>
                                </div>
                              )}
                            </div>
                          )}
                          
                          {/* Generate 버튼 */}
                          <button
                            onClick={handleSoundGenerate}
                            disabled={isGeneratingSound || !soundPrompt.trim()}
                            className="px-6 py-2 bg-primary rounded-button hover:bg-primary/90 text-black disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 min-w-[120px] justify-center"
                          >
                            {isGeneratingSound ? (
                              <>
                                <Loader2 className="w-4 h-4 animate-spin" />
                                <span>Generating</span>
                              </>
                            ) : (
                              <>
                                <i className="ri-magic-line"></i>
                                <span>Generate</span>
                              </>
                            )}
                          </button>
                        </div>
                      </div>
                    </div>
                  ) : (
                    /* From Video Mode */
                    <>
                      {/* Video Clip Selector */}
                      <VideoClipSelector
                        clips={timelineClips}
                        selectedClipId={selectedVideoClip}
                        onSelectClip={setSelectedVideoClip}
                        disabled={isGeneratingSound || videoSoundGeneration.isGenerating}
                      />
                      
                      {/* Duration and Generate Controls */}
                      <div className="flex items-center gap-3 p-4 bg-gray-700/50 rounded-lg">
                        {/* Duration 선택 */}
                        <div className="relative duration-dropdown-container">
                          <button
                            onClick={() => setShowDurationDropdown(!showDurationDropdown)}
                            disabled={isGeneratingSound || videoSoundGeneration.isGenerating}
                            className="flex items-center gap-2 px-3 py-2 bg-gray-800 rounded-lg hover:bg-gray-700 disabled:opacity-50"
                          >
                            <span className="text-sm min-w-[55px]">↔ {soundDuration}.0s</span>
                          </button>
                          
                          {showDurationDropdown && (
                            <div className="absolute top-full mt-2 left-0 bg-gray-800 border border-gray-700 rounded-lg shadow-2xl shadow-black/50 z-10 p-4 w-80">
                              <div className="text-sm text-gray-400 mb-2">Duration</div>
                              <div className="flex items-center gap-3">
                                <input
                                  type="range"
                                  min="1"
                                  max="22"
                                  value={soundDuration}
                                  onChange={(e) => setSoundDuration(Number(e.target.value))}
                                  className="flex-1 accent-primary"
                                />
                                <span className="text-sm text-gray-300 min-w-[50px] text-right">
                                  ↔ {soundDuration}.0s
                                </span>
                              </div>
                            </div>
                          )}
                        </div>
                        
                        <div className="flex-1"></div>
                        
                        {/* Generate 버튼 */}
                        <button
                          onClick={handleSoundGenerate}
                          disabled={isGeneratingSound || videoSoundGeneration.isGenerating || !selectedVideoClip}
                          className="px-6 py-2 bg-primary rounded-button hover:bg-primary/90 text-black disabled:opacity-50 disabled:cursor-not-allowed flex items-center gap-2 min-w-[120px] justify-center"
                        >
                          {(isGeneratingSound || videoSoundGeneration.isGenerating) ? (
                            <>
                              <Loader2 className="w-4 h-4 animate-spin" />
                              <span>Generating</span>
                            </>
                          ) : (
                            <>
                              <i className="ri-magic-line"></i>
                              <span>Generate from Video</span>
                            </>
                          )}
                        </button>
                      </div>
                    </>
                  )}
                  
                  {/* 에러 메시지 */}
                  {(generationError || videoSoundGeneration.error) && (
                    <div className="p-3 bg-red-500/10 border border-red-500/50 rounded-lg text-red-400 text-sm">
                      {generationError || videoSoundGeneration.error}
                    </div>
                  )}
                </div>
              </div>

              {/* Generated Sounds History - 최근 30개 그룹만 표시 */}
              <div>
                <div className="flex items-center justify-between mb-4">
                  <h3 className="font-medium">
                    Generated Sounds 
                    {soundGroups.length > 0 && (
                      <span className="text-gray-400 ml-2">
                        ({soundGroups.reduce((acc, g) => acc + g.variations.length, 0)} in {soundGroups.length} groups)
                      </span>
                    )}
                  </h3>
                </div>
                {isLoadingHistory ? (
                  <div className="text-center py-8 text-gray-500">
                    <i className="ri-loader-4-line animate-spin text-2xl mb-2"></i>
                    <div>Loading sound history...</div>
                  </div>
                ) : soundGroups.length === 0 ? (
                  <div className="text-center py-8 text-gray-500">
                    No generated sounds yet.
                  </div>
                ) : (
                  <div className="space-y-2">
                    {soundGroups.map((group) => (
                      <div key={group.groupId} className="border border-gray-700 rounded-lg overflow-hidden">
                        <button
                          onClick={() => {
                            setExpandedGroups(prev => {
                              const newSet = new Set(prev);
                              if (newSet.has(group.groupId)) {
                                newSet.delete(group.groupId);
                              } else {
                                newSet.add(group.groupId);
                              }
                              return newSet;
                            });
                          }}
                          className="w-full px-4 py-3 flex items-start gap-2 hover:bg-gray-700/50 transition-colors text-left"
                        >
                          <div className="mt-1">
                            {expandedGroups.has(group.groupId) ? (
                              <ChevronDown className="w-4 h-4 text-gray-400" />
                            ) : (
                              <ChevronRight className="w-4 h-4 text-gray-400" />
                            )}
                          </div>
                          <div className="flex-1 min-w-0">
                            <div className="text-sm font-medium truncate">
                              {formatSoundDisplayTitle(group.title, group.prompt)}
                            </div>
                            <div className="flex items-center gap-2 text-xs text-gray-400 mt-1">
                              <span>{new Date(group.createdAt).toLocaleDateString()}</span>
                              {group.generationType && (
                                <span className={`px-1.5 py-0.5 rounded text-xs ${
                                  group.generationType === 'music' 
                                    ? 'bg-purple-500/20 text-purple-400'
                                    : group.generationType === 'from_video'
                                    ? 'bg-blue-500/20 text-blue-400'
                                    : 'bg-green-500/20 text-green-400'
                                }`}>
                                  {group.generationType === 'sound_effect' ? 'Sound Effect' :
                                   group.generationType === 'music' ? 'Music' :
                                   group.generationType === 'from_video' ? 'From Video' :
                                   group.generationType}
                                </span>
                              )}
                            </div>
                          </div>
                        </button>
                        
                        {expandedGroups.has(group.groupId) && (
                          <div className="px-4 pb-3 space-y-2 border-t border-gray-700">
                            {group.variations.map((variation) => (
                              <div 
                                key={variation.id}
                                onClick={() => handleToggleSelect(variation.id)}
                                className="flex items-center gap-3 p-2 rounded-lg hover:bg-gray-700/30 cursor-pointer"
                              >
                                <input 
                                  type="checkbox"
                                  checked={selectedAudioIds.has(variation.id)}
                                  onChange={() => handleToggleSelect(variation.id)}
                                  onClick={(e) => e.stopPropagation()}
                                  className="w-4 h-4 text-primary bg-gray-700 border-gray-600 rounded focus:ring-primary"
                                />
                                
                                <span className="text-sm text-gray-400">
                                  {variation.variationNumber}.
                                </span>
                                
                                <button 
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    handlePlayPause({
                                      id: variation.id,
                                      name: `Sample ${variation.variationNumber}`,
                                      url: variation.url,
                                      duration: variation.duration,
                                      size: 0
                                    });
                                  }}
                                  className="w-8 h-8 flex items-center justify-center bg-gray-900 rounded-full hover:bg-gray-800 transition-colors"
                                >
                                  <i className={playingAudioId === variation.id ? 'ri-pause-fill text-sm' : 'ri-play-fill text-sm'}></i>
                                </button>
                                
                                <div className="flex-1">
                                  <div className="text-sm">Sample {variation.variationNumber}</div>
                                  <div className="text-xs text-gray-500">
                                    {formatDuration(variation.duration)}
                                  </div>
                                </div>
                              </div>
                            ))}
                          </div>
                        )}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ) : (
            /* 업로드 섹션 */
            <>
              <div className="mb-6">
            <h3 className="font-medium mb-4">Upload Audio</h3>
            <div 
              className="border-2 border-dashed border-gray-700 rounded-lg p-8 text-center hover:border-primary/50 transition-colors"
              onDrop={handleDrop}
              onDragOver={handleDragOver}
            >
              <i className="ri-upload-cloud-line text-4xl text-gray-400 mb-3"></i>
              <div className="text-gray-400 mb-2">
                Drag and drop audio files or click to upload
              </div>
              <div className="text-sm text-gray-500 mb-4">
                Supported formats: MP3, WAV, M4A, OGG, AAC
              </div>
              <input 
                ref={fileInputRef}
                type="file" 
                accept="audio/*" 
                multiple
                className="hidden" 
                id="audio-upload"
                onChange={handleFileUpload}
                disabled={isUploading}
              />
              <button 
                onClick={() => fileInputRef.current?.click()}
                disabled={isUploading}
                className="px-6 py-2 bg-primary rounded-button text-black hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {isUploading ? 'Uploading...' : 'Browse Files'}
              </button>
            </div>
          </div>

          <div>
            <div className="flex items-center justify-between mb-4">
              <h3 className="font-medium">Uploaded Audio ({uploadedAudios.length})</h3>
              {uploadedAudios.length > 0 && (
                <button 
                  onClick={handleSelectAll}
                  className="text-sm text-primary hover:text-primary/80"
                >
                  {selectedAudioIds.size === uploadedAudios.length ? 'Deselect All' : 'Select All'}
                </button>
              )}
            </div>
            {uploadedAudios.length === 0 ? (
              <div className="text-center py-8 text-gray-500">
                No audio files uploaded. Please upload audio files.
              </div>
            ) : (
              <div className="space-y-2">
                {uploadedAudios.map((audio) => (
                  <div 
                    key={audio.id}
                    onClick={() => handleToggleSelect(audio.id)}
                    className="flex items-center gap-3 p-3 bg-gray-700/50 hover:bg-gray-700 rounded-lg group cursor-pointer"
                  >
                    <input 
                      type="checkbox"
                      checked={selectedAudioIds.has(audio.id)}
                      onChange={() => handleToggleSelect(audio.id)}
                      onClick={(e) => e.stopPropagation()}
                      className="w-4 h-4 text-primary bg-gray-700 border-gray-600 rounded focus:ring-primary"
                    />
                    
                    <button 
                      onClick={(e) => {
                        e.stopPropagation();
                        handlePlayPause(audio);
                      }}
                      className="w-10 h-10 flex items-center justify-center bg-gray-900 rounded-full hover:bg-gray-800 transition-colors"
                    >
                      <i className={playingAudioId === audio.id ? 'ri-pause-fill' : 'ri-play-fill'}></i>
                    </button>
                    
                    <div className="flex-1">
                      <div className="font-medium text-sm">{audio.name}</div>
                      <div className="text-xs text-gray-400 mt-1">
                        {formatDuration(audio.duration)} • {formatFileSize(audio.size)}
                      </div>
                    </div>
                    
                    <button 
                      onClick={(e) => {
                        e.stopPropagation();
                        handleRemoveAudio(audio.id);
                      }}
                      className="w-8 h-8 flex items-center justify-center hover:bg-gray-600 rounded-lg opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                      <i className="ri-delete-bin-line text-red-400"></i>
                    </button>
                  </div>
                ))}
              </div>
            )}
          </div>
            </>
          )}
        </div>
        
        <div className="p-6 border-t border-gray-700">
          <div className="flex items-center justify-between">
            <div className="text-sm text-gray-400">
              {selectedAudioIds.size > 0 && (
                <span>{selectedAudioIds.size} selected</span>
              )}
            </div>
            <div className="flex gap-3">
              <button 
                onClick={onClose}
                className="px-6 py-2 bg-gray-700 rounded-button hover:bg-gray-600"
              >
                Close
              </button>
              <button 
                onClick={handleAddSelectedToTimeline}
                disabled={
                  activeTab === 'preset' 
                    ? !selectedPreset 
                    : selectedAudioIds.size === 0
                }
                className="px-6 py-2 bg-primary rounded-button hover:bg-primary/90 text-black disabled:opacity-50 disabled:cursor-not-allowed"
              >
                {activeTab === 'preset' 
                  ? `Add Preset Music` 
                  : `Add Selected to Timeline (${selectedAudioIds.size})`
                }
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="types/video-editor.ts">
export interface VideoClip {
  id: string;
  duration: number;
  position: number;
  thumbnails?: number;
  url?: string;
  thumbnail?: string;
  title?: string;
  maxDuration?: number; // Maximum duration in pixels (actual video length)
  startTime?: number; // Start time in seconds within the original video
  endTime?: number; // End time in seconds within the original video
  sourceType?: 'clip' | 'upload' | 'project'; // Source of the video (AI-generated clip, user upload, or project)
}

export interface TextClip {
  id: string;
  content: string;
  duration: number;
  position: number;
  style: TextStyle;
  effect?: TextEffect;
  maxDuration?: number; // For consistency, though text clips may not have a max duration
}

export interface SoundClip {
  id: string;
  name: string;
  duration: number;
  position: number;
  volume: number;
  url?: string;
  maxDuration?: number; // Maximum duration in pixels (actual audio length)
  startTime?: number; // Start time in seconds within the original audio
  endTime?: number; // End time in seconds within the original audio
  waveformData?: number[]; // Normalized waveform peak values (0-1)
  isAnalyzing?: boolean; // Whether the audio is currently being analyzed
  fadeInDuration?: number; // Fade in duration in pixels (0 = no fade)
  fadeOutDuration?: number; // Fade out duration in pixels (0 = no fade)
  fadeInType?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out'; // Fade curve type
  fadeOutType?: 'linear' | 'ease-in' | 'ease-out' | 'ease-in-out'; // Fade curve type
}

export interface TextStyle {
  fontSize: number;
  fontSizeRatio?: number; // 컨테이너 너비의 비율 (0.044 = 4.4%)
  fontFamily: string;
  color: string;
  alignment: 'left' | 'center' | 'right';
  fontWeight?: number; // 400 (normal), 700 (bold), 500 (medium)
  verticalPosition?: 'top' | 'middle' | 'bottom';
  positionX?: number; // 0-100 (%) 커스텀 위치
  positionY?: number; // 0-100 (%) 커스텀 위치
  backgroundColor?: string; // 배경색 (옵션)
  backgroundOpacity?: number; // 배경 투명도 0-1
}

export type TextEffect = 
  | 'none' 
  | 'pulse' 
  | 'bounce' 
  | 'gradient' 
  | 'fade' 
  | 'slide' 
  | 'typing' 
  | 'glow' 
  | 'wave' 
  | 'zoom'
  | 'shake'
  | 'spin'
  | 'flip'
  | 'elastic'
  | 'rubberband'
  | 'jello'
  | 'flash'
  | 'neon'
  | 'glitch'
  | 'shadow'
  | 'outline'
  | 'chrome'
  | 'rainbow'
  | 'fire'
  | 'ice';

export interface TimelineTrack {
  id: string;
  type: 'video' | 'text' | 'sound';
  label: string;
  clips: (VideoClip | TextClip | SoundClip)[];
}

export interface EditorState {
  videoClips: VideoClip[];
  textClips: TextClip[];
  soundClips: SoundClip[];
  selectedClip: string | null;
  playheadPosition: number;
  zoom: number;
}

export interface LibraryVideo {
  id: string;
  job_id: string;
  status: string;
  input_image_url: string;
  output_video_url: string;
  created_at: string;
  is_favorite: boolean;
  aspect_ratio?: string;
  selected_effects: Array<{
    id: number;
    name: string;
  }>;
}

// 프로젝트 저장 타입 추가
export interface LibraryProject {
  id: number;
  project_name: string;
  updated_at: string;
  latest_video_url?: string;  // project_saves에서 직접 가져옴
  thumbnail_url?: string;  // 프로젝트 썸네일 URL
  latest_render?: {
    render_id: string;
    output_url: string;
    thumbnail_url: string | null;
    status: string;
  };
  content_snapshot?: {
    aspect_ratio: string;
    duration_frames: number;
  };
}

// 사용자 업로드 영상 타입
export interface UserUploadedVideo {
  id: number;
  user_id: string;
  file_name: string;
  storage_path: string;
  file_size: number;
  duration?: number;
  aspect_ratio?: string;
  thumbnail_url?: string;
  metadata?: any;
  uploaded_at: string;
  is_deleted?: boolean;
}

// 통합 라이브러리 아이템 타입
export type LibraryItem = 
  | { type: 'clip'; data: LibraryVideo }
  | { type: 'project'; data: LibraryProject }
  | { type: 'upload'; data: UserUploadedVideo };
</file>

<file path="app/video-editor/_components/VideoPreview.tsx">
'use client';

import { useEffect, useMemo, useState, useRef } from 'react';
import { toast } from 'sonner';
import { Player, PlayerRef } from '@remotion/player';
import { CompositePreview } from './remotion/CompositePreview';
import { TextClip as TextClipType, SoundClip as SoundClipType } from '@/types/video-editor';
import TextOverlayEditor from './TextOverlayEditor';
import FullscreenPreviewModal from './FullscreenPreviewModal';
import RenderingModal from './RenderingModal';
import { BufferingSpinner } from './BufferingSpinner';
import { ASPECT_RATIOS, CAROUSEL_CONFIG, STYLES, AspectRatioValue } from '../_constants';
// import { useVideoPreloader } from '../_hooks/useVideoPreloader';

interface PreviewClip {
  id: string;
  thumbnail?: string;
  url?: string;
  duration: number;
  thumbnails?: number;
  position?: number;
  title?: string;
  maxDuration?: number;
  startTime?: number;
  endTime?: number;
}

interface VideoPreviewProps {
  clips: PreviewClip[];
  textClips?: TextClipType[];
  soundClips?: SoundClipType[];
  onRemoveClip?: (id: string) => void;
  playerRef?: React.MutableRefObject<PlayerRef | null>;
  currentTime?: number;
  isPlaying?: boolean;
  onPlayStateChange?: (playing: boolean) => void;
  onUpdateTextPosition?: (id: string, x: number, y: number) => void;
  onUpdateTextSize?: (id: string, fontSize: number, fontSizeRatio: number) => void;
  selectedTextClip?: string | null;
  onSelectTextClip?: (id: string | null) => void;
  projectTitle?: string;
}

export default function VideoPreview({ 
  clips, 
  textClips = [], 
  soundClips = [], 
  onRemoveClip,
  playerRef,
  onUpdateTextPosition,
  onUpdateTextSize,
  selectedTextClip,
  onSelectTextClip,
  projectTitle = 'Untitled Project',
  currentTime,
  isPlaying,
  onPlayStateChange
}: VideoPreviewProps) {
  // SSR-CSR hydration 안정화를 위한 마운트 플래그
  const [is_mounted, setIsMounted] = useState(false);
  // 선택된 프리뷰 대상 클립 ID 관리
  const [selected_preview_clip_id, setSelectedPreviewClipId] = useState<string | null>(null);
  // 캐러셀 현재 인덱스
  const [currentIndex, setCurrentIndex] = useState(0);
  // 전체 화면 미리보기 모달 상태
  const [isFullscreenOpen, setIsFullscreenOpen] = useState(false);
  // 버퍼링 상태 추적
  const [isBuffering, setIsBuffering] = useState(false);
  // 렌더링 상태
  const [isRendering, setIsRendering] = useState(false);
  const [renderProgress, setRenderProgress] = useState(0);
  const [renderComplete, setRenderComplete] = useState(false);
  const [renderOutputUrl, setRenderOutputUrl] = useState<string | null>(null);
  const [isRenderModalOpen, setIsRenderModalOpen] = useState(false);
  
  // Export 관련 상태 (저장 상태 제거)
  
  const containerRef = useRef<HTMLDivElement>(null);
  const { ITEM_WIDTH, ITEM_HEIGHT, ITEM_GAP } = CAROUSEL_CONFIG;
  
  // 비디오 URL 목록 추출 (프리로딩 비활성화 - Remotion이 자체 처리)
  // const videoUrls = useMemo(() => clips.map(clip => clip.url), [clips]);
  // const { loadingCount, loadedCount, totalCount } = useVideoPreloader(videoUrls);

  useEffect(() => {
    setIsMounted(true);
  }, []);

  // 스페이스바 키보드 단축키 이벤트 리스너
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // 텍스트 입력 중이 아닐 때만 동작
      const target = event.target as HTMLElement;
      if (target.tagName === 'INPUT' || 
          target.tagName === 'TEXTAREA' || 
          target.isContentEditable) {
        return;
      }
      
      // 스페이스바 감지
      if (event.key === ' ' || event.code === 'Space') {
        event.preventDefault(); // 기본 스크롤 동작 방지
        
        // 재생/일시정지 토글
        if (onPlayStateChange && playerRef?.current) {
          if (isPlaying) {
            playerRef.current.pause();
            onPlayStateChange(false);
          } else {
            playerRef.current.play();
            onPlayStateChange(true);
          }
        }
      }
    };

    // 이벤트 리스너 등록
    window.addEventListener('keydown', handleKeyDown);

    // 클린업
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [isPlaying, onPlayStateChange, playerRef]);

  // 초기/클립 변경 시 기본 선택: 첫 번째 클립
  useEffect(() => {
    if (clips.length === 0) {
      setSelectedPreviewClipId(null);
      setCurrentIndex(0);
    } else if (!selected_preview_clip_id || !clips.some(c => c.id === selected_preview_clip_id)) {
      setSelectedPreviewClipId(clips[0].id);
      setCurrentIndex(0);
    }
  }, [clips, selected_preview_clip_id]);
  
  
  // Memoize soundClips with volume to trigger re-render when volume changes
  const memoizedSoundClips = useMemo(() => {
    return soundClips.map(clip => ({
      ...clip,
      volume: clip.volume !== undefined ? clip.volume : 100 // Ensure volume is included with proper default
    }));
  }, [soundClips]);

  // Player 이벤트 리스너 설정 - 버퍼링 상태 추적 및 초기 볼륨 설정
  useEffect(() => {
    let volumeInterval: NodeJS.Timeout | null = null;
    let volumeTimeout: NodeJS.Timeout | null = null;
    
    // Player가 실제로 준비될 때까지 대기하며 볼륨 설정
    const checkAndSetVolume = () => {
      if (playerRef?.current) {
        try {
          playerRef.current.setVolume(1);
          
          // 이벤트 리스너 설정
          const player = playerRef.current;
          
          // waiting 이벤트 - 버퍼링 시작
          const handleWaiting = () => {
            setIsBuffering(true);
          };
          
          // resume 이벤트 - 버퍼링 종료
          const handleResume = () => {
            setIsBuffering(false);
          };
          
          // 이벤트 리스너 등록
          player.addEventListener('waiting', handleWaiting);
          player.addEventListener('resume', handleResume);
          
          // 클린업 함수 저장
          return () => {
            player.removeEventListener('waiting', handleWaiting);
            player.removeEventListener('resume', handleResume);
          };
        } catch {
          return null;
        }
      }
      return null;
    };
    
    // 즉시 시도
    const cleanup = checkAndSetVolume();
    if (!cleanup) {
      // 실패하면 짧은 간격으로 재시도
      volumeInterval = setInterval(() => {
        const cleanup = checkAndSetVolume();
        if (cleanup) {
          if (volumeInterval) clearInterval(volumeInterval);
          if (volumeTimeout) clearTimeout(volumeTimeout);
        }
      }, 100);
      
      // 최대 5초 후 정리
      volumeTimeout = setTimeout(() => {
        if (volumeInterval) clearInterval(volumeInterval);
      }, 5000);
    }
    
    // 클린업
    return () => {
      if (volumeInterval) clearInterval(volumeInterval);
      if (volumeTimeout) clearTimeout(volumeTimeout);
      cleanup?.();
    };
  }, [playerRef, clips.length, soundClips.length]); // clips나 soundClips 변경 시 재설정
  
  // 선택된 클립이 변경되면 해당 인덱스로 이동
  useEffect(() => {
    if (selected_preview_clip_id) {
      const index = clips.findIndex(c => c.id === selected_preview_clip_id);
      if (index !== -1 && index !== currentIndex) {
        setCurrentIndex(index);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selected_preview_clip_id, clips]); // currentIndex는 의도적으로 제외 (무한 루프 방지)

  // 캐러셀 네비게이션
  const handlePrevious = () => {
    const newIndex = Math.max(0, currentIndex - 1);
    setCurrentIndex(newIndex);
    if (clips[newIndex]) {
      setSelectedPreviewClipId(clips[newIndex].id);
    }
  };

  const handleNext = () => {
    const newIndex = Math.min(clips.length - 1, currentIndex + 1);
    setCurrentIndex(newIndex);
    if (clips[newIndex]) {
      setSelectedPreviewClipId(clips[newIndex].id);
    }
  };
  
  // 특정 인덱스로 이동
  const goToIndex = (index: number) => {
    setCurrentIndex(Math.max(0, Math.min(clips.length - 1, index)));
    if (clips[index]) {
      setSelectedPreviewClipId(clips[index].id);
    }
  };

  // 네비게이션 가능 여부
  const canGoPrevious = currentIndex > 0;
  const canGoNext = currentIndex < clips.length - 1;
  
  // 슬라이드 위치 계산
  const calculateTransform = () => {
    const containerWidth = containerRef.current?.offsetWidth || 0;
    const itemTotalWidth = ITEM_WIDTH + ITEM_GAP;
    // 현재 인덱스의 아이템을 컨테이너 중앙에 배치
    const centerOffset = (containerWidth - ITEM_WIDTH) / 2;
    const slideOffset = -(currentIndex * itemTotalWidth);
    return slideOffset + centerOffset;
  };
  
  // 총 프레임 계산 (픽셀 기반 - 40px = 1초 = 30프레임)
  const calculateTotalFrames = useMemo(() => {
    // 각 트랙의 끝 위치 계산 (position + duration)
    const videoEnd = clips.length > 0 
      ? Math.max(...clips.map(c => (c.position || 0) + c.duration))
      : 0;
    const textEnd = textClips.length > 0
      ? Math.max(...textClips.map(c => (c.position || 0) + c.duration))
      : 0;
    const soundEnd = soundClips.length > 0
      ? Math.max(...soundClips.map(c => (c.position || 0) + c.duration))
      : 0;
    
    // 모든 트랙 중 가장 끝 위치
    const totalPx = Math.max(videoEnd, textEnd, soundEnd);
    const totalSeconds = totalPx / 40; // 40px = 1초
    return Math.max(30, Math.round(totalSeconds * 30)); // 최소 1초(30프레임) 보장
  }, [clips, textClips, soundClips]);
  
  // 화면 비율 옵션
  const [selectedAspectRatio, setSelectedAspectRatio] = useState<AspectRatioValue>('9:16');
  
  // 선택된 비율에 따른 실제 크기 계산
  const getAspectRatioDimensions = (ratio: AspectRatioValue) => {
    const ratioConfig = Object.values(ASPECT_RATIOS).find(r => r.value === ratio);
    return ratioConfig || ASPECT_RATIOS.MOBILE;
  };
  
  const aspectRatioDimensions = getAspectRatioDimensions(selectedAspectRatio);
  const videoAspectRatio = {
    width: aspectRatioDimensions.width,
    height: aspectRatioDimensions.height
  };

  // content hash 생성 함수 (SHA256 사용)
  const generateContentHash = async (data: {
    videoClips: unknown[];
    textClips: unknown[];
    soundClips: unknown[];
    aspectRatio: string;
  }): Promise<string> => {
    const essentialData = {
      aspectRatio: data.aspectRatio,
      videoClips: (data.videoClips as unknown[]).map((clip: unknown) => {
        const c = clip as Record<string, unknown>;
        return {
          url: c.url,
          position: c.position,
          duration: c.duration,
          startTime: c.startTime || 0,
          endTime: c.endTime
        };
      }).sort((a, b) => (a.position as number) - (b.position as number)),
      textClips: (data.textClips as unknown[]).map((text: unknown) => {
        const t = text as Record<string, unknown>;
        return {
          content: t.content,
          position: t.position,
          duration: t.duration,
          style: t.style,
          effect: t.effect
        };
      }).sort((a, b) => (a.position as number) - (b.position as number)),
      soundClips: (data.soundClips as unknown[]).map((sound: unknown) => {
        const s = sound as Record<string, unknown>;
        return {
          url: s.url,
          position: s.position,
          duration: s.duration,
          volume: s.volume,
          startTime: s.startTime || 0
        };
      }).sort((a, b) => (a.position as number) - (b.position as number))
    };
    
    // 브라우저에서 Web Crypto API 사용
    const msgUint8 = new TextEncoder().encode(JSON.stringify(essentialData));
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
  };

  // Export Video 핸들러 (Save + Download 통합)
  const handleExportVideo = async () => {
    if (clips.length === 0) {
      toast.error('Please add video clips first.');
      return;
    }

    // 2분(120초) 제한 체크
    const totalDurationInSeconds = calculateTotalFrames / 30; // 30fps 기준
    if (totalDurationInSeconds > 120) {
      toast.error(
        `Timeline cannot exceed 2 minutes (Current: ${Math.floor(totalDurationInSeconds / 60)}m ${Math.floor(totalDurationInSeconds % 60)}s)`,
        { duration: 5000 }
      );
      return;
    }

    setIsRendering(true);
    setRenderProgress(0);
    setIsRenderModalOpen(true);

    try {
      // 1. content hash 생성
      const contentHash = await generateContentHash({
        videoClips: clips,
        textClips: textClips,
        soundClips: memoizedSoundClips,
        aspectRatio: selectedAspectRatio
      });
      
      // 2. 기존 렌더링 확인
      const checkResponse = await fetch(`/api/video/check-render?hash=${encodeURIComponent(contentHash)}`);
      
      if (!checkResponse.ok) {
        console.error('Failed to check existing render');
        // 체크 실패해도 계속 진행 (새 렌더링)
      } else {
        const checkResult = await checkResponse.json();
        
        // 3. 기존 렌더링이 있으면 바로 다운로드
        if (checkResult.exists && checkResult.outputUrl) {
          setRenderOutputUrl(checkResult.outputUrl);
          setIsRendering(false);
          setIsRenderModalOpen(false);
          
          // 바로 다운로드 실행
          const link = document.createElement('a');
          link.href = checkResult.outputUrl;
          link.download = `${projectTitle || 'video'}-${Date.now()}.mp4`;
          link.target = '_blank';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          console.log('Using existing render:', checkResult.renderId);
          return; // 렌더링 불필요
        }
      }

      // 4. 기존 렌더링이 없으면 새로 렌더링
      const response = await fetch('/api/video/render', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          videoClips: clips,
          textClips: textClips,
          soundClips: memoizedSoundClips,
          aspectRatio: selectedAspectRatio,
          durationInFrames: calculateTotalFrames,
          projectName: projectTitle,
          contentHash: contentHash, // content hash 추가
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Render failed');
      }

      const result = await response.json();

      if (result.success && result.renderId) {
        console.log('Render started:', result);
        
        // 진행 상황 확인 간격 개선 - 초반에는 자주, 후반에는 덜 자주
        let checkInterval = 2500; // 초기 간격 2.5초
        const maxInterval = 20000; // 최대 20초
        const maxAttempts = 30; // 최대 10분
        let attempts = 0;

        const checkProgress = async () => {
          try {
            const statusResponse = await fetch(
              `/api/video/render?renderId=${result.renderId}&bucketName=${result.bucketName}`
            );
            
            if (!statusResponse.ok) {
              throw new Error('Failed to check status');
            }

            const status = await statusResponse.json();
            
            if (status.done && status.outputFile) {
              // 렌더링 완료 - Save API 호출하여 Supabase에 저장
              const finalSaveResponse = await fetch('/api/video/save', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  projectName: projectTitle,
                  videoClips: clips,
                  textClips: textClips,
                  soundClips: memoizedSoundClips,
                  aspectRatio: selectedAspectRatio,
                  durationInFrames: calculateTotalFrames,
                  renderId: result.renderId,
                  renderOutputUrl: status.outputFile,
                }),
              });

              if (finalSaveResponse.ok) {
                const finalSaveResult = await finalSaveResponse.json();
                
                // Supabase URL이 있으면 사용, 없으면 S3 URL 사용
                const videoUrl = finalSaveResult.videoUrl || status.outputFile;
                setRenderOutputUrl(videoUrl);
                setRenderComplete(true);
                setIsRendering(false);
                setRenderProgress(100);
                
                console.log('Video saved to:', finalSaveResult.storageLocation, videoUrl);
                
              } else {
                // Save 실패해도 S3 URL은 사용 가능
                setRenderOutputUrl(status.outputFile);
                setRenderComplete(true);
                setIsRendering(false);
                setRenderProgress(100);
              }
            } else if (attempts < maxAttempts) {
              // 진행률 업데이트
              setRenderProgress(Math.round((status.overallProgress || 0) * 100));
              attempts++;
              
              // 체크 간격을 점진적으로 증가
              if (attempts === 0) {
                checkInterval = 3000; // 첫 번째 재귀는 3초
              } else if (attempts === 1) {
                checkInterval = 10000; // 두 번째 재귀는 10초
              } else if (attempts === 2) {
                checkInterval = 15000; // 세 번째 재귀는 15초  
              } else {
                checkInterval = maxInterval; // 이후는 20초
              }
              
              // 다시 체크
              setTimeout(checkProgress, checkInterval);
            } else {
              // 타임아웃
              throw new Error('Rendering timeout exceeded.');
            }
          } catch (error) {
            console.error('Progress check error:', error);
            setIsRendering(false);
            setRenderProgress(0);
            alert('Error checking render status.');
          }
        };

        // 2초 후 첫 체크 시작 (빠른 피드백 제공)
        setTimeout(checkProgress, 2000);
      } else {
        throw new Error('Failed to start rendering.');
      }
    } catch (error) {
      console.error('Download error:', error);
      alert(`Download failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      setIsRendering(false);
      setRenderProgress(0);
      setIsRenderModalOpen(false);
    }
  };

  // handleSaveFile 제거 - Export Video로 통합됨

  if (!is_mounted) return null;

  return (
    <div className="w-full h-full bg-black flex items-center">
      <div className="flex w-full h-full">
        {/* 좌측 50%: 캐러셀 형태의 클립 슬롯 */}
        <div className="w-1/2 flex flex-col items-center justify-center relative pr-2">
          {/* 캐러셀 컨테이너 */}
          <div className="flex items-center gap-2 w-full h-full relative">
          {/* 이전 버튼 */}
          <button
            onClick={handlePrevious}
            disabled={!canGoPrevious}
            className={`flex-shrink-0 w-10 h-10 flex items-center justify-center rounded-full transition-all ${
              canGoPrevious 
                ? 'bg-white/10 hover:bg-white/20 text-white cursor-pointer' 
                : 'bg-white/5 text-gray-600 cursor-not-allowed'
            }`}
            aria-label="Previous clips"
          >
            <i className="ri-arrow-left-s-line text-xl"></i>
          </button>

          {/* 클립 슬롯들 */}
          {clips.length > 0 ? (
            <div 
              ref={containerRef}
              className="flex-1 overflow-hidden relative h-full"
            >
              <div 
                className="flex items-center h-full"
                style={{
                  transform: `translateX(${calculateTransform()}px)`,
                  transition: 'transform 0.4s cubic-bezier(0.4, 0, 0.2, 1)'
                }}
              >
                {clips.map((clip, index) => {
                  const distance = Math.abs(index - currentIndex);
                  const isCenter = index === currentIndex;
                  const isAdjacent = distance === 1;
                  const scale = isCenter ? 1.1 : isAdjacent ? 0.9 : 0.75;
                  const opacity = isCenter ? 1 : isAdjacent ? 0.8 : 0.5;
                  
                  return (
                    <div 
                      key={clip.id} 
                      className={`flex-shrink-0 transition-all duration-300 flex items-center group ${
                        !isCenter ? 'hover:opacity-100' : ''
                      }`}
                      style={{
                        width: `${ITEM_WIDTH}px`,
                        height: `${ITEM_HEIGHT}px`,
                        marginRight: `${ITEM_GAP}px`,
                        transform: `scale(${scale})`,
                        opacity: opacity,
                      }}
                    >
                      <div className="bg-gray-900 rounded-lg overflow-hidden w-full h-full relative transition-all duration-200 hover:shadow-xl hover:shadow-black/50">
                        <div
                          role="button"
                          tabIndex={0}
                          className="relative w-full h-full cursor-pointer transition-all duration-200 hover:scale-105"
                          onClick={(e) => {
                            e.stopPropagation();
                            goToIndex(index);
                          }}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter' || e.key === ' ') {
                              e.preventDefault();
                              goToIndex(index);
                            }
                          }}
                        >
                          {/* 썸네일 이미지 - object-contain으로 비율 유지 */}
                          {clip.thumbnail ? (
                            <div
                              className="absolute inset-0 bg-center bg-no-repeat transition-all duration-200 hover:brightness-110"
                              style={{ 
                                backgroundImage: `url('${clip.thumbnail}')`,
                                backgroundSize: 'contain'
                              }}
                            />
                          ) : (
                            <div className="absolute inset-0 flex items-center justify-center text-gray-600">
                              <i className="ri-video-line text-4xl"></i>
                            </div>
                          )}
                          
                          {/* 중앙 클립 강조 효과 */}
                          {isCenter && (
                            <div className="absolute inset-0 bg-gradient-to-t from-black/20 to-transparent pointer-events-none" />
                          )}
                          
                          {/* 삭제 버튼 - 중앙 클립에만 표시 */}
                          {onRemoveClip && isCenter && (
                            <div className="absolute bottom-2 right-2">
                              <div
                                role="button"
                                tabIndex={0}
                                className="w-7 h-7 flex items-center justify-center bg-black/40 hover:bg-black/60 rounded transition-opacity"
                                onClick={(e) => { 
                                  e.stopPropagation(); 
                                  onRemoveClip(clip.id);
                                  // 삭제 후 인덱스 조정
                                  if (index === clips.length - 1 && index > 0) {
                                    setCurrentIndex(index - 1);
                                  }
                                }}
                                onKeyDown={(e) => {
                                  if (e.key === 'Enter' || e.key === ' ') {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    onRemoveClip(clip.id);
                                  }
                                }}
                                aria-label="Remove clip"
                              >
                                <i className="ri-delete-bin-line text-white text-xs"></i>
                              </div>
                            </div>
                          )}
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          ) : (
            /* 빈 상태 표시 */
            <div className="flex-1 flex items-center justify-center">
              <div className="text-green-500 text-sm">
                No clips added yet
              </div>
            </div>
          )}

            {/* 다음 버튼 */}
            <button
              onClick={handleNext}
              disabled={!canGoNext}
              className={`flex-shrink-0 w-10 h-10 flex items-center justify-center rounded-full transition-all ${
                canGoNext 
                  ? 'bg-white/10 hover:bg-white/20 text-white cursor-pointer' 
                  : 'bg-white/5 text-gray-600 cursor-not-allowed'
              }`}
              aria-label="Next clips"
            >
              <i className="ri-arrow-right-s-line text-xl"></i>
            </button>
          </div>
          
          {/* 페이지 인디케이터 - 하단에 위치 */}
          {clips.length > 1 && (
            <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2 flex gap-1.5 bg-black/50 px-3 py-2 rounded-full">
              {clips.map((_, index) => {
                const isActive = index === currentIndex;
                return (
                  <button
                    key={index}
                    onClick={() => goToIndex(index)}
                    className={`rounded-full transition-all duration-300 ${
                      isActive 
                        ? 'bg-[#38f47cf9] w-6 h-1.5' 
                        : 'bg-gray-600 w-1.5 h-1.5 hover:bg-gray-500'
                    }`}
                    aria-label={`Go to clip ${index + 1}`}
                  />
                );
              })}
            </div>
          )}
        </div>

        {/* 중앙 구분선 */}
        <div className="w-px bg-gray-700"></div>

        {/* 우측 50%: 편집 화면 - 모든 트랙 합성 */}
        <div className="w-1/2 bg-gray-900 rounded-lg overflow-hidden relative flex flex-col pl-2">
          {/* 상단 컨트롤 바 */}
          <div className="bg-gray-800/50 backdrop-blur-sm border-b border-gray-700 px-3 py-2 flex justify-between items-center z-20">
            <div className="flex items-center gap-2">
              <div className="bg-black/50 px-2 py-1 rounded text-xs font-medium">
                Editor
              </div>
            </div>
            {/* 비디오 컨트롤 버튼들 */}
            <div className="flex gap-2">
              {/* Preview 버튼 */}
              <div className="relative group">
                <button 
                  className="p-2 bg-black/50 rounded hover:bg-black/70 transition-colors"
                  onClick={() => setIsFullscreenOpen(true)}
                >
                  <i className="ri-play-circle-line text-primary"></i>
                </button>
                <div className="absolute top-full mt-1 left-1/2 -translate-x-1/2 px-2 py-1 bg-gray-900 text-white text-xs rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-50">
                  Preview
                </div>
              </div>
              
              {/* Export Video 버튼 (Save + Download 통합) */}
              <div className="relative group">
                <button 
                  className="p-2 bg-black/50 rounded hover:bg-black/70 transition-colors"
                  onClick={handleExportVideo}
                  disabled={isRendering}
                >
                  {isRendering ? (
                    <div className="w-4 h-4 border-2 border-gray-500 border-t-primary rounded-full animate-spin" />
                  ) : (
                    <i className="ri-video-download-line text-primary"></i>
                  )}
                </button>
                <div className="absolute top-full mt-1 left-1/2 -translate-x-1/2 px-2 py-1 bg-gray-900 text-white text-xs rounded whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none z-50">
                  {isRendering ? `Rendering... ${renderProgress}%` : 'Export Video'}
                </div>
              </div>
              
              {/* 구분선 */}
              <div className="w-px bg-gray-600 mx-1" />
              
              {/* 화면 비율 선택 버튼 */}
              <div className="flex gap-1 bg-black/50 rounded p-1">
              <button
                onClick={() => setSelectedAspectRatio('9:16')}
                className={`px-2 py-1 rounded text-xs transition-colors ${
                  selectedAspectRatio === '9:16' 
                    ? 'bg-[#38f47cf9] text-black font-medium' 
                    : 'hover:bg-white/10 text-gray-400'
                }`}
                title="Mobile (9:16)"
              >
                9:16
              </button>
              <button
                onClick={() => setSelectedAspectRatio('1:1')}
                className={`px-2 py-1 rounded text-xs transition-colors ${
                  selectedAspectRatio === '1:1' 
                    ? 'bg-[#38f47cf9] text-black font-medium' 
                    : 'hover:bg-white/10 text-gray-400'
                }`}
                title="Square (1:1)"
              >
                1:1
              </button>
              <button
                onClick={() => setSelectedAspectRatio('16:9')}
                className={`px-2 py-1 rounded text-xs transition-colors ${
                  selectedAspectRatio === '16:9' 
                    ? 'bg-[#38f47cf9] text-black font-medium' 
                    : 'hover:bg-white/10 text-gray-400'
                }`}
                title="Wide (16:9)"
              >
                16:9
              </button>
              </div>
            </div>
          </div>
          {/* 비디오 프리뷰 영역 */}
          <div className="flex-1 relative flex items-center justify-center p-2 bg-gray-500">
            {/* 체커보드 패턴 오버레이 */}
            <div className="absolute inset-0">
              <div className="h-full w-full" style={{
                backgroundImage: 'linear-gradient(45deg, #606060 25%, transparent 25%), linear-gradient(-45deg, #606060 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #606060 75%), linear-gradient(-45deg, transparent 75%, #606060 75%)',
                backgroundSize: '20px 20px',
                backgroundPosition: '0 0, 0 10px, 10px -10px, -10px 0px',
                backgroundColor: '#505050'
              }} />
            </div>
            {clips.length > 0 || textClips.length > 0 || soundClips.length > 0 ? (
              <div 
                className="relative shadow-2xl"
                style={{
                  width: selectedAspectRatio === '16:9' ? '95%' : 
                         selectedAspectRatio === '1:1' ? 'auto' : 'auto',
                  height: selectedAspectRatio === '16:9' ? 'auto' : 
                          selectedAspectRatio === '1:1' ? '95%' : '95%',
                  maxWidth: '95%',
                  maxHeight: '95%',
                  aspectRatio: aspectRatioDimensions.displayRatio,
                }}
              >
                {/* 빨간 테두리 - 시각적 가이드 (오버레이 클릭 방해하지 않도록 뒤로 보내고 포인터 이벤트 비활성화) */}
                <div 
                  className="absolute inset-0 z-10"
                  style={{
                    border: `2px solid ${STYLES.BORDER_COLOR}`,
                    borderRadius: '0.5rem',
                    pointerEvents: 'none'
                  }}
                />
                
                {/* 콘텐츠 컨테이너 */}
                <div 
                  className="relative w-full h-full rounded-lg overflow-hidden"
                  style={{ 
                    backgroundColor: 'transparent'
                  }}
                >
                  <Player
                  ref={playerRef}
                  component={CompositePreview as unknown as React.ComponentType<Record<string, unknown>>}
                  inputProps={{
                    videoClips: clips,
                    textClips: textClips, // 텍스트 효과를 표시하기 위해 실제 데이터 전달
                    soundClips: memoizedSoundClips,
                    pixelsPerSecond: 40,
                    backgroundColor: 'black' // 항상 검은색 배경으로 설정하여 letterbox 효과
                  }}
                  durationInFrames={calculateTotalFrames}
                  compositionWidth={videoAspectRatio.width}
                  compositionHeight={videoAspectRatio.height}
                  fps={30}
                  style={{ 
                    width: '100%', 
                    height: '100%',
                    display: 'block'
                  }}
                  controls={false}
                  showVolumeControls={true}
                  clickToPlay={false}
                  doubleClickToFullscreen={false}
                  />
                  
                  {/* Buffering indicator overlay */}
                  {isBuffering && (
                    <BufferingSpinner
                      message="Buffering"
                      submessage="Loading content..."
                      isOverlay={true}
                      overlayOpacity="light"
                    />
                  )}
                  
                  
                  {/* 텍스트 편집 오버레이 - Player와 같은 컨테이너 내에 위치 */}
                  <TextOverlayEditor
                    textClips={textClips}
                    containerWidth={videoAspectRatio.width}
                    containerHeight={videoAspectRatio.height}
                    currentTime={currentTime || 0}
                    pixelsPerSecond={40}
                    onUpdatePosition={(id, x, y) => {
                      if (onUpdateTextPosition) {
                        onUpdateTextPosition(id, x, y);
                      }
                    }}
                    onUpdateSize={(id, fontSize, fontSizeRatio) => {
                      if (onUpdateTextSize) {
                        onUpdateTextSize(id, fontSize, fontSizeRatio);
                      }
                    }}
                    selectedClip={selectedTextClip || null}
                    onSelectClip={(id) => {
                      if (onSelectTextClip) {
                        onSelectTextClip(id);
                      }
                    }}
                    aspectRatio={selectedAspectRatio}
                  />
                </div>
              </div>
            ) : (
              <div className="w-full h-full flex items-center justify-center p-8">
                <div 
                  className="relative shadow-2xl"
                  style={{
                    width: selectedAspectRatio === '16:9' ? '95%' : 
                           selectedAspectRatio === '1:1' ? 'auto' : 'auto',
                    height: selectedAspectRatio === '16:9' ? 'auto' : 
                            selectedAspectRatio === '1:1' ? '95%' : '95%',
                    maxWidth: '95%',
                    maxHeight: '95%',
                    aspectRatio: aspectRatioDimensions.displayRatio,
                  }}
                >
                  {/* 빨간 테두리 - 시각적 가이드 (오버레이 클릭 방해하지 않도록 뒤로 보내고 포인터 이벤트 비활성화) */}
                  <div 
                    className="absolute inset-0 z-10"
                    style={{
                      border: `2px solid ${STYLES.BORDER_COLOR}`,
                      borderRadius: '0.5rem',
                      pointerEvents: 'none'
                    }}
                  />
                  
                  {/* 콘텐츠 */}
                  <div 
                    className="relative w-full h-full rounded-lg flex items-center justify-center"
                    style={{ 
                      backgroundColor: 'transparent'
                    }}
                  >
                    <div className="text-green-500 text-sm text-center">
                      <div className="mb-2">Add clips to see preview</div>
                      <div className="text-xs text-green-500">
                      
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
      
      {/* 전체 화면 미리보기 모달 */}
      <FullscreenPreviewModal
        isOpen={isFullscreenOpen}
        onClose={() => setIsFullscreenOpen(false)}
        clips={clips}
        textClips={textClips}
        soundClips={memoizedSoundClips}
        aspectRatio={selectedAspectRatio}
        videoWidth={videoAspectRatio.width}
        videoHeight={videoAspectRatio.height}
      />
      
      {/* 렌더링 모달 */}
      <RenderingModal
        isOpen={isRenderModalOpen}
        onClose={() => {
          setIsRenderModalOpen(false);
          setRenderComplete(false);
          setRenderProgress(0);
        }}
        renderProgress={renderProgress}
        renderComplete={renderComplete}
        renderOutputUrl={renderOutputUrl}
      />
    </div>
  );
}
</file>

<file path="app/video-editor/page.tsx">
'use client';

import { useEffect, useState, useCallback } from 'react';
import { Header } from '@/components/layout/Header';
import { LibraryModal } from '@/components/modals/LibraryModal';
import { VideoEditorProviders, useClips, usePlayback, useHistory, useProject } from './_context/Providers';
import VideoPreview from './_components/VideoPreview';
import Timeline from './_components/Timeline';
import VideoLibraryModal from './_components/VideoLibraryModal';
import SoundLibraryModal from './_components/SoundLibraryModal';
import TextEditorModal from './_components/TextEditorModal';

// 실제 Video Editor 컴포넌트 (Context 사용)
function VideoEditorContent() {
  // Context에서 가져오기
  const {
    projectTitle,
    setProjectTitle,
    timelineHeight,
    isResizing,
    handleResizerMouseDown,
    containerRef,
    showVideoLibrary,
    showSoundLibrary,
    showTextEditor,
    showLibrary,
    setShowVideoLibrary,
    setShowSoundLibrary,
    setShowTextEditor,
    setShowLibrary,
    handleAddClip,
    handleAddSound,
    handleAddText: handleAddTextButton,
  } = useProject();
  
  // ClipContext에서 가져오기
  const {
    timelineClips,
    textClips,
    soundClips,
    selectedTextClip,
    editingTextClip,
    setSelectedTextClip,
    setEditingTextClip,
    handleAddToTimeline,
    handleDeleteVideoClip,
    handleDuplicateVideoClip,
    handleSplitVideoClip: contextSplitVideoClip,
    handleResizeVideoClip,
    handleUpdateVideoClipPosition,
    handleUpdateAllVideoClips,
    handleReorderVideoClips,
    handleAddTextClip,
    handleEditTextClip,
    handleDeleteTextClip,
    handleDuplicateTextClip,
    handleSplitTextClip: contextSplitTextClip,
    handleResizeTextClip,
    handleUpdateTextClipPosition,
    handleUpdateAllTextClips,
    handleReorderTextClips,
    handleUpdateTextPosition,
    handleUpdateTextSize,
    handleAddSoundClips,
    handleDeleteSoundClip,
    handleDuplicateSoundClip,
    handleSplitSoundClip: contextSplitSoundClip,
    handleResizeSoundClip,
    handleUpdateSoundClipPosition,
    handleUpdateAllSoundClips,
    handleReorderSoundClips,
    handleUpdateSoundVolume,
    handleUpdateSoundFade,
  } = useClips();
  
  // PlaybackContext에서 가져오기
  const {
    isPlaying,
    currentTime,
    totalDuration,
    playerRef,
    handlePlayPause,
    handleSeek,
    setIsPlaying,
  } = usePlayback();
  
  // HistoryContext에서 가져오기
  const {
    canUndo,
    canRedo,
    handleUndo,
    handleRedo,
  } = useHistory();
  
  // URL 파라미터 처리는 ProjectContext에서 이미 처리됨
  
  // 타임라인 스케일: 1초당 몇 px로 표시할지 결정
  const PIXELS_PER_SECOND = 40;
  
  // editingTextClip이 변경될 때 모달을 열기
  useEffect(() => {
    if (editingTextClip) {
      setShowTextEditor(true);
    }
  }, [editingTextClip, setShowTextEditor]);
  
  // Split 함수들 - currentTime을 전달하기 위한 래퍼
  const handleSplitVideoClip = (id: string) => {
    contextSplitVideoClip(id, currentTime, PIXELS_PER_SECOND);
  };
  
  const handleSplitTextClip = (id: string) => {
    contextSplitTextClip(id, currentTime, PIXELS_PER_SECOND);
  };
  
  const handleSplitSoundClip = (id: string) => {
    contextSplitSoundClip(id, currentTime, PIXELS_PER_SECOND);
  };

  // handleAddText 함수 (텍스트 에디터 모달용)
  const handleAddText = () => {
    setEditingTextClip(undefined);
    handleAddTextButton();
  };

  // 프레임 동기화를 위한 폴링 - PlaybackContext에서 이미 처리됨
  // 삭제된 함수들: getVideoDurationSeconds, extractTitleFromUrl, handleAddToTimeline 등
  // 이제 모두 Context에서 처리

  const handleEditSoundClip = () => {
    // TODO: Implement sound editing modal
  };
  
  // Favorites 상태 관리 (간단한 로컬 상태로 처리)
  const [favoriteVideos, setFavoriteVideos] = useState<Set<string>>(new Set());
  
  const handleToggleFavorite = useCallback((videoId: string) => {
    setFavoriteVideos(prev => {
      const newSet = new Set(prev);
      if (newSet.has(videoId)) {
        newSet.delete(videoId);
      } else {
        newSet.add(videoId);
      }
      return newSet;
    });
  }, []);

  // 리사이저 이벤트는 ProjectContext에서 이미 처리됨

  return (
    <div ref={containerRef} className="bg-background text-foreground h-screen overflow-hidden flex flex-col">
      <Header 
        activePage="edit"
        projectTitle={projectTitle}
        onProjectTitleChange={setProjectTitle}
        onLibraryClick={() => setShowLibrary(true)}
      />
      
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* 비디오 프리뷰 영역 - 타임라인 높이에 따라 유동적 */}
        <div className="flex-1 min-h-0 overflow-hidden relative">
          <VideoPreview 
            clips={timelineClips}
            textClips={textClips}
            soundClips={soundClips}
            onRemoveClip={handleDeleteVideoClip}
            playerRef={playerRef}
            currentTime={currentTime}
            isPlaying={isPlaying}
            onPlayStateChange={setIsPlaying}
            onUpdateTextPosition={handleUpdateTextPosition}
            onUpdateTextSize={handleUpdateTextSize}
            selectedTextClip={selectedTextClip}
            onSelectTextClip={setSelectedTextClip}
            projectTitle={projectTitle}
          />
        </div>

        {/* 리사이저 바 - 아래로만 드래그 가능 */}
        <div 
          className={`h-1 bg-gray-700 hover:bg-[#38f47cf9] transition-colors relative ${
            isResizing ? 'bg-[#38f47cf9]' : ''
          } ${timelineHeight >= 300 ? 'cursor-s-resize' : 'cursor-ns-resize'}`}
          onMouseDown={handleResizerMouseDown}
          title={timelineHeight >= 300 ? "드래그하여 타임라인 축소" : "드래그하여 타임라인 크기 조정"}
        >
          {/* 리사이저 핸들 아이콘 */}
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="flex flex-col gap-0.5">
              <div className="w-8 h-0.5 bg-gray-500 rounded-full" />
              <div className="w-8 h-0.5 bg-gray-500 rounded-full" />
            </div>
          </div>
        </div>

        {/* 타임라인 영역 - 고정 높이 */}
        <div 
          className="flex-shrink-0 relative"
          style={{ height: `${timelineHeight}px` }}
        >
          <Timeline 
          clips={timelineClips}
          textClips={textClips}
          soundClips={soundClips}
          onAddClip={handleAddClip}
          onAddText={handleAddText}
          onAddSound={handleAddSound}
          onEditTextClip={handleEditTextClip}
          onEditSoundClip={handleEditSoundClip}
          onDeleteTextClip={handleDeleteTextClip}
          onDeleteSoundClip={handleDeleteSoundClip}
          onDeleteVideoClip={handleDeleteVideoClip}
          onDuplicateVideoClip={handleDuplicateVideoClip}
          onDuplicateTextClip={handleDuplicateTextClip}
          onDuplicateSoundClip={handleDuplicateSoundClip}
          onSplitVideoClip={handleSplitVideoClip}
          onSplitTextClip={handleSplitTextClip}
          onSplitSoundClip={handleSplitSoundClip}
          onResizeTextClip={handleResizeTextClip}
          onResizeSoundClip={handleResizeSoundClip}
          onReorderVideoClips={handleReorderVideoClips}
          onReorderTextClips={handleReorderTextClips}
          onReorderSoundClips={handleReorderSoundClips}
          onResizeVideoClip={handleResizeVideoClip}
          onUpdateVideoClipPosition={handleUpdateVideoClipPosition}
          onUpdateTextClipPosition={handleUpdateTextClipPosition}
          onUpdateSoundClipPosition={handleUpdateSoundClipPosition}
          onUpdateAllVideoClips={handleUpdateAllVideoClips}
          onUpdateAllTextClips={handleUpdateAllTextClips}
          onUpdateAllSoundClips={handleUpdateAllSoundClips}
          onUpdateSoundVolume={handleUpdateSoundVolume}
          onUpdateSoundFade={handleUpdateSoundFade}
          pixelsPerSecond={PIXELS_PER_SECOND}
          currentTime={currentTime}
          totalDuration={totalDuration}
          isPlaying={isPlaying}
          onSeek={handleSeek}
          onPlayPause={handlePlayPause}
          onUndo={handleUndo}
          onRedo={handleRedo}
          canUndo={canUndo}
          canRedo={canRedo}
          />
        </div>
      </div>

      {showVideoLibrary && (
        <VideoLibraryModal
          onClose={() => setShowVideoLibrary(false)}
          onAddToTimeline={handleAddToTimeline}
        />
      )}

      {showSoundLibrary && (
        <SoundLibraryModal
          onClose={() => setShowSoundLibrary(false)}
          onCreateVideo={() => {
            // TODO: Implement create video functionality
          }}
          onSelectSounds={async (sounds) => {
            // 사운드 클립들을 추가
            await handleAddSoundClips(sounds);
            setShowSoundLibrary(false);
          }}
        />
      )}

      {showTextEditor && (
        <TextEditorModal
          isOpen={showTextEditor}
          onClose={() => {
            setShowTextEditor(false);
            setEditingTextClip(undefined);
          }}
          onAddText={handleAddTextClip}
          editingClip={editingTextClip}
        />
      )}
      
      {showLibrary && (
        <LibraryModal
          isOpen={showLibrary}
          onClose={() => setShowLibrary(false)}
          favoriteVideos={favoriteVideos}
          onToggleFavorite={handleToggleFavorite}
        />
      )}
    </div>
  );
}

// Context Provider로 감싼 페이지 컴포넌트
export default function VideoEditorPage() {
  return (
    <VideoEditorProviders>
      <VideoEditorContent />
    </VideoEditorProviders>
  );
}
</file>

<file path="app/video-editor/_components/Timeline.tsx">
'use client';

import { useEffect, useRef, useCallback, useState } from 'react';
import { VideoClip as VideoClipType, TextClip as TextClipType, SoundClip as SoundClipType } from '@/types/video-editor';
import TimelineControls from './TimelineControls';
import TimelineTrack from './TimelineTrack';
import TimelinePlayhead from './TimelinePlayhead';
import TimelineSelectionBox from './TimelineSelectionBox';
import { useTimelineState } from '../_hooks/useTimelineState';
import { useDragAndDrop } from '../_hooks/useDragAndDrop';
import { useSelectionState } from '../_hooks/useSelectionState';
import { calculateTimelineDuration, generateTimeMarkers } from '../_utils/timeline-helpers';

interface TimelineProps {
  clips: VideoClipType[];
  textClips?: TextClipType[];
  soundClips?: SoundClipType[];
  onAddClip: () => void;
  onAddText?: () => void;
  onAddSound?: () => void;
  onEditTextClip?: (clip: TextClipType) => void;
  onEditSoundClip?: (clip: SoundClipType) => void;
  onDeleteTextClip?: (id: string) => void;
  onDeleteSoundClip?: (id: string) => void;
  onDeleteVideoClip?: (id: string) => void;
  onDuplicateVideoClip?: (id: string) => void;
  onDuplicateTextClip?: (id: string) => void;
  onDuplicateSoundClip?: (id: string) => void;
  onSplitVideoClip?: (id: string) => void;
  onSplitTextClip?: (id: string) => void;
  onSplitSoundClip?: (id: string) => void;
  onResizeTextClip?: (id: string, newDuration: number) => void;
  onResizeSoundClip?: (id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => void;
  onReorderVideoClips?: (clips: VideoClipType[]) => void;
  onUpdateVideoClipPosition?: (id: string, newPosition: number) => void;
  onUpdateTextClipPosition?: (id: string, newPosition: number) => void;
  onReorderTextClips?: (clips: TextClipType[]) => void;
  onReorderSoundClips?: (clips: SoundClipType[]) => void;
  onResizeVideoClip?: (id: string, newDuration: number, handle?: 'left' | 'right', deltaPosition?: number) => void;
  onUpdateSoundClipPosition?: (id: string, newPosition: number) => void;
  onUpdateAllVideoClips?: (clips: VideoClipType[]) => void;
  onUpdateAllTextClips?: (clips: TextClipType[]) => void;
  onUpdateAllSoundClips?: (clips: SoundClipType[]) => void;
  onUpdateSoundVolume?: (id: string, volume: number) => void;
  onUpdateSoundFade?: (id: string, fadeType: 'fadeIn' | 'fadeOut', duration: number) => void;
  pixelsPerSecond?: number;
  currentTime?: number;
  totalDuration?: number;
  isPlaying?: boolean;
  onSeek?: (time: number) => void;
  onPlayPause?: () => void;
  onUndo?: () => void;
  onRedo?: () => void;
  canUndo?: boolean;
  canRedo?: boolean;
}

export default function Timeline({ 
  clips, 
  textClips = [],
  soundClips = [],
  onAddClip,
  onAddText,
  onAddSound,
  onEditTextClip,
  onEditSoundClip,
  onDeleteTextClip,
  onDeleteSoundClip,
  onDeleteVideoClip,
  onDuplicateVideoClip,
  onDuplicateTextClip,
  onDuplicateSoundClip,
  onSplitVideoClip,
  onSplitTextClip,
  onSplitSoundClip,
  onResizeTextClip,
  onResizeSoundClip,
  onUpdateVideoClipPosition,
  onUpdateTextClipPosition,
  onResizeVideoClip,
  onUpdateSoundClipPosition,
  onUpdateAllVideoClips,
  onUpdateAllTextClips,
  onUpdateAllSoundClips,
  onUpdateSoundVolume,
  onUpdateSoundFade,
  pixelsPerSecond: initialPixelsPerSecond = 40,
  currentTime = 0,
  totalDuration: propTotalDuration,
  isPlaying = false,
  onSeek,
  onPlayPause,
  onUndo,
  onRedo,
  canUndo = false,
  canRedo = false,
}: TimelineProps) {
  // 줌 레벨 상태 관리
  const [pixelsPerSecond, setPixelsPerSecond] = useState(initialPixelsPerSecond);
  // Use custom hooks for state management
  const {
    activeClip,
    activeClipType,
    selectedClip,
    selectedClipType,
    rectSelectedClips,
    setActiveClipInfo,
    selectClip,
    clearSelection,
    setRectSelectedClips,
  } = useTimelineState();

  const {
    isDragging,
    dragStartX,
    isResizing,
    resizeHandle,
    startWidth,
    startPosition,
    resizeMoved,
    finalResizeWidth,
    finalResizePosition,
    isDraggingPlayhead,
    setIsDraggingPlayhead,
    startDrag,
    startResize,
    resetDragState,
    updateDragDirection,
    checkResizeActivation,
    setFinalResizeWidth,
    setFinalResizePosition,
  } = useDragAndDrop();

  const {
    selectionContainerRef,
    isSelectingRange,
    selectionStartX,
    selectionCurrentX,
    selectionStartY,
    selectionCurrentY,
    isRangeActive,
    selectionRangeStartX,
    selectionRangeEndX,
    selectionRangeStartY,
    selectionRangeEndY,
    isAdjustingSelection,
    isMovingSelection,
    startSelection,
    updateSelection,
    endSelection,
    startAdjustSelection,
    startMoveSelection,
    getSelectionBounds,
  } = useSelectionState();

  const playheadRef = useRef<HTMLDivElement>(null);

  // 줌 변경 핸들러
  const handleZoomChange = (direction: 'in' | 'out') => {
    setPixelsPerSecond(prev => {
      const basePixelsPerSecond = 40; // 기본값 (100%)
      const currentPercent = (prev / basePixelsPerSecond) * 100;
      const zoomStep = 10; // 10% 단위로 조절
      const minPercent = 50;  // 최소 50% (축소 제한)
      const maxPercent = 200; // 최대 200% (확대 제한)
      
      let newPercent: number;
      if (direction === 'in') {
        // 줌 인 (확대) - 10% 증가
        newPercent = Math.min(maxPercent, currentPercent + zoomStep);
      } else {
        // 줌 아웃 (축소) - 10% 감소
        newPercent = Math.max(minPercent, currentPercent - zoomStep);
      }
      
      // 퍼센트를 픽셀로 변환
      return Math.round((newPercent / 100) * basePixelsPerSecond);
    });
  };

  // Helper function to check if click is near playhead
  const isNearPlayhead = useCallback((clientX: number): boolean => {
    const scrollContainer = document.querySelector('.timeline-content .overflow-x-auto');
    if (!scrollContainer) return false;
    
    const rect = scrollContainer.getBoundingClientRect();
    const scrollLeft = scrollContainer.scrollLeft;
    const x = clientX - rect.left - 192 + scrollLeft; // 192 is the left panel width
    const clickPosition = x;
    const playheadPos = currentTime * pixelsPerSecond;
    
    // Return true if click is within 8 pixels of playhead
    return Math.abs(clickPosition - playheadPos) < 8;
  }, [currentTime, pixelsPerSecond]);

  // Calculate timeline duration with zoom
  const basePixelsPerSecond = 40;
  
  // 기본 스케일로 총 시간 계산 (초 단위) - props로 받거나 직접 계산
  const totalDurationInSeconds = propTotalDuration ?? calculateTimelineDuration(clips, textClips, soundClips, basePixelsPerSecond);
  const minimumDuration = 120; // 120초 (2분) - 기본 표시 시간
  const bufferTime = 10; // 10초 버퍼
  const timelineLengthInSeconds = Math.max(minimumDuration, Math.ceil(totalDurationInSeconds + bufferTime));
  
  // 줌 적용된 픽셀 값
  const timeMarkers = generateTimeMarkers(timelineLengthInSeconds);
  const playheadPosition = currentTime * pixelsPerSecond;

  // Update rect selected clips based on selection area
  const updateRectSelectedClips = (left: number, right: number, top: number, bottom: number) => {
    const container = selectionContainerRef.current;
    if (!container) return;
    const containerRect = container.getBoundingClientRect();
    const elements = container.querySelectorAll<HTMLElement>('.timeline-clip');
    const intersecting: { id: string; type: 'video' | 'text' | 'sound' }[] = [];
    
    elements.forEach((el) => {
      const elRect = el.getBoundingClientRect();
      const elLeft = elRect.left - containerRect.left;
      const elRight = elRect.right - containerRect.left;
      const elTop = elRect.top - containerRect.top;
      const elBottom = elRect.bottom - containerRect.top;
      const overlap = elLeft < right && elRight > left && elTop < bottom && elBottom > top;
      
      if (overlap) {
        const id = el.getAttribute('data-clip-id') || '';
        const typeAttr = el.getAttribute('data-clip-type');
        if (id && (typeAttr === 'video' || typeAttr === 'text' || typeAttr === 'sound')) {
          intersecting.push({ id, type: typeAttr as 'video' | 'text' | 'sound' });
        }
      }
    });
    
    setRectSelectedClips(intersecting);
  };

  // Handle mouse down on clip
  const handleMouseDown = (e: React.MouseEvent, clipId: string, clipType: 'video' | 'text' | 'sound') => {
    // Check if click is near playhead first - if so, start dragging playhead instead
    if (isNearPlayhead(e.clientX)) {
      e.preventDefault();
      e.stopPropagation();
      setIsDraggingPlayhead(true);
      return;
    }
    
    if (e.shiftKey || isSelectingRange || isAdjustingSelection || isMovingSelection) {
      return;
    }
    if ((e.target as HTMLElement).classList.contains('resize-handle')) {
      return;
    }
    
    startDrag(e.clientX);
    setActiveClipInfo(clipId, clipType);
    selectClip(clipId, clipType);
  };

  // Handle resize start
  const handleResizeStart = (e: React.MouseEvent, clipId: string, handle: 'left' | 'right', clipType: 'video' | 'text' | 'sound' = 'video') => {
    if (e.shiftKey || isSelectingRange || isAdjustingSelection || isMovingSelection) {
      e.stopPropagation();
      e.preventDefault();
      return;
    }
    
    e.stopPropagation();
    e.preventDefault();
    
    let currentWidth = 200;
    let currentPosition = 0;
    
    if (clipType === 'video') {
      const clip = clips.find(c => c.id === clipId);
      currentWidth = clip?.duration || 200;
      currentPosition = clip?.position || 0;
    } else if (clipType === 'text') {
      const clip = textClips.find(c => c.id === clipId);
      currentWidth = clip?.duration || 200;
      currentPosition = clip?.position || 0;
    } else if (clipType === 'sound') {
      const clip = soundClips.find(c => c.id === clipId);
      currentWidth = clip?.duration || 200;
      currentPosition = clip?.position || 0;
    }
    
    startResize(e.clientX, handle, currentWidth, currentPosition);
    setActiveClipInfo(clipId, clipType);
  };

  // Handle toolbar action
  const handleToolbarAction = (action: 'edit' | 'duplicate' | 'split' | 'delete') => {
    if (action === 'delete') {
      if (rectSelectedClips.length > 0) {
        rectSelectedClips.forEach(({ id, type }) => {
          if (type === 'video' && onDeleteVideoClip) onDeleteVideoClip(id);
          if (type === 'text' && onDeleteTextClip) onDeleteTextClip(id);
          if (type === 'sound' && onDeleteSoundClip) onDeleteSoundClip(id);
        });
        setRectSelectedClips([]);
        clearSelection();
        return;
      }
    }

    if (!selectedClip || !selectedClipType) return;

    switch (action) {
      case 'edit':
        if (selectedClipType === 'text' && onEditTextClip) {
          const clip = textClips.find(c => c.id === selectedClip);
          if (clip) onEditTextClip(clip);
        } else if (selectedClipType === 'sound' && onEditSoundClip) {
          const clip = soundClips.find(c => c.id === selectedClip);
          if (clip) onEditSoundClip(clip);
        }
        break;

      case 'duplicate':
        if (selectedClipType === 'video' && onDuplicateVideoClip) {
          onDuplicateVideoClip(selectedClip);
        } else if (selectedClipType === 'text' && onDuplicateTextClip) {
          onDuplicateTextClip(selectedClip);
        } else if (selectedClipType === 'sound' && onDuplicateSoundClip) {
          onDuplicateSoundClip(selectedClip);
        }
        break;

      case 'split':
        if (selectedClipType === 'video' && onSplitVideoClip) {
          onSplitVideoClip(selectedClip);
        } else if (selectedClipType === 'text' && onSplitTextClip) {
          onSplitTextClip(selectedClip);
        } else if (selectedClipType === 'sound' && onSplitSoundClip) {
          onSplitSoundClip(selectedClip);
        }
        break;

      case 'delete':
        if (selectedClipType === 'video' && onDeleteVideoClip) {
          onDeleteVideoClip(selectedClip);
        } else if (selectedClipType === 'text' && onDeleteTextClip) {
          onDeleteTextClip(selectedClip);
        } else if (selectedClipType === 'sound' && onDeleteSoundClip) {
          onDeleteSoundClip(selectedClip);
        }
        clearSelection();
        break;
    }
  };

  // Check if split is possible
  const canSplit = () => {
    if (!selectedClip || !selectedClipType) return false;
    const playheadPos = currentTime * pixelsPerSecond;
    
    if (selectedClipType === 'video') {
      const clip = clips.find(c => c.id === selectedClip);
      if (clip) {
        return playheadPos > clip.position && playheadPos < clip.position + clip.duration;
      }
    } else if (selectedClipType === 'text') {
      const clip = textClips.find(c => c.id === selectedClip);
      if (clip) {
        return playheadPos > clip.position && playheadPos < clip.position + clip.duration;
      }
    } else if (selectedClipType === 'sound') {
      const clip = soundClips.find(c => c.id === selectedClip);
      if (clip) {
        return playheadPos > clip.position && playheadPos < clip.position + clip.duration;
      }
    }
    
    return false;
  };

  // Handle timeline click for seeking
  const handleTimelineClick = (e: React.MouseEvent<HTMLDivElement>) => {
    if (e.shiftKey || isSelectingRange || isAdjustingSelection || isMovingSelection) return;
    if (!onSeek || isResizing || isDragging) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const time = Math.max(0, Math.min(x / pixelsPerSecond, totalDurationInSeconds));
    onSeek(time);
  };

  // Handle track click for seeking
  const handleTrackClick = (e: React.MouseEvent<HTMLDivElement>) => {
    // Check if click is near playhead first - if so, start dragging instead of seeking
    if (isNearPlayhead(e.clientX)) {
      e.preventDefault();
      e.stopPropagation();
      setIsDraggingPlayhead(true);
      return;
    }
    
    if ((e.target as HTMLElement).closest('.timeline-clip')) return;
    if (e.shiftKey || isSelectingRange || isAdjustingSelection || isMovingSelection) return;
    if (!onSeek || isResizing || isDragging) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const time = Math.max(0, Math.min(x / pixelsPerSecond, totalDurationInSeconds));
    onSeek(time);
  };

  // Handle playhead drag
  const handlePlayheadMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    if (e.shiftKey || isSelectingRange || isAdjustingSelection || isMovingSelection) return;
    setIsDraggingPlayhead(true);
  };

  // Handle selection mouse down
  const handleSelectionMouseDown = (e: React.MouseEvent<HTMLDivElement>) => {
    // Check if click is near playhead first
    if (isNearPlayhead(e.clientX)) {
      e.preventDefault();
      e.stopPropagation();
      setIsDraggingPlayhead(true);
      return;
    }
    
    if (isDragging || isResizing || isAdjustingSelection || isMovingSelection) return;
    const target = e.target as HTMLElement;
    if (target.closest('.timeline-clip')) return;
    if (target.closest('.resize-handle')) return;
    if (playheadRef.current && playheadRef.current.contains(target)) return;

    const container = selectionContainerRef.current;
    if (!container) return;
    const rect = container.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    if (y <= 32) return; // Timeline header protection

    e.preventDefault();
    e.stopPropagation();

    const clampedX = Math.max(0, Math.min(x, rect.width));
    const clampedY = Math.max(0, Math.min(y, rect.height));
    
    clearSelection();
    startSelection(clampedX, clampedY);
  };

  // Mouse move and mouse up effects
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!activeClip) return;

      if (isResizing) {
        const delta = e.clientX - dragStartX;
        const activated = checkResizeActivation(e.clientX);
        
        if (!activated) return;

        let newWidth = startWidth;
        let newPosition = startPosition;

        // Calculate new dimensions based on resize handle

        if (resizeHandle === 'left') {
          newPosition = Math.max(0, startPosition + delta);
          newWidth = startWidth + (startPosition - newPosition);
        } else {
          newWidth = startWidth + delta;
        }

        // Apply constraints
        newWidth = Math.max(80, newWidth);
        newPosition = Math.max(0, newPosition);

        setFinalResizeWidth(newWidth);
        setFinalResizePosition(newPosition);

        // Update DOM
        const clipElement = document.querySelector(`[data-clip-id="${activeClip}"]`) as HTMLElement;
        if (clipElement) {
          clipElement.style.width = `${newWidth}px`;
          if (resizeHandle === 'left') {
            clipElement.style.left = `${newPosition}px`;
          }
        }
      } else if (isDragging) {
        const delta = e.clientX - dragStartX;
        updateDragDirection(e.clientX);
        
        const clipElement = document.querySelector(`[data-clip-id="${activeClip}"]`) as HTMLElement;
        if (clipElement) {
          clipElement.style.transform = `translateX(${delta}px)`;
        }
      }
    };

    const handleMouseUp = () => {
      if (activeClip) {
        const clipElement = document.querySelector(`[data-clip-id="${activeClip}"]`) as HTMLElement;
        
        if (clipElement && isDragging) {
          const delta = parseFloat(clipElement.style.transform.replace(/translateX\(|px\)/g, '')) || 0;
          
          // Import helper functions for timeline positioning
          import('../_utils/timeline-utils').then(({ magneticPositioning, freePositioning, soundPositioning }) => {
            if (activeClipType === 'video' && onUpdateAllVideoClips) {
              const currentClip = clips.find(c => c.id === activeClip);
              if (currentClip) {
                const newPosition = Math.max(0, currentClip.position + delta);
                const { targetPosition, adjustedClips } = magneticPositioning(
                  clips,
                  activeClip,
                  newPosition,
                  currentClip.duration
                );
                
                const updatedClips = [
                  ...adjustedClips,
                  { ...currentClip, position: targetPosition }
                ].sort((a, b) => a.position - b.position);
                
                onUpdateAllVideoClips(updatedClips);
              }
            } else if (activeClipType === 'text' && onUpdateAllTextClips) {
              const currentClip = textClips.find(c => c.id === activeClip);
              if (currentClip) {
                const newPosition = Math.max(0, currentClip.position + delta);
                const targetPosition = freePositioning(
                  textClips,
                  activeClip,
                  newPosition,
                  currentClip.duration
                );
                
                const updatedClips = textClips.map(clip =>
                  clip.id === activeClip ? { ...clip, position: targetPosition } : clip
                ).sort((a, b) => a.position - b.position);
                
                onUpdateAllTextClips(updatedClips);
              }
            } else if (activeClipType === 'sound' && onUpdateAllSoundClips) {
              const currentClip = soundClips.find(c => c.id === activeClip);
              if (currentClip) {
                const newPosition = Math.max(0, currentClip.position + delta);
                const { targetPosition, adjustedClips } = soundPositioning(
                  soundClips,
                  activeClip,
                  newPosition,
                  currentClip.duration
                );
                
                const updatedClips = [
                  ...adjustedClips,
                  { ...currentClip, position: targetPosition }
                ].sort((a, b) => a.position - b.position);
                
                onUpdateAllSoundClips(updatedClips);
              }
            }
          });
          clipElement.style.transform = '';
        }
        
        // Handle resize end
        if (clipElement && isResizing && resizeMoved) {
          const finalWidth = finalResizeWidth || startWidth;
          const finalPosition = resizeHandle === 'left' ? finalResizePosition : startPosition;
          
          if (activeClipType === 'video') {
            if (resizeHandle === 'left' && onUpdateVideoClipPosition) {
              onUpdateVideoClipPosition(activeClip, finalPosition);
            }
            if (onResizeVideoClip) {
              const deltaPosition = resizeHandle === 'left' ? finalPosition - startPosition : 0;
              onResizeVideoClip(activeClip, finalWidth, resizeHandle || undefined, deltaPosition);
            }
          } else if (activeClipType === 'text') {
            if (resizeHandle === 'left' && onUpdateTextClipPosition) {
              onUpdateTextClipPosition(activeClip, finalPosition);
            }
            if (onResizeTextClip) {
              onResizeTextClip(activeClip, finalWidth);
            }
          } else if (activeClipType === 'sound') {
            if (resizeHandle === 'left' && onUpdateSoundClipPosition) {
              onUpdateSoundClipPosition(activeClip, finalPosition);
            }
            if (onResizeSoundClip) {
              const deltaPosition = resizeHandle === 'left' ? finalPosition - startPosition : 0;
              onResizeSoundClip(activeClip, finalWidth, resizeHandle || undefined, deltaPosition);
            }
          }
        }
      }
      
      setActiveClipInfo(null, null);
      resetDragState();
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    return () => {
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeClip, activeClipType, isDragging, isResizing, dragStartX, startWidth, startPosition, resizeHandle, clips, textClips, soundClips, resizeMoved, finalResizeWidth, finalResizePosition]);

  // Selection range effect
  useEffect(() => {
    if (!isSelectingRange) return;

    const handleMove = (e: MouseEvent) => {
      const container = selectionContainerRef.current;
      if (!container) return;
      const rect = container.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const clampedX = Math.max(0, Math.min(x, rect.width));
      const clampedY = Math.max(0, Math.min(y, rect.height));
      
      updateSelection(clampedX, clampedY);
      
      const left = Math.min(selectionStartX ?? 0, clampedX);
      const right = Math.max(selectionStartX ?? 0, clampedX);
      const top = Math.min(selectionStartY ?? 0, clampedY);
      const bottom = Math.max(selectionStartY ?? 0, clampedY);
      updateRectSelectedClips(left, right, top, bottom);
    };

    const handleUp = () => {
      if (selectionStartX === null || selectionCurrentX === null || 
          selectionStartY === null || selectionCurrentY === null) {
        endSelection();
        return;
      }

      const start = Math.min(selectionStartX, selectionCurrentX);
      const end = Math.max(selectionStartX, selectionCurrentX);
      const top = Math.min(selectionStartY, selectionCurrentY);
      const bottom = Math.max(selectionStartY, selectionCurrentY);
      const minDragPx = 5;
      
      if (end - start < minDragPx || bottom - top < 1) {
        setRectSelectedClips([]);
      }
      
      endSelection();
    };

    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleUp);
    
    return () => {
      document.removeEventListener('mousemove', handleMove);
      document.removeEventListener('mouseup', handleUp);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isSelectingRange, selectionStartX, selectionCurrentX, selectionStartY, selectionCurrentY]);

  // Playhead drag effect
  useEffect(() => {
    const handlePlayheadMouseMove = (e: MouseEvent) => {
      if (!isDraggingPlayhead || !onSeek) return;
      
      const scrollContainer = document.querySelector('.timeline-content .overflow-x-auto');
      if (!scrollContainer) return;
      
      const rect = scrollContainer.getBoundingClientRect();
      const scrollLeft = scrollContainer.scrollLeft;
      const x = e.clientX - rect.left - 192 + scrollLeft;
      // 직접 계산하여 클로저 이슈 방지 + 초당 과도한 onSeek 호출 제한
      const basePixelsPerSecond = 40;
      const time = Math.max(0, x / basePixelsPerSecond);

      // 프레임 단위(1/30초)로 스로틀링하여 setState 연쇄 방지
      const quantizedTime = Math.round(time * 30) / 30;
      onSeek(quantizedTime);
    };

    const handlePlayheadMouseUp = () => {
      setIsDraggingPlayhead(false);
    };

    if (isDraggingPlayhead) {
      document.addEventListener('mousemove', handlePlayheadMouseMove);
      document.addEventListener('mouseup', handlePlayheadMouseUp);
      return () => {
        document.removeEventListener('mousemove', handlePlayheadMouseMove);
        document.removeEventListener('mouseup', handlePlayheadMouseUp);
      };
    }
  }, [isDraggingPlayhead, onSeek, setIsDraggingPlayhead]);

  // Mouse move effect for cursor feedback near playhead
  useEffect(() => {
    const handleMouseMoveForCursor = (e: MouseEvent) => {
      // Only change cursor if not dragging anything
      if (isDragging || isResizing || isDraggingPlayhead || isSelectingRange) return;
      
      const scrollContainer = document.querySelector('.timeline-content .overflow-x-auto');
      if (!scrollContainer) return;
      
      // Check if mouse is near playhead
      if (isNearPlayhead(e.clientX)) {
        document.body.style.cursor = 'ew-resize';
      } else {
        document.body.style.cursor = '';
      }
    };
    
    document.addEventListener('mousemove', handleMouseMoveForCursor);
    return () => {
      document.removeEventListener('mousemove', handleMouseMoveForCursor);
      document.body.style.cursor = '';
    };
  }, [isDragging, isResizing, isDraggingPlayhead, isSelectingRange, isNearPlayhead]);


  // Get selection bounds for rendering
  const selectionBounds = getSelectionBounds();

  return (
    <div className="bg-gray-800 border-t border-gray-700 flex flex-col h-full">
      {/* Playback controls */}
      <TimelineControls
        isPlaying={isPlaying}
        currentTime={currentTime}
        totalDuration={totalDurationInSeconds}
        onPlayPause={onPlayPause || (() => {})}
        onSeek={onSeek || (() => {})}
        onUndo={onUndo}
        onRedo={onRedo}
        canUndo={canUndo}
        canRedo={canRedo}
      />

      <div className="relative flex-1 overflow-y-auto min-h-0 timeline-content">
        {/* Actions toolbar */}
        <div className="flex border-b border-gray-700 bg-gray-900">
          <div className="w-48 flex-shrink-0 p-1 border-r border-gray-700 flex items-center justify-center">
            <span className="text-[10px] text-gray-400 font-medium">Actions</span>
          </div>
          <div className="flex-1 p-1 flex items-center gap-2 px-3">
            <button
              onClick={() => handleToolbarAction('edit')}
              disabled={!selectedClip || (selectedClipType !== 'text' && selectedClipType !== 'sound')}
              className={`px-3 py-1 rounded text-xs flex items-center gap-1.5 transition-colors ${
                selectedClip && (selectedClipType === 'text' || selectedClipType === 'sound')
                  ? 'bg-gray-800 hover:bg-gray-700 text-white'
                  : 'bg-gray-900 text-gray-500 cursor-not-allowed'
              }`}
            >
              <i className="ri-edit-line text-[11px]"></i>
              <span>Edit</span>
            </button>
            
            <button
              onClick={() => handleToolbarAction('duplicate')}
              disabled={!selectedClip}
              className={`px-3 py-1 rounded text-xs flex items-center gap-1.5 transition-colors ${
                selectedClip
                  ? 'bg-gray-800 hover:bg-gray-700 text-white'
                  : 'bg-gray-900 text-gray-500 cursor-not-allowed'
              }`}
            >
              <i className="ri-file-copy-line text-[11px]"></i>
              <span>Duplicate</span>
            </button>
            
            <button
              onClick={() => handleToolbarAction('split')}
              disabled={!selectedClip || !canSplit()}
              className={`px-3 py-1 rounded text-xs flex items-center gap-1.5 transition-colors ${
                selectedClip && canSplit() 
                  ? 'bg-gray-800 hover:bg-gray-700 text-white' 
                  : 'bg-gray-900 text-gray-500 cursor-not-allowed'
              }`}
            >
              <i className="ri-scissors-line text-[11px]"></i>
              <span>Split</span>
            </button>
            
            <button
              onClick={() => handleToolbarAction('delete')}
              disabled={!selectedClip && rectSelectedClips.length === 0}
              className={`px-3 py-1 rounded text-xs flex items-center gap-1.5 transition-colors ${
                selectedClip || rectSelectedClips.length > 0
                  ? 'bg-red-900/50 hover:bg-red-800/50 text-red-400 hover:text-red-300'
                  : 'bg-gray-900 text-gray-500 cursor-not-allowed'
              }`}
            >
              <i className="ri-delete-bin-line text-[11px]"></i>
              <span>
                {rectSelectedClips.length > 0 ? `Delete (${rectSelectedClips.length})` : 'Delete'}
              </span>
            </button>
            
            <div className="ml-auto flex items-center gap-4">
              {/* 줌 컨트롤 */}
              <div className="flex items-center gap-1">
                <button
                  onClick={() => handleZoomChange('out')}
                  disabled={Math.round((pixelsPerSecond / 40) * 100) <= 50}
                  className={`px-2 py-1 rounded text-xs flex items-center gap-1 transition-colors ${
                    Math.round((pixelsPerSecond / 40) * 100) <= 50
                      ? 'bg-gray-900 text-gray-600 cursor-not-allowed'
                      : 'bg-gray-800 hover:bg-gray-700'
                  }`}
                  title="줌 아웃 (최소 50%)"
                >
                  <i className="ri-zoom-out-line text-[11px]"></i>
                </button>
                <span className="text-[10px] text-gray-400 min-w-[60px] text-center">
                  {Math.round((pixelsPerSecond / 40) * 100)}%
                </span>
                <button
                  onClick={() => handleZoomChange('in')}
                  disabled={Math.round((pixelsPerSecond / 40) * 100) >= 200}
                  className={`px-2 py-1 rounded text-xs flex items-center gap-1 transition-colors ${
                    Math.round((pixelsPerSecond / 40) * 100) >= 200
                      ? 'bg-gray-900 text-gray-600 cursor-not-allowed'
                      : 'bg-gray-800 hover:bg-gray-700'
                  }`}
                  title="줌 인 (최대 200%)"
                >
                  <i className="ri-zoom-in-line text-[11px]"></i>
                </button>
              </div>
              
              <div className="text-[10px] text-gray-400">
                {rectSelectedClips.length > 0 ? (
                  `${rectSelectedClips.length} selected`
                ) : selectedClip ? (
                  `${selectedClipType === 'video' ? 'Video' : selectedClipType === 'text' ? 'Text' : 'Sound'} clip selected`
                ) : (
                  'Select a clip or drag to multi-select'
                )}
              </div>
            </div>
          </div>
        </div>
        
        {/* Timeline content */}
        <div className="flex overflow-x-auto">
          {/* Left fixed area */}
          <div className="flex-shrink-0 w-48">
            <div className="border-b border-r border-gray-700 p-1 h-8 flex items-center justify-center">
              <span className="text-[10px] text-gray-400 font-medium">Timeline</span>
            </div>
        
            <div className="border-b border-r border-gray-700 h-8 flex items-center justify-center px-2">
              <button 
                onClick={onAddClip}
                className="w-32 h-6 bg-black rounded flex items-center justify-center gap-1.5 hover:bg-gray-900 transition-colors group"
              >
                <i className="ri-add-line text-[13px] text-[#38f47cf9] group-hover:text-white"></i>
                <span className="text-[13px] text-[#38f47cf9] group-hover:text-white">Add Clip</span>
              </button>
            </div>
            
            <div className="border-b border-r border-gray-700 h-8 flex items-center justify-center px-2">
              <button 
                onClick={onAddText}
                className="w-32 h-6 bg-black rounded flex items-center justify-center gap-1.5 hover:bg-gray-900 transition-colors group"
              >
                <i className="ri-text text-[13px] text-[#38f47cf9] group-hover:text-white"></i>
                <span className="text-[13px] text-[#38f47cf9] group-hover:text-white">Add Text</span>
              </button>
            </div>

            <div className="border-r border-gray-700 h-8 flex items-center justify-center px-2">
              <button 
                onClick={onAddSound}
                className="w-32 h-6 bg-black rounded flex items-center justify-center gap-1.5 hover:bg-gray-900 transition-colors group"
              >
                <i className="ri-music-line text-[13px] text-[#38f47cf9] group-hover:text-white"></i>
                <span className="text-[13px] text-[#38f47cf9] group-hover:text-white">Add Sound</span>
              </button>
            </div>
          </div>

          {/* Right scrollable area */}
          <div
            className="flex-1 relative"
            style={{ minWidth: `${timelineLengthInSeconds * pixelsPerSecond}px` }}
            ref={selectionContainerRef}
            onMouseDownCapture={handleSelectionMouseDown}
          >
            {/* Timeline ruler */}
            <div className="border-b border-gray-700 bg-black h-8">
              <div 
                className="flex items-center h-full relative"
                onClick={handleTimelineClick}
                style={{ cursor: 'pointer' }}
              >
                <div className="flex">
                  {timeMarkers.map((time, index) => (
                    <span
                      key={index}
                      className="text-[10px] text-gray-400 inline-flex items-center"
                      style={{ 
                        width: `${pixelsPerSecond}px`,
                        boxSizing: 'border-box',
                        paddingLeft: index === 0 ? '2px' : '0'
                      }}
                    >
                      {time}
                    </span>
                  ))}
                </div>
                {/* 2-minute limit warning line */}
                <div
                  className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-20"
                  style={{ 
                    left: `${120 * pixelsPerSecond}px`,
                    boxShadow: '0 0 4px rgba(239, 68, 68, 0.5)'
                  }}
                  title="2-minute limit"
                />
              </div>
            </div>

            {/* 2-minute limit warning line extending across all tracks */}
            <div
              className="absolute top-8 bottom-0 w-0.5 bg-red-500 opacity-30 z-10 pointer-events-none"
              style={{ 
                left: `${120 * pixelsPerSecond}px`
              }}
            />

            {/* Video track */}
            <TimelineTrack
              type="video"
              clips={clips}
              selectedClips={selectedClip === null ? [] : [selectedClip]}
              rectSelectedClips={rectSelectedClips}
              onClipClick={selectClip}
              onMouseDown={handleMouseDown}
              onResizeStart={handleResizeStart}
              activeClip={activeClip}
              pixelsPerSecond={pixelsPerSecond}
              isSelectingRange={isSelectingRange}
              onTrackClick={handleTrackClick}
            />

            {/* Text track */}
            <TimelineTrack
              type="text"
              clips={textClips}
              selectedClips={selectedClip === null ? [] : [selectedClip]}
              rectSelectedClips={rectSelectedClips}
              onClipClick={selectClip}
              onMouseDown={handleMouseDown}
              onResizeStart={handleResizeStart}
              onEditClip={onEditTextClip as ((clip: TextClipType | SoundClipType) => void) | undefined}
              onDeleteClip={onDeleteTextClip}
              activeClip={activeClip}
              pixelsPerSecond={pixelsPerSecond}
              isSelectingRange={isSelectingRange}
              onTrackClick={handleTrackClick}
            />

            {/* Sound track */}
            <TimelineTrack
              type="sound"
              clips={soundClips}
              selectedClips={selectedClip === null ? [] : [selectedClip]}
              rectSelectedClips={rectSelectedClips}
              onClipClick={selectClip}
              onMouseDown={handleMouseDown}
              onResizeStart={handleResizeStart}
              onEditClip={onEditSoundClip as ((clip: TextClipType | SoundClipType) => void) | undefined}
              onDeleteClip={onDeleteSoundClip}
              onVolumeChange={onUpdateSoundVolume}
              onFadeChange={onUpdateSoundFade}
              activeClip={activeClip}
              pixelsPerSecond={pixelsPerSecond}
              isSelectingRange={isSelectingRange}
              onTrackClick={handleTrackClick}
            />

            {/* Selection box */}
            {isSelectingRange && selectionBounds && (
              <TimelineSelectionBox
                left={selectionBounds.left}
                top={selectionBounds.top}
                width={selectionBounds.width}
                height={selectionBounds.height}
                isActive={false}
              />
            )}

            {/* Active selection box */}
            {isRangeActive && selectionRangeStartX !== null && selectionRangeEndX !== null && 
             selectionRangeStartY !== null && selectionRangeEndY !== null && (
              <TimelineSelectionBox
                left={Math.min(selectionRangeStartX, selectionRangeEndX)}
                top={Math.min(selectionRangeStartY, selectionRangeEndY)}
                width={Math.abs(selectionRangeEndX - selectionRangeStartX)}
                height={Math.abs(selectionRangeEndY - selectionRangeStartY)}
                isActive={true}
                onMouseDown={startMoveSelection}
                onResizeStart={startAdjustSelection}
              />
            )}

            {/* Playhead */}
            <TimelinePlayhead
              position={playheadPosition}
              onMouseDown={handlePlayheadMouseDown}
            />
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

</files>
